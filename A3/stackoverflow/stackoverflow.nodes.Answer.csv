answer_id,link,title,is_accepted,body_markdown,score,uuid
2155,https://stackoverflow.com/a/69272967,Return &#39;biggest fan of a tag&#39; neo4j,true,"The error is here:

```
WHERE COUNT(posted) &lt; 10
```

You need to use these aggregations in a WITH clause as you did with your earlier count in the query.

Change the query to this and it should work:

```
MATCH (b:Blog)-[r:liked]-(p:Post)-[:tagged]-(t:Tag)
WHERE t.content = &quot;dog&quot;
WITH b, COUNT(r) as interaction_count

MATCH (b:Blog)-[posted:posted_by]-(:Post)-[:tagged]-(t:Tag)

WITH b,interaction_count, COUNT(posted) as p
WHERE p&lt;10 

RETURN b, interaction_count
ORDER BY interaction_count DESC
LIMIT 10
```

The only difference is that I broke your &quot;WHERE&quot; into a &quot;WITH/WHERE&quot; pattern",1,69272967
2156,https://stackoverflow.com/a/69267009,How to simplify neo4j query with multiple CASE&#39;s,false,"perhaps something along the line of this, using COALESCE to avoid the nested CASE

    WITH COALESCE(ljCase1,ljCase2,ljCase3) AS myCase
    WITH CASE myCase 
             WHEN x THEN ..
             WHEN y THEN ..
             ELSE ..
         END",0,69267009
2157,https://stackoverflow.com/a/69263731,Returning same path after &quot;count&quot; operation in Neo4J,true,"Without testing, I think this would solve the issue:

    MATCH path=(pe:person)-[:VISITED]-&gt;(ba:bank)-[:MADE]-&gt;(pa:payment)-[:TO]-&gt;(bu:business)
    WHERE condition1
    AND condition2
    AND condition3
    WITH pe, bu, COLLECT(path) AS paths, COUNT(DISTINCT ba) as banks
    WHERE banks &gt; 1
    UNWIND paths AS path
    RETURN path",1,69263731
2158,https://stackoverflow.com/a/69263260,Neo4j - Get the relationship that have the latest timestamp,true,"these are a couple of options depending what you exactly need

    //the highest timestamp overall
    MATCH (n:Node)-[r:REL]-&gt;(m:Node)
    RETURN MAX(r.timestamp)
    
    //the highest timestamp per nodepair
    MATCH (n:Node)-[r:REL]-&gt;(m:Node)
    RETURN id(n),id(r),MAX(r.timestamp)
    
    //the relationship with highest timestamp per nodepair
    MATCH (n:Node)-[r:REL]-&gt;(m:Node)
    WITH n,m,r,r.timestamp AS rel ORDER BY r.timestamp  DESC
    RETURN n,m,collect(r)[0] AS rWithHighestTimestamp

",0,69263260
2159,https://stackoverflow.com/a/69263576,Neo4j modeling relationship query,true,"I think the definition of &#39;competing&#39; should be more explicit. From the diagram you post, my common sense is that they compete on A and B, because they are both offering these products.

Putting an array of product(ids) on the COMPETES rel could work, but is not very &#39;graphy&#39;

I would add (:Competition) nodes, and link them to each of the competing companies, as well as to specific products. The advantage would be that you can use this node, or the rel to store data on the type of competition (price, quality).

[![Graph model][1]][1]

Another approach (perhaps even better) would be to create :(:Offering) nodes between the company and the products, and create [:COMPETES] rels between the competing offerings.

[![Graph model 2][2]][2]


  [1]: https://i.stack.imgur.com/91Wn9.png
  [2]: https://i.stack.imgur.com/GNHLD.png",1,69263576
2160,https://stackoverflow.com/a/69251760,How to add additional stop words to a Neo4j Full-text analyzer,false,"AFAIK, it is not possible to write a custom analyzer without writing a plugin. Luckily, you can copy some of the existing code for your custom analyzer.
For example, you can take a look at the covidgraph custom analyzer:

https://github.com/covidgraph/neo4j-additional-analyzers


    @Service.Implementation(AnalyzerProvider.class)
    public class SynonymAnalyzerProvider extends AnalyzerProvider {
    
        public static final String DESCRIPTION = &quot;analyzer using synonyms&quot;;
        public static final String ANALYZER_NAME = &quot;synonym&quot;;
    
        public SynonymAnalyzerProvider() {
            super(ANALYZER_NAME, new String[0]);
        }
    
        public Analyzer createAnalyzer() {
            try {
                return CustomAnalyzer.builder()
                        .withTokenizer(WhitespaceTokenizerFactory.class)
                        .addTokenFilter(SynonymFilterFactory.class, &quot;synonyms&quot;, &quot;gene_symbols.txt&quot;, &quot;ignoreCase&quot;, &quot;true&quot;)
                        .addTokenFilter(StopFilterFactory.class, &quot;format&quot;, &quot;snowball&quot;, &quot;words&quot;, &quot;org/apache/lucene/analysis/snowball/english_stop.txt,org/apache/lucene/analysis/snowball/german_stop.txt&quot;, &quot;ignoreCase&quot;, &quot;true&quot;)
                        .addTokenFilter(LowerCaseFilterFactory.class)
                        .build();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    
        @Override
        public String description() {
            return DESCRIPTION;
        }
    }

Specifically, it seems that the stop-words are added in the following line:

    .addTokenFilter(StopFilterFactory.class, &quot;format&quot;, &quot;snowball&quot;, &quot;words&quot;, &quot;org/apache/lucene/analysis/snowball/english_stop.txt,org/apache/lucene/analysis/snowball/german_stop.txt&quot;, &quot;ignoreCase&quot;, &quot;true&quot;)
",0,69251760
2161,https://stackoverflow.com/a/69273018,Neo4j query using only one core of my machine,false,"You can use `CALL apoc.periodic.iterate()` to do parallel executions, using the `parallel: true` parameter that you add to options.

However -- normally these are for write operations, and your query is a read.  It&#39;s not clear what you want to do in terms of a parallel read here.

Normally, to parallelize a read, you break it into multiple paginated reads, and have multiple different queries executing.  Like let&#39;s take this bit as the core &quot;body&quot; of your query:

```
MATCH p=(a:address)-[r*]-&gt;(b:address)
WHERE NOT (b)-[]-&gt;(:address)
WITH a,b, LAST(nodes(p)) as c,length(p) as depth
RETURN a.add_id, c.add_id,max(depth)
```

to parallelize reads on this, I would do say 3 different queries, each ending with a different ending:

`ORDER BY a.add_id SKIP 0 LIMIT 100`

`ORDER BY a.add_id SKIP 100 LIMIT 100`

`ORDER BY a.add_id SKIP 200 LIMIT 100`

...and so on.  Each gives you a page of 100 results
",0,69273018
2162,https://stackoverflow.com/a/69255357,Substitute for @additionalLabels in Neo4j GraphQL 2.0,true,"There is no workaround for this at this time(20/09/2021), however, we merged [this](https://github.com/neo4j/graphql/pull/475) pull request a few days ago, that includes your desired functionally. It will be released very soon. ",0,69255357
2163,https://stackoverflow.com/a/69253457,Graphileon Proxy Feature issue,true,"The `body` must also be JSON so you need to do:

```
var body = JSON.stringify({
                    url: schemaUrl,
                    method: &#39;POST&#39;,
                    body: JSON.stringify({
                            state : &quot;*&quot;,
                            bucket:
                            [
                                {name: &quot;Ram&quot;, tr1: &quot;TR1&quot;, TC1: 1}
                            ]
                        })
                });
```",1,69253457
2164,https://stackoverflow.com/a/69256380,Neo4j Procedure and Transactions,false,"I figured this out and will share for those it may help.  In Class 3, you need to both import the Log and Transaction interfaces and use the decorators (which I knew already):

```// Class 3
import import org.neo4j.graphdb.Transaction;
import org.neo4j.procedure.Context;
import org.neo4j.logging.Log;

public class Class 3 {
     @Context
    Public Transaction tx;
    @Context
    Public Log log;

    // Put your Methods Here
    

    // Put your constructor Here
    // Constructor
    public Class3v(Log log, Transaction tx) {
        this.log = log;
        this.tx = tx;
    }
}

```
Then, in the main class where you wrote your procedure, you need to &quot;pass&quot; the log and tx instances you created in that procedure to the above helper class 3 like so:

```
// Class1
import import org.neo4j.graphdb.Transaction;
import org.neo4j.procedure.Context;
import org.neo4j.logging.Log;

public class Class1 { 
     

    public     @Context
    public Log logClass1;
    @Context
    public Transaction txClass1;

    @Procedure(value = &quot;WHATEVER&quot;, mode = Mode.WRITE)
    @Description(&quot;WHATEVER&quot;)
    public Stream&lt;ReturnRecord&gt; nameOfClass1 () {

        //  Other Stuff
        // Create Instance of Class 3 Object
        Class3 instanceOfClass3Object = new Class3 (logClass1, txClass1);
     
       
        return Stream.Of(new ReturnRecord());    
    }
    
    public class ReturnRecord () {
        // WHATEVER YOU HAPPEN TO HAVE HERE
    }
}",0,69256380
2165,https://stackoverflow.com/a/69273049,Kubernetes pod FileLockException: Lock file has been locked by another process - neo4j 4.2,false,"Using google filestore in lieu of regular persistent volume claims is not recommended; for performance reasons Neo4j needs high speed, performant local disks, typically they recommend SSDs.  Using a filestore like cloud abstraction, if it works, is likely to result in degraded performance.

Now in general, the error you&#39;re seeing refers to files on disk being locked by a different process.  This can happen because a previous (crashed) version of Neo4j locked it, or it could be due to volume issues, here is where you&#39;d have to research deep into how filestore provides a POSIX complaint drive on something like GKE.",0,69273049
2166,https://stackoverflow.com/a/69213660,In Cypher can I check if a property is a list before updating its value,false,"You will need to use the APOC library to inspect a property type:

    MATCH (a:part) 
    WHERE NOT  apoc.meta.isType(a.serials) = &quot;LIST&quot;
    SET a.serials=[] 
    return a

You can check the docs for more info: https://neo4j.com/labs/apoc/4.1/overview/apoc.meta/apoc.meta.isType/",1,69213660
2167,https://stackoverflow.com/a/69237480,In Cypher can I check if a property is a list before updating its value,true,"Cypher has no built-in function for this but there is a small hack you can use that is checking if adding an element to the property would increase its size by 1 , for eg 

```
MATCH (n:Award)
RETURN size(n.years + 11) = size(n.years)+1 AS isList
```

`+` sign, add elements, concat or sums. Therefore to differentiate a a string from an array, we need to add two digits.",1,69237480
2168,https://stackoverflow.com/a/69220594,How to Exclude nodes from Path in Cypher?,false,"What about:

```
MATCH path=(b:BaseHierarchy)-[:INCLUDES]-&gt;(n)-[:PARENT_OF*]-&gt;(inc:Client) 
WHERE n.code = &#39;ARNOG&#39; AND 
      NONE(node IN nodes(path) WHERE node.code IN [&#39;1V2ZG&#39;])
WITH b, nodes(path) AS nodes, relationships(path) AS relationships 
RETURN b,
       apoc.coll.toSet(apoc.coll.flatten(collect(relationships))) as relationships,
       apoc.coll.toSet(apoc.coll.flatten(collect(nodes))) as nodes;
```
?",0,69220594
2169,https://stackoverflow.com/a/69208991,Is there any way to find out maximum value from property in Neo4j?,true,"The quotation marks in your query results indicate that this property is stored as a string. The `order by` is therefore alphabetical, not numeric. Try casting the results (or the property itself) [to an int][1].


  [1]: https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-tointeger",1,69208991
2170,https://stackoverflow.com/a/69203303,MERGE with UNWIND Issue Neo4j,true,"**Merge** requires a field(s) which you need to be unique like `name` in this case. If you don’t provide it then it will create only one node and add the values of the last node.

You can modify your code as below if `name` is the only property.

    WITH $batch AS batch
    UNWIND batch as ind
    MERGE (n:Friend{name: ind.name})


In case there are more properties:

    WITH $batch AS batch
    UNWIND batch as ind
    MERGE (n:Friend{name: ind.name})
    SET n += ind

",2,69203303
2171,https://stackoverflow.com/a/69189387,Using Selenium to Input Cypher Commands into Neo4j,false,"the question is very unclear!But I realized that you need to enter something in span
try use 

    wait.until(EC.visibility_of_element_located(
			(By.CSS_SELECTOR, &#39;#your selector&#39;))).send_keys(&#39;&#39;)",0,69189387
2172,https://stackoverflow.com/a/69178622,Cypher - get all associated relationships for a node,true,"For a single query: probably something like this would do what you&#39;re looking for (untested, since I don&#39;t have your data, but... should be close):

```sql
MATCH (doc:Doctor {id=1000000})&lt;-[:PATIENT_AT]-(pat:Patient)-[:HAS_DIAGNOSIS]-&gt;(diag:Diagnosis)
return doc,pat,collect(diag)
```

This particular query ignores the direct relationship between `(:Doctor)` and `(:Diagnosis)` but I don&#39;t think it&#39;s needed for the results you&#39;re looking for, since each patient is associated with the diagnoses.",2,69178622
2173,https://stackoverflow.com/a/69202642,How to save multiple labels of a node in neo4j in a specified order?,false,"Can you clarify the problem? There are times when analytics or visualizations benefit from multiple labels. I&#39;m making some assumption by creating the framework (which you should do in future questions). Is this your scenario? I&#39;ve added another Label &quot;Node&quot;

    create (n1:Node)
    create (n2:Node)
    create (n3:Node)
    
    with n1,n2,n3
    match (n1) set n1:CreativeWork 
    with n1,n2,n3
    match (n1) set n1:ImageProject 
    with n1,n2,n3
    with n1,n2,n3
    match (n1) set n1:MediaProject 
    with n1,n2,n3
    match (n1) set n1:Thing 
    
    with n1,n2,n3
    match (n2) set n1:CreativeWork 
    with n1,n2,n3
    match (n2) set n1:ImageProject 
    with n1,n2,n3
    match (n2) set n1:MediaProject 
    with n1,n2,n3
    match (n2) set n1:Thing 
    
    with n1,n2,n3
    match (n3) set n1:CreativeWork 
    with n1,n2,n3
    match (n3) set n1:MediaProject 

If so, what is it you&#39;re trying to do. The display you showed is the node labels are they would appear in the results window after running a query.There is not a way to change that sort order. But why is that sort important to you? It&#39;s not something an end user will see. You actually have only 3 nodes and they would all be visualized similarly. 

Can you achieve you goal using properties? If not every node has 3Labels, then you could use a grass file to distinguish them. The grass file processes the formatting by the order (bottom to top) the nodes appear in the listing. 
",0,69202642
2174,https://stackoverflow.com/a/69176385,Adding relationships between an array of array of objects in Neo4j Cypher,false,"I don&#39;t think you need to UNWIND all arrays

    WITH $orgs AS orgs,
         $locs AS locs,
         $contacts AS contacts
    
    UNWIND $orgs as orgs


    FOREACH (i IN range(0, size(orgs) - 1) |
        MERGE (org:Organization { id: orgs[i].id })
        MERGE (loc:Location {id: locs[i].id})
        MERGE (contact:Contact {id: contacts[i].id})
        MERGE (org)-[:LOCATED_AT]-&gt;(loc)
        MERGE (org)-[:CONTACT_AT]-&gt;(contact)
    )

should do it",1,69176385
2175,https://stackoverflow.com/a/69179739,Adding relationships between an array of array of objects in Neo4j Cypher,false,"A solution was posted in the official Neo4j site. I&#39;m sharing here as well. 

    UNWIND range(0, size($orgs) - 1) as i
    with i
    MERGE (o:Organization { id: $orgs[i].id })-[r:LOCATED_AT]-&gt;(l:Location {id: $locs[i].id}) 
    with o, i
    MERGE (o)-[r2:CONTACT_AT]-&gt;(l2:Contact {id: $contacts[i].id})

Link to original [answer][1]


  [1]: https://community.neo4j.com/t/adding-relationships-between-an-array-of-array-of-objects/44343/3",0,69179739
2176,https://stackoverflow.com/a/69164283,Neo4j-4.1 Relationship property match queries are running slow even after creating indexes on it,true,"You want to update to Neo4j 4.3 where relationship indexes were introduced. Here is a [complete list][1] of what is new in Neo4j 4.3, but the most relevant for you are:

**Relationship and Relationship Property Indexes**
*Fast, Scalable Relationship Query Performance*

A highly requested feature over the years by the community that we’re happy to finally introduce: Relationship type lookup indexes and relationship property indexes. These offer up new modeling capabilities, and significantly speed up many kinds of queries, by making it possible to index relationship types and properties.


  [1]: https://neo4j.com/product/neo4j-graph-database/whats-new-in-neo4j-4-3/",1,69164283
2177,https://stackoverflow.com/a/69152000,Neo4j: Sequence of Events as Nodes Not working,false,"This will be a two step process. First the initial loading of the data as you have outlined. Then an enhancement in which you create the NEXT relationships. We do this in healthcare analytics of patient journeys or trajectories. By analogy, your yellow nodes might be a patient and the blue one an encounter. So each patient has a sequence of encounters.

You can query and sort by the date or other ordering variable. For example, collect a sorted list of encounters:

    match (e:encounter) with e order by e.enc_date with e.subjectId as sid,collect(distinct e.enc_date) as eo return sid,size(eo) as ct,eo

I used this in some python code to then iterate through the collection to create the enc_seq edge, equivalent to your NEXT:

    &gt; dfeo = Neo4jLib.CypherToPandas(&quot;match (e:encounter) with e order by e.enc_date with e.subjectId as sid,collect(distinct e.enc_date) as eo return sid,size(eo) as ct,eo&quot;,&#39;ppmi&#39;)
        csv = dfeo.to_csv(index=False).split(&#39;\n&#39;)
        cts=0
        sw = open(&quot;c:\\temp\\error.txt&quot;,&quot;a&quot;)
        for i in range(1,len(dfeo)):
            cc = csv[i].split(&#39;,&#39;)
            for j in range(0,int(cc[1])-1):
                try:
                   q= &quot;match (e1:encounter{subjectId:&quot; + str(dfeo[&#39;sid&#39;][i]) + &quot;,enc_date:date(&#39;&quot; + str(dfeo[&#39;eo&#39;][i][j]) + &quot;&#39;)}) match (e2:encounter{subjectId:&quot; + str(dfeo[&#39;sid&#39;][i]) + &quot;,enc_date:date(&#39;&quot; + str(dfeo[&#39;eo&#39;][i][j+1]) + &quot;&#39;)}) merge (e1)-[r:enc_seq{subjectId:&quot; + str(dfeo[&#39;sid&#39;][i]) + &quot;, seqCt:&quot; + str(j) + &quot;}]-(e2)&quot;
                   Neo4jLib.CypherNoReturn(q,&#39;ppmi&#39;)
                except:
                   cts = cts + 1  
                   sw.write(str(i) + &#39;:&#39; + str(j) + &quot;\n&quot;+ q + &quot;\n&quot;)            
        print(&quot;exceptions: &quot; + str(cts))
        sw.flush()
        sw.close()

You can probably do this within a cypher query using a WITH (each row) followed by a  CALL to a function similar to my python code. For my purposes it was more convenient to use python.
    


    ",0,69152000
2178,https://stackoverflow.com/a/69209042,An error occurred! Unable to start in just one database on server,true,"There are [more detailed logs][1] you should be looking at to debug this. I would start with neo4j.log and then debug.log if that doesn&#39;t answer your question.


  [1]: https://neo4j.com/docs/operations-manual/current/monitoring/logging/",0,69209042
2179,https://stackoverflow.com/a/69133223,"new Neo4jGraphQL({ typeDefs, driver }) causes Unknown directive error",true,You can&#39;t use infer schema for `@neo4j/graphql`(The official Neo4j GraphQL lib) and it&#39;s only to be used with the deprecated `neo4j-graphql-js`. You are trying to put a `neo4j-graphql-js` compatible schema into `@neo4j/graphql`. You should change `@relation` to `@relationship` and for relationship properties please refer to [this](https://neo4j.com/docs/graphql-manual/2.0/type-definitions/basics/#_relationship_properties). ,1,69133223
2180,https://stackoverflow.com/a/69130980,Cannot merge the following node because of null property value for &#39;name&#39;:,false,"Csv need coma only and that&#39;s work ...
",-2,69130980
2181,https://stackoverflow.com/a/69133687,Cannot merge the following node because of null property value for &#39;name&#39;:,false,"ry this

&gt; LOAD CSV WITH HEADERS FROM &quot;file:///C:/test1.csv&quot; AS line MATCH
&gt; (n:SiteA {name: line.SiteA}) where n.name is not null MATCH (m:SiteB
&gt; {name: line.SiteB}) where m.name is not null MERGE (n)
&gt; -[:has_device_function]-&gt; (m);

Two things to notice: filtering out nulls and using MATCH rather than merge in the initial extraction of the nodes for the new relationship.
",0,69133687
2182,https://stackoverflow.com/a/69133820,Cannot merge the following node because of null property value for &#39;name&#39;:,false,In order to easily avoid this kind of problem I usually pass a default value on null items for my CSV (usually DELETE_ME_PLEASE). Then I&#39;ll just match and delete nodes with this.,0,69133820
2183,https://stackoverflow.com/a/69142288,Cannot merge the following node because of null property value for &#39;name&#39;:,false,"First, just to be sure: this means that there are rows in your CSV that have an empty name column.

That said, you can remove lines from the CSV before continuing your query:
```
LOAD CSV WITH HEADERS FROM &quot;file:///C:/test1.csv&quot; AS line
WITH line WHERE line.name IS NOT NULL
MERGE (n:SiteA {name: line.SiteA})
MERGE (m:SiteB {name: line.SiteB})
MERGE (n) -[:has_device_function]-&gt; (m);
```",0,69142288
2184,https://stackoverflow.com/a/69142736,Dump a Graph from Neo4j with pickle in python,true,"I guess you get this error because you&#39;re not just trying to dump the nodes and relationships, but the whole instance of the Graph class, including functions, etc.

It&#39;s not clear to me how the dump will help you achieve your goal.  
This answer looks promissing though: https://stackoverflow.com/a/31809054/2403344  
The idea is to create a Python iGraph from your Neo4j DB.
This could then be pickled etc.",1,69142736
2185,https://stackoverflow.com/a/69142782,Dump a Graph from Neo4j with pickle in python,false,"What you need to do is to implement `__getstate__` and `__setstate__`. See [here][1] for an example. I think you will have to extend `Graph` in order to implement those methods.


  [1]: https://docs.python.org/3/library/pickle.html#handling-stateful-objects",0,69142782
2186,https://stackoverflow.com/a/69128263,throws NoRootNodeMappingException while projecting/mapping neo4j query result to an interface or DTO class,false,"If you specify edge types the should have a colon, so 
[:STEPTAKER] and [:CONTACT]

Also , when returning multiple columns, separate them by a comma

RETURN a.name AS name,  s.count AS count",0,69128263
2187,https://stackoverflow.com/a/69130615,Error with spring data neo4j java.lang.NoSuchMethodError: org.springframework.web.util.ServletRequestPathUtils.setParsedRequestPath,true,"You have duplicated `spring-web` dependency and in one of them, you explicitly set the version. Don&#39;t do this and rely on `spring-boot-starter-parent` transitive dependencies and versions.

You also have `spring-boot-starter-web` dependency which has `spring-web` as a transitive dependency, so you don&#39;t need `spring-web`. Having said that, please delete the following ones:

```xml
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
    &lt;version&gt;5.3.2&lt;/version&gt;
&lt;/dependency&gt;
```",0,69130615
2188,https://stackoverflow.com/a/69120598,Neo4j Create Nodes without Creating Duplicates Nodes,true,"You can just use `MERGE` and there will never be any duplicates:

    LOAD CSV WITH HEADERS FROM &#39;&#39; as row
    MERGE (n:User{user_name:row.User_Name})
    MERGE (r:UserId{user_id:row.User_ID})
    ..",1,69120598
2189,https://stackoverflow.com/a/69142934,Python neo4j return relationship properties,true,"I couldn&#39;t reproduce the issue.  
Using Python 3.8.10, neo4j 4.3.4 (pip install neo4j) and neo4j DBMS 4.3.3  
I took the movie example database and ran this code:
```
with driver.session() as session:
    result = session.run(&quot;MATCH (Person)-[r:ACTED_IN]-&gt;() RETURN * LIMIT 1&quot;)
    for record in result:
        pprint(record[&quot;r&quot;][&quot;roles&quot;])
driver.close()
```
The output is `[&#39;Shane Falco&#39;]` which is correct (the property of the ACTED_IN relationship.

That said, I realised that RETURN * will only return &quot;named&quot; nodes and relationships (those that you assigned to variables).  
You can see this in the table view in Neo4J Browser:  
Running `MATCH (p:Person)-[:ACTED_IN]-&gt;(m:Movie) RETURN * LIMIT 1` will only return p and m, NOT THEIR RELATIONSHIP.",1,69142934
2190,https://stackoverflow.com/a/69100884,Get all nodes with a specific type of relationship to a root node,true,"you need to change the order of the rel type and wildcard operator:

    Match (n:NODE_TYPE)-[:REL_TYPE*]-&gt;(r:NODE_TYPE {id:SPECIFIC_ID}) 
    return n

",1,69100884
2191,https://stackoverflow.com/a/69094473,"In Neo4j, is there anyway to create a graph projection if your graph is too big to fit in memory? The estimate is 152GB for my very large graph",false,"Well, it&#39;s not a definitive answer, since it would depend on your needs with this processed data.

You may try to create clusters, using the write method (writes the cluster id directly as a property in memory), or any kind of community like that before, and run an algorithm for each of these clusters.

This way you could iterate through each community in order to create other graphs (that would probably fit your RAM size) and work with your whole data. The downside of this is that your results won&#39;t be 100% equal if you could project the whole graph in memory in order to apply the algorithms, but in this case (not enough RAM) I believe it&#39;s a good trade.",0,69094473
2192,https://stackoverflow.com/a/69078499,Neo4j / Cypher - find path but middle nodes of this path can&#39;t be of type X,true,"I think something like this:

    MATCH p=shortestPath((startNode)-[*..10]-(endNode))
    WHERE none(node IN nodes(p)[1..-1] WHERE node:X)

The key is to omit the first and the last node from the filter like so:

    nodes(p)[1..-1]",0,69078499
2193,https://stackoverflow.com/a/69087580,Neo4j / Cypher - find path but middle nodes of this path can&#39;t be of type X,false,"This is worth reading, in order to try to avoid that Cypher falls back to the slow algo

https://neo4j.com/docs/cypher-manual/current/execution-plans/shortestpath-planning/",0,69087580
2194,https://stackoverflow.com/a/69089237,Return top % of results in Neo4J,false,"Answering my own question (again), in case someone else is looking up the same issue

```
MATCH (s:Student)-[:READ]-&gt;(b:Book)
WITH s, COUNT(b) AS no_of_books
ORDER BY no_of_books DESC
WITH COLLECT ({Student_Name: s.Name, No_of_Books: no_of_books}) AS books_per_stu
WITH books_per_stu, toInteger(size(books_per_stu)/100) AS percentile
UNWIND book_per_stu[0..percentile] AS top_stu
RETURN top_stu
```

Seems like, surprisingly, there&#39;s no straightforward way to do this, like my pseudo-code in my first post. The above syntax will return the results as a list of dictionaries rather than in a tabular format. I still welcome any answer that&#39;s simpler than mine.",0,69089237
2195,https://stackoverflow.com/a/69093785,Neo4j - Is it possible to select a shortest path where nodes with a certain label have a particular value?,true,"Not sure how optimized this is, but it probably does the job. Basically we introduce a nested list comprehension syntax:

    MATCH (a:Test {id: &#39;1&#39;} ),
      (e:Test {id: &#39;5&#39;}),
      p = shortestPath((a)-[:REL*]-(e))
    WHERE all(r IN [x in nodes(p) where x:Foo] WHERE r.type = &#39;car&#39;)
    RETURN p ",0,69093785
2196,https://stackoverflow.com/a/69044262,How do i follow a specific pattern of multiple nodes/relationships any number of times through a graph?,false,"for these situations, with rels in both directions (which makes &quot;downstream&quot; an unclear concept) ,I suggest to use apoc : https://neo4j.com/labs/apoc/4.1/overview/apoc.path/apoc.path.expandConfig/

You can also try 


    MATCH (I0)-[:requires|provides*]-(F1)
    
But this is risky given the probability of looping and again, the bi-directionality.",0,69044262
2197,https://stackoverflow.com/a/69071922,"Neo4j | Cypher - given node A, show me path to node B of C type which has more than X children of D type",true,"I guess the query was just too big to handle for neo4j as I have 5,000,000+ nodes.",0,69071922
2198,https://stackoverflow.com/a/69044207,Can&#39;t query created nodes from apoc.load.xml,true,"apparently the `name` property contains an array after import, in which case this should work

    match(n:Element) 
    where n.name[0] = &quot;element1&quot; 
    return n

 OR 

    match(n:Element) 
    where &quot;element1&quot; IN n.name 
    return n",1,69044207
2199,https://stackoverflow.com/a/69041865,Which Version of neo4j Does the Grails Plugin Support?,true,"The source is here: https://github.com/grails/gorm-neo4j.
It only works with [Neo4j 3.x][1], hence the old parameter syntax (`{param}` instead of the newer `$param`).


  [1]: https://github.com/grails/gorm-neo4j/blob/0812e0cd1061c0459c3588f5d5e38520ac3db5e0/gradle.properties#L20",1,69041865
2200,https://stackoverflow.com/a/69039643,Return destination nodes available to Node B that can&#39;t be accessed from Node A,false,"This should do it

    MATCH (b:User {name:&#39;B&#39;})
    WITH b
    MATCH (a:User {name:&#39;A&#39;})
    WITH a,b
    MATCH (b)-—&gt;(r:Repository)
    WHERE NOT EXISTS((a)--&gt;(r))
    RETURN r.name",1,69039643
2201,https://stackoverflow.com/a/69045220,Return destination nodes available to Node B that can&#39;t be accessed from Node A,false,"Since you don&#39;t need to return userA, you can write your query like this. Do a profiling and you will see that this is more efficient query. 

    MATCH (b:User {name:&#39;B&#39;})-—&gt;(r:Repository)
    WHERE NOT EXISTS((:User {name:&#39;A&#39;})--&gt;(r))
    RETURN r.name",0,69045220
2202,https://stackoverflow.com/a/69030732,Neo4j - find nodes of type A which have more than X children of type B,true,"This returns the Parent nodes that have &gt; 3 Child nodes related through R

    MATCH (Parent:typeA)
    WHERE SIZE([(Parent)-[R]-(Child:typeB) | Child]) &gt; 3
    RETURN Parent

or this, if you need the children

    MATCH (Parent:typeA)-[R]-(Child:typeB)
    WITH Parent, COLLECT(Child) AS children
    WHERE SIZE(children) &gt; 3
    RETURN Parent,children



",1,69030732
2203,https://stackoverflow.com/a/69016873,What is the difference between those two match requests that excluding a relationship type?,false,"The WHERE in the first statement tests the endNode. In the second, it is about the existence of an connection.

The first statement only returns users that have a rel to Test1  nodes that are not Test2

The second one returns users that do have a rel to Test1, but not to Test2",0,69016873
2204,https://stackoverflow.com/a/69106124,Neo4j: Cypher query to parallelize a row of the result from a previous query,true,"For paralelizing, apoc is your friend, specifically the `apoc.periodic.iterate` procedure. In your usecase you can parallelize as you are only updating a property of a single node in each row.

The resulted query would look something like:

    CALL apoc.periodic.iterate(&quot;
    match (s:Sentence) RETURN s&quot;,
    &quot;
    match (s)-[r:RELATED]-(t:Sentence)
    with s as sentence, collect(t.embedding) as neighbours
    with sentence, [
        w in reduce(s=[], neighbour IN neighbours | 
        case when size(s) = 0 then
        neighbour else [
            i in range(0, size(s)-1) |
            s[i] + neighbour[i]] end) |
            w / tofloat(size(neighbours))
        ] as average
     
     with sentence, [
         i in range(0, size(sentence.embedding)-1) |
         (0.8 * sentence.embedding[i]) + (0.2 *average[i])
     ] as unnormalized
     
     with sentence, unnormalized, sqrt(reduce(sum = 0.0, element in unnormalized | sum + element^2)) as divideby
     set sentence.normalized = [
         i in range(0, size(unnormalized)-1) | (unnormalized[i] / divideby)
     ]&quot;, {batchSize:1000, parallel:true})

You can play around with the batchSize parameter. For more information look at the [docs][1].


  [1]: https://neo4j.com/labs/apoc/4.2/overview/apoc.periodic/apoc.periodic.iterate/",0,69106124
2205,https://stackoverflow.com/a/69035514,LOAD CSV: mulitple MERGE and Eager operator,false,"You have an RRF file and load CSV requires a CSV line. When you reference a field in the csv you need to include the data type and your tag (line). You also need the periodic commit number of rows per iteration. Your file needs to be in the import folder of your database.

For example:

    USING PERIODIC COMMIT 5000
    LOAD CSV FROM &#39;file:///MRCONSO.RRF&#39; AS line FIELDTERMINATOR &#39;|&#39;
    MERGE (c:Concept {cui: toInteger(linecui),language: toString(line.language})



",-1,69035514
2206,https://stackoverflow.com/a/69014746,"Pentaho SSH communication to Neo4j suddenly fails with `IOException: Cannot negotiate, proposals do not match.`",false,"My colleague later noticed that neo4j:4.2.3 image was [repushed][1] and its new version is built upon Debian Bullseye. By comparing with computer where new version of neo4j was not yet pulled we realized that version of openssh was changed from 7.9p1-10 to 8.4p1-5. (`dpkg --list | grep openssh`). Then we were easily able to reproduce the bug locally and prove that PDI works against old Neo4j image but fails against new image.

One option was to tweak updated Neo4j image and force downgrade openssh to previous version. This would probably work, however it would close the gate to any upgrades, patches and limited room for manoeuvre in case of any problems. Hence we decided the right solution was to upgrade client.

Our version of the Pentaho PDI (dictated btw by customer) utilizes [trilead-ssh2 library build 213][2]. Unfortunately, with newer versions (tried 217 and the newest 222) it failed too. Replacing library by [Jenkins fork build 217][3] made ssh communication ultimately working again. It seems the essential part of success is [pull request #60][4] which adds new KEX algorithms. The fork needs two dependencies ([eddsa][5] in central maven repo and jbcrypt which I could find neither in central nor in Spring repo but it can be found [here][6]) which must be copied into Pentaho PDI `data-integration/lib` directory as well.

  [1]: https://hub.docker.com/layers/neo4j/library/neo4j/4.2.3/images/sha256-b7438470eea50709352dce23e7507e9f6580406e03afd229661a5e52d8e7a11f?context=explore
  [2]: https://mvnrepository.com/artifact/com.trilead/trilead-ssh2
  [3]: https://mvnrepository.com/artifact/org.jenkins-ci/trilead-ssh2/trilead-ssh2-build-217-jenkins-17
  [4]: https://github.com/jenkinsci/trilead-ssh2/pull/60
  [5]: https://mvnrepository.com/artifact/net.i2p.crypto/eddsa
  [6]: https://mirrors.huaweicloud.com/repository/maven/org/connectbot/jbcrypt/jbcrypt/1.0.0/",0,69014746
2207,https://stackoverflow.com/a/69013233,Neo4J checking if a user follows me back,false,"You can do it by adding an OPTIONAL MATCH of the reverse path and then assigning this path to a variable. Then you test the length of the variable in the RETURN using a CASE statement to get the results

E.G.
```
MATCH (ua:User {name:&quot;bob&quot;})-[:Follows]-&gt;(ub:User {name:&quot;Bill&quot;})
OPTIONAL MATCH p = (ub)-[r:Follows]-&gt;(ua)
RETURN ua.name, ub.name, CASE WHEN LENGTH(p) &gt; 0 THEN &#39;yes&#39; ELSE &#39;no&#39; END AS follows_back
```

This would return either:
  &quot;bob&quot;, &quot;bill&quot;, &quot;yes&quot;
or 
  &quot;bob&quot;, &quot;bill&quot;, &quot;no&quot;
",1,69013233
2208,https://stackoverflow.com/a/69013902,Neo4J checking if a user follows me back,true,"this query will give you the followers of A and a true|false for each of them indicating if (s)he follows back

    MATCH (ua:User {name:&quot;bob&quot;})-[:Follows]-&gt;(ub:User)
    RETURN ub.name AS ubName,
           EXISTS((ub)-[:Follows]-&gt;(ua)) AS followsBack",1,69013902
2209,https://stackoverflow.com/a/69016183,Cypher - order by rarity of type of child node,false,"I tested below query using the Movie database.

- Collect parent, child, R and child degree and put all child degree in a list (collect_nodes)
- Create a range of index to accumulate the sum of child degrees (range_idx)
- From 0 to the number of rows, get a running sum of degrees
- From each parent, child, R and child degree, check if sum_degree &lt;= 35 
- Return the parent, child, R and child degree

You cannot get the exact rows that equals 35 because what you limit is the number of rows and not the child degrees.  Also, show us sample data to work on so that we can give you the best answer

    MATCH (Parent)-[R]-(Child) WHERE ID(Parent)=$parentId
    CALL {
        WITH Child
        RETURN apoc.node.degree(Child) as ChildDegree
    }
    WITH Parent, Child, type(R) as R, ChildDegree ORDER BY R, ChildDegree
    WITH collect({p:Parent, c:Child, r: R, cd:ChildDegree }) as collect_nodes, collect(ChildDegree) as collect_degs
    WITH collect_nodes, collect_degs, RANGE(0, SIZE(collect_degs)-1) AS range_idx
    UNWIND range_idx as idx
    WITH collect_nodes[idx] as nodes, REDUCE(acc = 0, value in (collect_degs[idx] + collect_degs[..idx]) | acc + value) AS sum_degree
    UNWIND nodes as n_set
    WITH n_set.p as Parent, n_set.c as Child, n_set.r as R, n_set.cd as ChildDegree WHERE sum_degree &lt;= 35
    RETURN Parent, Child, R, ChildDegree 

Sample result:

    ╒═══════════════════════════╤══════════════════════════════════════════════════════════════════════╤══════════╤═════════════╕
    │&quot;Parent&quot;                   │&quot;Child&quot;                                                               │&quot;R&quot;       │&quot;ChildDegree&quot;│
    ╞═══════════════════════════╪══════════════════════════════════════════════════════════════════════╪══════════╪═════════════╡
    │{&quot;name&quot;:&quot;Jessica Thompson&quot;}│{&quot;name&quot;:&quot;Paul Blythe&quot;}                                                │&quot;FOLLOWS&quot; │2            │
    ├───────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────┼─────────────┤
    │{&quot;name&quot;:&quot;Jessica Thompson&quot;}│{&quot;name&quot;:&quot;James Thompson&quot;}                                             │&quot;FOLLOWS&quot; │3            │
    ├───────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────┼─────────────┤
    │{&quot;name&quot;:&quot;Jessica Thompson&quot;}│{&quot;name&quot;:&quot;Angela Scope&quot;}                                               │&quot;FOLLOWS&quot; │3            │
    ├───────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────┼─────────────┤
    │{&quot;name&quot;:&quot;Jessica Thompson&quot;}│{&quot;tagline&quot;:&quot;Come as you are&quot;,&quot;title&quot;:&quot;The Birdcage&quot;,&quot;released&quot;:1996}  │&quot;REVIEWED&quot;│5            │
    ├───────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────┼─────────────┤
    │{&quot;name&quot;:&quot;Jessica Thompson&quot;}│{&quot;tagline&quot;:&quot;It&#39;s a hell of a thing, killing a man&quot;,&quot;title&quot;:&quot;Unforgiven│&quot;REVIEWED&quot;│5            │
    │                           │&quot;,&quot;released&quot;:1992}                                                    │          │             │
    ├───────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────┼─────────────┤
    │{&quot;name&quot;:&quot;Jessica Thompson&quot;}│{&quot;tagline&quot;:&quot;Break The Codes&quot;,&quot;title&quot;:&quot;The Da Vinci Code&quot;,&quot;released&quot;:20│&quot;REVIEWED&quot;│7            │
    │                           │06}                                                                   │          │             │
    ├───────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────┼─────────────┤
    │{&quot;name&quot;:&quot;Jessica Thompson&quot;}│{&quot;tagline&quot;:&quot;Pain heals, Chicks dig scars... Glory lasts forever&quot;,&quot;titl│&quot;REVIEWED&quot;│8            │
    │                           │e&quot;:&quot;The Replacements&quot;,&quot;released&quot;:2000}                                │          │             │
    └───────────────────────────┴──────────────────────────────────────────────────────────────────────┴──────────┴─────────────┘",0,69016183
2210,https://stackoverflow.com/a/69012803,Neo4j Cypher- With clause query,true,"Your first query has `m, count(m)`, which will result in a count of 1 for each Movie node `m`.

You can check this by returning from the query in the second line:

    MATCH (a:Person)-[:ACTED_IN]-&gt;(m:Movie)
    RETURN a, m, count(m) AS numMovies

The solution is to remove the separate `m` variable from the `WITH` clause as shown in your second query.",0,69012803
2211,https://stackoverflow.com/a/69004043,Query a whole graph from starting node,false,I think that what you are looking for is a spanning tree : https://neo4j.com/labs/apoc/4.1/overview/apoc.path/apoc.path.spanningTree/,0,69004043
2212,https://stackoverflow.com/a/69004798,How to get the output of the neo4j query in currency format (With $ symbol)?,true,"Since you found apoc already:

COALESCE ( ‘$’+ apoc.number.format(data.amount, &#39;#,##0.00;(#,##0.00)&#39;, &#39;it&#39;), ‘no amount’)",0,69004798
2213,https://stackoverflow.com/a/69009773,Get nodes having more than X relationships and it&#39;s children in specific format,true,"Turns out there is a library called APOC (Awesome Procedures on Cypher) and it has tons of really cool function. One of them is `degree` function.

Check this out if you&#39;re running into similar issues. It simplified my queries a lot!",0,69009773
2214,https://stackoverflow.com/a/69043803,Can&#39;t open Neo4j browser after loading the newest db dump,true,Solution is to update the browser,0,69043803
2215,https://stackoverflow.com/a/69017746,Neo4j vector operations on arrays,true,"I was able to do this with the following query:

Note: `embedding` is an array of floats

```
match (s:Sentence)-[r:RELATED]-(t:Sentence)
with s as sentence, collect(t.embedding) as neighbours_embeddings
set sentence.neighbour_avg = [
  w in reduce(
    s=[], neighbour_embedding IN neighbours_embeddings | 
    case when size(s) = 0 then neighbour_embedding
    else [
      i in range(0, size(s)-1) |
      s[i] + neighbour_embedding[i]
    ] end) |
    w / tofloat(size(neighbours_embeddings))
]
```",0,69017746
2216,https://stackoverflow.com/a/68990605,Cypher: return a string if no match using fulltext search,false,"You can simply use coalesce:

    CALL db.index.fulltext.queryNodes(&#39;myIndex&#39;, &#39;coding&#39;)
    YIELD node
    RETURN coalesce(node, &quot;No match found&quot;) as result",0,68990605
2217,https://stackoverflow.com/a/68992835,Cypher: return a string if no match using fulltext search,true,"The problem was that after `YIELD` returns null, all the operations after that are not computed (similar to how MATCH vs OPTIONAL MATCH work).

I was able to overcome this by creating a collection, unwind with case, and coalesce as Tomaz suggested in his answer.

```
CALL db.index.fulltext.queryNodes(&#39;myIndex&#39;, &#39;coding&#39;)
YIELD node
WITH collect(node) as nodes
UNWIND (CASE nodes WHEN [] then [null] else nodes end) as n
RETURN coalesce(n, &quot;No match found&quot;)
```",0,68992835
2218,https://stackoverflow.com/a/68983906,Using Djisktra Shortest Path on anonyous graph NEO4j,false,"It is possible to run Dijkstra algo in anonymous graph projection, as stated here
[Dijkstra Source-Target Anonymous syntax][1]


  [1]: https://neo4j.com/docs/graph-data-science/current/algorithms/dijkstra-source-target/#algorithms-dijkstra-single-source-syntax-anonymous

For the &#39;graph does not exist&#39; problem, have you tried to use CALL gds.graph.list() to verify it was created? Are you sure somewhere inside your query you are not dropping it?
",0,68983906
2219,https://stackoverflow.com/a/68985575,Using Djisktra Shortest Path on anonyous graph NEO4j,true,"When you restart your Neo4j instance, the named graph gets dropped from the memory. This is the only way you can drop your named graph without explicitly dropping it. If you want to do multiple dijkstra algorithms in sequence it if more performant if you create a named graph, but you can also run dijsktra on an anonymous graph:


    CALL gds.graph.create( &#39;graphname, &#39;node&#39;, &#39;rel&#39;, { relationshipProperties: &#39;prop&#39; } )
    
    MATCH (source:Location {name: &#39;A&#39;}), (target:Location {name: &#39;F&#39;})
    CALL gds.shortestPath.dijkstra.stream({
        nodeProjection: &#39;node&#39;,
        relationshipProjection:&#39;rel&#39;,
        relationshipProperties: [&#39;cost&#39;]
        sourceNode: source,
        targetNode: target,
        relationshipWeightProperty: &#39;cost&#39;
    })
    YIELD index, sourceNode, targetNode, totalCost, nodeIds, costs, path

",0,68985575
2220,https://stackoverflow.com/a/69163353,jQAssistant: Can&#39;t reset external Neo4J store - why?,true,See the comments which led to a Jenkins pipeline. Otherwise cleaning (in my case) can overlap with scanning.,1,69163353
2221,https://stackoverflow.com/a/68977874,Do you know of an example of Grails and neo4j configuration?,true,"The GORM Neo4J project has an example subproject which use Neo4j as primary data source, please check https://github.com/grails/gorm-neo4j/tree/master/examples/grails3-neo4j for more informaiton. 

Here is an example https://github.com/puneetbehl/neo4j-example",1,68977874
2222,https://stackoverflow.com/a/68966361,cypher filter relationship based on where not in,true,"```
MATCH 
    (e1:Entity1)&lt;-[:Entity2]-(e2),
    (e2)-[:Entity3]-&gt;()-[:Entity4]-&gt;(e4),
    (e4)&lt;-[:Entity5]-(e5)
WHERE 
    NOT e4.name in [&quot;ABC&quot;,&quot;XYZ&quot;] 
    AND e1.name in [&quot;BB&quot;, &quot;CC&quot;] 
WITH e2 as entity2
MATCH (entity2)&lt;-[:Entity6]-(entity6)
RETURN entity6                                                                                                                       

```

I think you missed filtering `e1.name` in your query,  posted originally in the question.",0,68966361
2223,https://stackoverflow.com/a/68963834,Neo4j - Find triplets with most similar attributes (nodes and relationships)?,false,"something along these lines should get you started

    MATCH (u:User)--&gt;(something)&lt;--(other:User)
    WHERE u &lt;&gt; other
    WITH u, COUNT(something) AS sharedSomethings
    ORDER BY sharedSomethings DESC",1,68963834
2224,https://stackoverflow.com/a/68965097,Neo4j - Find triplets with most similar attributes (nodes and relationships)?,true,"Maybe you could use [Node Similarity algorithm][1] that uses the Jaccard similarity under the hood. It is available in the [Neo4j Graph Data Science library][2]. This algorithm will allow you to compare node similarity based on their attribute nodes as you call them. If you also want to compare node properties, you would have to create your own comparing sets for each node and then use the basic implementation of Jaccard similarity score: https://neo4j.com/docs/graph-data-science/current/alpha-algorithms/jaccard/


  [1]: https://neo4j.com/docs/graph-data-science/current/algorithms/node-similarity/
  [2]: https://neo4j.com/docs/graph-data-science/current/",1,68965097
2225,https://stackoverflow.com/a/68969190,How to access the browser interface to install APOC in Neo4J?,false,"The APOC installation is not accessible via browser. It can be installed via Neo4j desktop app OR by copying the jar file in your installation directory.

After you download the APOC jar file, copy it in neo4j/plugins directory then restart your database. See the detailed steps here:

     https://stackoverflow.com/questions/42286508/apoc-is-only-partially-installing-its-extension-in-neo4j-one-procedure/42357481#42357481",0,68969190
2226,https://stackoverflow.com/a/68956250,neo4j order by optional property in descdending order with nulls being at the bottom,false,"You could add a field to your RETURN

    COALESCE ( node.createdAt, 999999999) AS sortField

that would give you a value to sort on.",0,68956250
2227,https://stackoverflow.com/a/68944680,Need to Add new property to all the labels expect the label name not starts like &#39;IA_&#39; in neo4j cypher,false,"You cannot add properties to labels. You can only add properties to nodes that have certain labels.

    MATCH (n)
    WHERE NONE( label IN labels(n) WHERE label STARTS WITH ‘IA_’ )
    SET n.myProperty = myValue

adds a property to nodes not having a label starting with IA_",1,68944680
2228,https://stackoverflow.com/a/68995071,SDN6 - Projection interfaces with Property Mapping,true,"The provided `@Property` annotation does only have an impact on the annotated property (`title`) itself.
There is no knowledge right now that goes from the `getTitle()` method in the projection to the annotated `title` field in the domain class.

To be safe when modifying this use the explicit property name:
```
interface DATspaceProjection {
    String getSUPtitle();
    String getSUPid();
}
```
I created an issue for improvement https://github.com/spring-projects/spring-data-neo4j/issues/2371",1,68995071
2229,https://stackoverflow.com/a/68926072,How to search comma separated greater than or less than values in neo4j,true,"Unfortunately, `toFloat` / `toInteger` do not accept locales, you won&#39;t be able to parse the comma properly with that function. 

As Tomaž suggested in the comment, migrate the values first (back up your data first!):
```
MATCH (n:Field)
SET n.value = toFloat(replace(n.value, &quot;,&quot;, &quot;&quot;)) # or toInteger
```

And then change your query to:
```
MATCH (n:Field)
WHERE n.name = &quot;square:&quot; AND n.value &gt; 12196
RETURN n
```",0,68926072
2230,https://stackoverflow.com/a/69163377,Why does jQAssistent scanning fail?,true,I now use a Jenkins pipeline to first clean the external JQAssistant database and then scan the software. This error hasn&#39;t occured since.,0,69163377
2231,https://stackoverflow.com/a/68922287,Cypher - conditional where clause,true,"This may help you, In Neo4j you can perform conditional operations using two options. 

If you have access to APOC, then you can use [`APOC.do.when`](https://neo4j.com/labs/apoc/4.1/overview/apoc.do/apoc.do.when/): 

```cypher
MATCH (s:Subject)-[:REGISTERED-BY]-&gt;(u:User{id: 1})

WHERE ...

CALL apoc.do.when(s.name=&quot;Math&quot;, &quot;SET s.name = \&quot;Maths\&quot;&quot;, &quot;&quot;, {}) YIELD value as _

RETURN s
```

The second is a more native [`FOREACH`](https://neo4j.com/docs/cypher-manual/current/clauses/foreach/): 

```cypher
MATCH (s:Subject)-[:REGISTERED-BY]-&gt;(u:User{id: 1})

WHERE ...

FOREACH(_ IN CASE s.name WHEN &quot;Math&quot; THEN [1] ELSE [] END | SET s.name = &quot;Maths&quot; )

RETURN s
```",0,68922287
2232,https://stackoverflow.com/a/68923546,Preventing duplicates with multiple collects in cypher query - which is the more canonical approach?,false,"Since both your constructs only return results if the full pattern

     (b)&lt;--(a)--&gt;(c) 

exists,the shortest way would be 

    MATCH (b)&lt;--(a)--&gt;(c)
    RETURN
        a,
        collect(DISTINCT b) as bs,
        collect(DISTINCT c) as cs

In case one or both of the two edges is/are optional, and you can use apoc, you can also do something like:



    MATCH (a)
    RETURN
        a,
        apoc.coll.toSet([(a)--&gt;(b) | b]) as bs,
        apoc.coll.toSet([(a)--&gt;(c) | b]) as cs
",1,68923546
2233,https://stackoverflow.com/a/68924819,Neo4j computed relations,false,"Let&#39;s say there is a node marriage with properties spouse1=p1 and spouse2=p2. If p1 and p2 are person ids (if p1,p2 are names, just change it to names and ensure it is unique), you can run below cypher to create the relationship :marriedTo from p1 to p2.

     MATCH (m: Marriage)
     WITH m.spouse1 as person1, m.spouse2 as person2
     MATCH (p1: Person {id: person1})
     WITH p1
     MATCH (p2: Person {id: person2})
     WITH p1, p2
     MERGE p=(p1) - [:marriedTo] - (p2)
     RETURN p",0,68924819
2234,https://stackoverflow.com/a/68942571,Neo4j computed relations,false,"In case the pattern does not have to persist, the best way would be to use virtual relationships. 

One way to do it is by using apoc : [https://neo4j.com/labs/apoc/4.1/virtual/][1]
If you need to have further interaction with the visualized relationships, you may use other tooling, e.g. our [Graphileon][2] platform (Disclosure :I work for the Graphileon team) 


  [1]: https://neo4j.com/labs/apoc/4.1/virtual/
  [2]: https://www.graphileon.com",0,68942571
2235,https://stackoverflow.com/a/68907332,Query doesn&#39;t work if I move hardcoded quotation marks,true,"Neo4j cypher syntax is below. 

    WHERE A.name=$nameParam

It should NOT have double quotes on the parameter name. Thus, the 2nd example is syntax error during runtime.
   ",1,68907332
2236,https://stackoverflow.com/a/68912936,Datetime comparison query doesn&#39;t return any results,false,"Double check the data type of start_datetime. It can be either in epoch seconds or epoch milliseconds.  You need to convert the epoch format to datetime, so that both are on the same data type.  The reason that your 2nd query works (.year) is because .year returns an integer value.

Run below to get samples:

     MATCH (n:Event) 
     RETURN distinct n.start_datetime LIMIT 5

Then if you see that it is 10 digits then it is in epochSeconds. If yes, then run below query:

     MATCH (n:Event) 
     WHERE n.start_datetime is not null 
     AND datetime({epochSeconds: n.start_datetime}) &gt; datetime(&quot;2019-06-01T18:40:32.142+0100&quot;) 
     RETURN n.start_datetime 
     LIMIT 25
    ",1,68912936
2237,https://stackoverflow.com/a/68919255,Datetime comparison query doesn&#39;t return any results,true,"It turns out the error was due to the timezone. Neo4j had saved the properties as `LocalDateTime`, which apparently can&#39;t be compared to `ZonedDateTime`.

I used `py2neo` for most of the nodes management, and the solution was to give a specific timezone to the python property. This was done (in my case) using:

```
datetime.datetime.fromtimestamp(kwargs[&quot;end&quot;], pytz.UTC)
```
After that, I was able to do the comparisons.

Hopes this saves a couple of hours to future developers.",0,68919255
2238,https://stackoverflow.com/a/68901949,Getting the top 10 values of a property in Neo4j cypher,false,"After the WHERE, you could do this :

    WITH
    m.P1 AS P1_test, n.P2 AS P2_test, count(*) AS testCount
    ORDER BY testCount DESC
    WITH P1_test, collect(P2_test) AS P2s
    RETURN P1_test, P2s[..10] AS top10",0,68901949
2239,https://stackoverflow.com/a/68908691,Getting the top 10 values of a property in Neo4j cypher,false," - You can do one match query to check if P1 and P2 are not null.
 - Then sort the result by P1 and count of P2 in descending order.
 - Collect P2 and its count then get the top 10 rows
- Unwind is like a for loop
- Lastly, return P1 and P2

In the future, please also give us sample data to work on. Thanks.

    match (n:N1) where n.P1 is not null and n.P2 is not null
    with n.P1 as P1_test, n.P2 as P2_test, count(n.P2) as cnt order by P1_test, cnt desc
    with P1_test,  collect({p2: P2_test, cnt:cnt})[..10] as p2_list
    unwind p2_list as c
    with P1_test, c.p2 as P2_test
    return P1_test, P2_test",0,68908691
2240,https://stackoverflow.com/a/68898886,spring-data-neo4j v6: No converter found capable of converting from type [MyDTO] to type [org.neo4j.driver.Value],true,"RTFM [Custom conversions][1] ...

Found the solution myself. Hopefully someone else may benefit from this as well.

Solution
========

**Create a custom converter**

    import mypackage.model.*
    import com.fasterxml.jackson.core.type.TypeReference
    import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
    import org.neo4j.driver.Value
    import org.neo4j.driver.Values
    import org.springframework.core.convert.TypeDescriptor
    import org.springframework.core.convert.converter.GenericConverter
    import org.springframework.core.convert.converter.GenericConverter.ConvertiblePair
    import java.util.HashSet
    
    class DtoToNeo4jValueConverter : GenericConverter {
        override fun getConvertibleTypes(): Set&lt;ConvertiblePair&gt;? {
            val convertiblePairs: MutableSet&lt;ConvertiblePair&gt; = HashSet()
            convertiblePairs.add(ConvertiblePair(MyDTO::class.java, Value::class.java))
            return convertiblePairs
        }
    
        override fun convert(source: Any?, sourceType: TypeDescriptor, targetType: TypeDescriptor?): Any? {
            return if (MyDTO::class.java.isAssignableFrom(sourceType.type)) {
                // generic way of converting an object into a map
                val dataclassAsMap = jacksonObjectMapper().convertValue(source as MyDTO, object :
                        TypeReference&lt;Map&lt;String, Any&gt;&gt;() {})
                Values.value(dataclassAsMap)
            } else null
        }
    }

**Register custom converter in config** 


    import org.springframework.context.annotation.Bean
    import org.springframework.context.annotation.Configuration
    import org.springframework.data.neo4j.core.convert.Neo4jConversions
    import org.springframework.core.convert.converter.GenericConverter
    import java.util.*
    
    
    @Configuration
    class MyNeo4jConfig {
        @Bean
        override fun neo4jConversions(): Neo4jConversions? {
            val additionalConverters: Set&lt;GenericConverter?&gt; = Collections.singleton(DtoToNeo4jValueConverter())
            return Neo4jConversions(additionalConverters)
        }
    }

  [1]: https://docs.spring.io/spring-data/neo4j/docs/current/reference/html/#custom.conversions.attribute.types
",0,68898886
2241,https://stackoverflow.com/a/68908284,Cypher: Avoid cycle in multiple relationship paths,false,"You could try out [`apoc.path.expandConfig`](https://neo4j.com/labs/apoc/4.1/graph-querying/expand-paths-config/) procedure. It has a `uniqueness` property, which you can be configured that a node cannot be traversed more than once.

```sql
MATCH (n:Event)
CALL apoc.path.expandConfig(n, {
    relationshipFilter: &quot;hasEvent&gt;&quot;,
    labelFilter: &quot;/Searched&quot;,
    uniqueness: &quot;NODE_GLOBAL&quot;
}) YIELD path
RETURN [n IN nodes(path) WHERE NOT n:Searched] AS upper
```

However, this query will still return A and B, because with `MATCH (n:Event)` you start looking from every node (regardless of the relationship between O and A). But if I understood you correctly, you don&#39;t wan&#39;t to start from all nodes, but from a specific one (&quot;pages dedicated to some events&quot;). So you might want to start with, e.g., `MATCH (n:Event {name: &quot;O&quot;})` that will return only O and C.",0,68908284
2242,https://stackoverflow.com/a/68887917,Return nodes that were deleted successfully,false,"This should do it

    MATCH (p:Post), (u:User)
    WHERE
     p.name IN [&quot;Latest Post&quot;]
     AND u.id = 1
     AND (p)-[:POST_OWNED_BY]-&gt;(u)

    // make sure you store the p.name
    WITH p, p.name AS deletedName

     DETACH DELETE p

    // return the name
    RETURN deletedName",0,68887917
2243,https://stackoverflow.com/a/68883342,Neo4j Cypher complex query optimization,false,"Some thoughts:

 - I don’t think this global graph search can be solved with a single query. You will need some kind of process to optimise exploration and use the result up to a certain point in subsequent steps.
 - when you could assign node labels instead of properties to reflect
   the state of a node, you could use apoc.path.expandConfig to just
   explore paths until you hit a node with state B.
 - you don’t need to re-investigate state A nodes that you traverse before you hit a node with state B, because they will not meet the requirements. 

Another approach could be this, given the fact that all nodes that are on the up or downstream paths from a B node, will not fulfil the requirements. Still assuming that you use labels to distinguish A and B nodes.

    MATCH (b:B)
    CALL apoc.path.spanningTree(b,
                               {relationshipFilter: &quot;&lt;&quot;,
                                labelFilter:&quot;/B&quot;
                               }
                               ) YIELD path
    UNWIND nodes(path) AS downStreamNode
    WITH b,COLLECT(DISTINCT downStreamNode) AS downStreamNodes
    CALL apoc.path.spanningTree(b,
                               {relationshipFilter: &quot;&gt;&quot;,
                                labelFilter:&quot;/B&quot;}
                               ) YIELD path
    UNWIND nodes(path) AS upStreamNode
    WITH b,downStreamNodes+COLLECT(DISTINCT upStreamNode) AS upAndDownStreamNodes
    RETURN apoc.coll.toSet(apoc.coll.flatten(COLLECT(upAndDownStreamNodes))) AS allNodesThatDoNotFulfillRequirements

",0,68883342
2244,https://stackoverflow.com/a/68894234,Performant neighbour navigation,false,"Have you looked at `https://neo4j.com/labs/apoc/4.1/background-operations/` or `https://neo4j.com/labs/apoc/4.1/database-introspection/`. You might have to write your own user defined functions in java, using the Neo4j java driver? That should speed things up considerably.  `https://neo4j.com/docs/api/java-driver/current/`",1,68894234
2245,https://stackoverflow.com/a/68910694,Performant neighbour navigation,false,"Depending on the size of your connected &quot;cluster&quot; of nodes making up automata, you might want to consider InfiniteGraph. 

The InfiniteGraph kernel in the client library caches the database data pages that are currently being used by the application. This can include millions of nodes and edges that get cached client-side. The cache uses a least-recently-used policy to flush database pages, writing pages that have been updated. Upon transaction commit, the remaining updated pages get written and the database reflects all changes.

Essentially, InfiniteGraph becomes an in-memory graph database tuned to each user&#39;s usage patterns with a massively scalable and fully distributed disk backing store.",1,68910694
2246,https://stackoverflow.com/a/68877649,Neo4j Python Driver Syntax Error on MERGE statement,true,"I recommend you to use f-string and then pass the parameter you need using python syntax.

```
query = f&quot;MERGE (n:Word{tag_a} {{ name: {name_a}}}) ON CREATE SET n.corpus = 1 ON MATCH SET n.corpus = n.corpus + 1 RETURN id(n) AS node_id&quot;
result_a = tx.run(query)
```

Just be cautious to always escape the query curly braces (duplicate them)",0,68877649
2247,https://stackoverflow.com/a/68909560,org.neo4j.ogm.context.GraphEntityMapper throwing IllegalArgumentException: Can not set Double field to java.math.BigDecimal,false,"I found out the exact place where the error was coming from was `neo4j.ogm.core` files, I tried various versions of the jar but nothing worked. 
Finally I resolved the problem by writing a custom converter as the implicit converter was not able to convert between Double and BigDecimal.
````
public class PercentageConverter implements AttributeConverter&lt;Double, BigDecimal&gt; {
  @Override
    public BigDecimal toGraphProperty(Double value) {
        if (value == null) {
            return null;
        }
        return new BigDecimal(value);
    }

    @Override
    public Double toEntityAttribute(BigDecimal value) {
        return value.doubleValue();
    }
} 
````
and annotate the entity attribute to use this converter
````
@Convert(PercentageConverter.class)
````
This resolved my error and now I can do all CRUD operations successfully ",0,68909560
2248,https://stackoverflow.com/a/68877378,communicating between docker instances of neo4j and express on local machine,false,"I was able to achieve the communication by using docker-compose. The problem is that both containers acted as separate networks and i could not find a way to allow the server to communicate with the database. Running docker-compose and building both containers within a single compose network allows communication using the service names.

take note this is tab sensitive!!

docker-compose.yml

```
version: &#39;3.7&#39;

networks:
    lan:

# The different services that make up our &quot;network&quot; of containers
services:
    # Express is our first service
    express:
        container_name: exp_server
        networks:
            - lan
        # The location of dockerfile to build this service
        build: &lt;location of dockerfile&gt;
        # Command to run once the Dockerfile completes building
        command: npm run startdev
        # Volumes, mounting our files to parts of the container
        volumes:
            - .:/src
        # Ports to map, mapping our port 3000, to the port 3000 on the container
        ports: 
            - 3000:3000
        # designating a file with environment variables
        env_file:
            - ./.env.express
    ## Defining the Neo4j Database Service        
    neo:
        container_name: neo4j_server
        networks:
            - lan
        # The image to use
        image: neo4j:latest
        # map the ports so we can check the db server is up
        ports: 
            - &quot;7687:7687&quot;
            - &quot;7474:7474&quot;
        # mounting a named volume to the container to track db data
        volumes:
            - $HOME/neo4j/conf:/conf
            - $HOME/neo4j/data:/data
            - $HOME/neo4j/logs:/logs
            - $HOME/neo4j/plugins:/plugins
        env_file:
            - .env.neo4j
```

with this you can use docker to run both the server and database and anything else while still using change detection rebuilding to develop and even build multiple environment images at the same time. NEAT",0,68877378
2249,https://stackoverflow.com/a/68866128,Get Nodes attached to all items in a path including the top element,true,"I would do this

    MATCH p=(pInit:part{_id:&#39;XXXXXXXXXX&#39;})-[cons:consumes*]-&gt;(item:part)
    UNWIND nodes(p) AS node
    WITH p,nodes(p)[0] AS pInit,node,[(node)-[relmop:isMaintainedWithOp]-&gt;(:maintenanceOps) | relmop][0] AS relmop
    RETURN p,pInit,relmop,endNode(relmop) AS mop,node
    ORDER BY node._sequence

",1,68866128
2250,https://stackoverflow.com/a/68889683,Get Nodes attached to all items in a path including the top element,false,"It seems weird but I fixed my problem doing this : 
```
MATCH p=(:part{_id:&#39;XXXXXXXXXX&#39;})-[cons:consumes*0..20]-&gt;(items:part) 
OPTIONAL MATCH (items)-[relmop:isMaintainedWithOp]-&gt;(mop:maintenanceOps)   
RETURN p,pInit,relmop,mop 
```
Allowing 0 connections, seems to use the first object in the path as &#39;items&#39; and search for other connections.",0,68889683
2251,https://stackoverflow.com/a/68860486,Adding a python list parameter in a neo4j query,true,"    MATCH (p1:Item),(p2:Item) where p1.value=$params RETURN  p1.value AS from, p2.value AS to, gds.alpha.similarity.euclideanDistance((p1.embeddingNode2vec), (p2.embeddingNode2vec)) AS similarity order by similarity desc limit 40

and then call the query execution like this:

    nodes = graphDB_Session.run(query, params= references[1])",0,68860486
2252,https://stackoverflow.com/a/68860558,Adding a python list parameter in a neo4j query,false,"Would be better to see more details of the code, but looks like the problem is the parenthesis.
Usually, when I do multi-line queries in python I&#39;ll use the multi-line f-string (using triple quotes -&gt; &quot;&quot;&quot;)

So the code would look like:

    query= f&quot;&quot;&quot;MATCH (p1:Item),(p2:Item) where p1.value={references[2]}
    RETURN  p1.value AS from, p2.value AS to,
    gds.alpha.similarity.euclideanDistance((p1.embeddingNode2vec),
    (p2.embeddingNode2vec)) AS similarity order by similarity desc limit
    40&quot;&quot;&quot;
obs: maybe you&#39;ll have to insert single-quotes for the parameter (&#39;{references[2]&#39;) so Neo4J recognize it as a string and not a variable). 

This way you don&#39;t need to pass parameters inside the session.run method.
Just be careful and remember to correctly escape any curly braces in the code (just duplicate it { -&gt; {{ )

If you want don&#39;t want to use a f-string, remove the parenthesis, keep the dollar-sign syntax ($name) instead of the curly-braced one and pass the parameter directly into the client.run().

Like this:

    run = client.run(query, name=references[2])",0,68860558
2253,https://stackoverflow.com/a/68850338,Mounting directory in Neo4j Docker container is resulting in empty directory on MacOS,true,"is the `/import` the right folder?

did you try using?
```yaml
services:
  neo4j:
    image: docker.io/neo4j:4.3.2
    container_name: neo4j
    ports:
      - 7474:7474
      - 7687:7687
    volumes:
      - $HOME/neo4j/logs:/logs
      - $HOME/neo4j/dummydata:/var/lib/neo4j/import #changed folder
  ```

source [here](https://neo4j.com/developer/docker-run-neo4j/)",2,68850338
2254,https://stackoverflow.com/a/68850327,Neo4j: bad result using the WITH statement,true,"I didn&#39;t understand the problem, but found a solution by replacing the MATCH / CREATE part of the relationship.

Valid request:

    CALL apoc.load.json(&quot;file:///files.json&quot;) yield value
    unwind value.nodes as node
    merge (file:File {id:node.path}) ON CREATE SET file.name = node.name
    WITH value
    unwind value.edges as edge
    MATCH (source:File {id: edge.sourceId}), (target:File {id: edge.targetId})
    MERGE (source)-[:`R`]-&gt;(target)",0,68850327
2255,https://stackoverflow.com/a/68844930,Construct queries with a condition,false,"I think what you are looking for is the `CASE` construct


    &#39;WHERE  ....&#39;
    +
    CASE 
        WHEN condition1 THEN  &#39;cypherFragement1&#39;
        WHEN condition2 THEN  &#39;cypherFragement2&#39;
        ELSE &#39;cypherFragementElse&#39;
    END
    +
    .....",0,68844930
2256,https://stackoverflow.com/a/68859069,Construct queries with a condition,false,"Maybe you can rewrite your entire cypher via apoc.do.when or apoc.do.case functions, which provide conditional judgment.",0,68859069
2257,https://stackoverflow.com/a/68844866,Neo4j yield statement within an APOC iterate call?,false,"What about:
```
CALL apoc.periodic.iterate(
   &quot;MATCH ()-[rel:RELATED]-&gt;() RETURN rel&quot;, 
   &quot;UNWIND $_batch AS item CALL apoc.refactor.invert(item.rel) YIELD input, output RETURN input, output&quot;,
   {batchMode: &quot;BATCH_SINGLE&quot;, batchSize: 100}
)
YIELD batches, operations
RETURN batches, operations AS total
```",0,68844866
2258,https://stackoverflow.com/a/68843437,Correct way to bulk insert / merge nodes and edges,true,"The `unwind_merge_nodes_query` function isn&#39;t generally intended to be used directly, although you can do so. Usually, you&#39;d want to use the functions from the `py2neo.bulk` module instead, which wrap these functions.

Either way though, that nuance is unlikely to help much with your specific problems. As a client-side library, py2neo can only carry out operations exposed by the Neo4j server and, unfortunately, there exists no good (low level) way to import non-trivial bulk data from the client. Py2neo can&#39;t fix that.

If performance is your goal, your best bet might be to instead use a LOAD CSV Cypher statement. Note though that to do this, your input data file will need to be on our visible to the server directly.",0,68843437
2259,https://stackoverflow.com/a/68847078,To get nodes and relationships between two specified nodes for review,false,"Might be better to use `shortestPath` operator to find the shortest path between two nodes.

    MATCH (start:temp {Name:&quot;Joel&quot;}), (end:temp {Name:&quot;Jack&quot;})
    MATCH p=shortestPath((start)-[*]-&gt;(end))
    RETURN nodes(p) as nodes, relationships(p) as rels",0,68847078
2260,https://stackoverflow.com/a/68848310,To get nodes and relationships between two specified nodes for review,false,"I assume you do not want to have duplicates in your result, so my approach would be this 

    MATCH (start:temp {Name:&quot;Joel&quot;}), (end:temp {Name:&quot;Jack&quot;})
    MATCH p=shortestPath((start)-[*]-&gt;(end))
    UNWIND nodes(p) AS node
    UNWIND relationships(p) AS rel
    RETURN COLLECT(DISTINCT node) as nodes, COLLECT(DISTINCT rel) as rels",0,68848310
2261,https://stackoverflow.com/a/68832092,How to increase performance when creating lots relations in neo4j,true,"You should replace:
```php
    $targetUrl = new Uri($link-&gt;getUri());

    if (!$this-&gt;nodeExist($targetUrl)) {
        $this-&gt;createNode($targetUrl);
    }

    if (!$this-&gt;nodeExist($foundOnUrl)) {
        $this-&gt;createNode($foundOnUrl);
    }

    $this-&gt;createRelation($foundOnUrl, $targetUrl);
```
with something like:
```php
$this-&gt;runStatement(&#39;
    USE &#39; . $this-&gt;getDB() . &#39;
    MERGE (a:URL {url_hash: $fromURL})
    MERGE (b:URL {url_hash: $toURL})
    CREATE (a)-[rel:Link]-&gt;(b)&#39;,
    [
        &#39;fromURL&#39; =&gt; CrawlUrl::getUrlHash($from),
        &#39;toURL&#39;   =&gt; CrawlUrl::getUrlHash($to),
    ]
);
```

Make sure you define an index (or a uniqueness constraint)  on `(:URL {url_hash})` **before** running the program.

If it is still too slow, then you&#39;ll indeed need to insert relationships by batch, with 1 query per batch (tweak the above query with `UNWIND`). You will need to experiment various batch sizes to determine what the best compromise is, in terms of import time and memory consumption (small batch =&gt; less memory =&gt; overall longer import time).

Side note: labels use `PascalCase` not `UPPER_CASE`, so `URL` should be written as `Url` (although the line is blurry when it comes to acronyms)",1,68832092
2262,https://stackoverflow.com/a/68820371,WHERE condition in neo4j | Filtering by relationship property,false,"There does not seem to be anything wrong with the cypher statement. 

Applying subsequent `MATCH` statements can be done with the `WITH` clause, it&#39;s well documented here : https://neo4j.com/docs/cypher-manual/current/clauses/with/",0,68820371
2263,https://stackoverflow.com/a/68820384,WHERE condition in neo4j | Filtering by relationship property,true,"Your query seems fine to me. However, there are 2 things I would like to point out here:

1. In this case, the `WHERE` clause can be removed and use match by property instead.
1. The `MATCH` clause can be combined.

So, the query would be:

```
MATCH (c:Client) -[r:CONTAINS {created: &quot;yesterday&quot;}]-&gt; (t:Transaction) -[:INCLUDES]-&gt; (i:Item)
RETURN c, t, i
```

Regarding your second question, when you want to run another query on the filtered dataset from the previous step, use [`WITH`][1] command. Instead of returning the result, `WITH` will pipe your result to the next query.

For example, with your query, we can do something like this to order the result by client name and return only the client:

```
MATCH (c:Client) -[r:CONTAINS {created: &quot;yesterday&quot;}]-&gt;  (t:Transaction) -[:INCLUDES]-&gt; (i:Item)
WITH c, t, i
ODERBY c.name DESC
RETURN c
```


  [1]: https://neo4j.com/docs/cypher-manual/current/clauses/with/",1,68820384
2264,https://stackoverflow.com/a/68819554,Neo4j: Exclude certain nodes in variable path relationship,false,"5 minutes after I posted this question, I thought of and tried a possible solution that seems to work. Not sure if this is against the rules, but here&#39;s a possible way out of my own problem (in case someone else is facing the same problem):

```
MATCH x=(p1:person)-[:PAYS]-(b1:business)
WITH *
MATCH y=(b1:business)-[:PAYS*..3]-(b2:business)-[:PAYS]-(p2:person)
RETURN x, y
```",0,68819554
2265,https://stackoverflow.com/a/68820469,Neo4j: Exclude certain nodes in variable path relationship,true,"The reason that 

    MATCH path=((person)-[:PAYS*0..3]-(person))
    WHERE NONE(n IN nodes(path) WHERE n:person)
    RETURN path

does not result in anything seems  to be  that the first and the last node are persons

if you want to find the paths from :person to :person with only :business in between, you could do this

    MATCH path=((p1:Person)-[:PAYS*1..3]-(p2:Person))
    WHERE ALL(n IN nodes(path)[1..-1] WHERE n:Business)
    RETURN path

You may all want to look at the `apoc.path.expand`  and `apoc.path.expandConfig` procedures (https://neo4j.com/labs/apoc/4.1/overview/apoc.path/). Powerful, but you introduce a dependency on the APOC library.

",1,68820469
2266,https://stackoverflow.com/a/68841538,Neo4j: Exclude certain nodes in variable path relationship,false,"You might want to look at how I handled this with X-linked inheritance. In that use case you aggregate the sex of the parent (M or F) and can then excluded MM from the aggregated string since a man never passes an X to his son. 

[http://stumpf.org/genealogy-blog/graph-databases-in-genealogy][1]


  [1]: http://stumpf.org/genealogy-blog/graph-databases-in-genealogy

The query exclude all MM concatenated strings, rather accepted anything except MM: 

    match p=(n:Person{RN:32})&lt;-[:father|mother*..99]-(m) with m, reduce(status =&#39;&#39;, q IN nodes(p)| status + q.sex) AS c, reduce(srt2 =&#39;|&#39;, q IN nodes(p)| srt2 + q.RN + &#39;|&#39;) AS PathOrder where c=replace(c,&#39;MM&#39;,&#39;&#39;) return distinct m.fullname as Fullname

In your case its P and B (person or business).  
",0,68841538
2267,https://stackoverflow.com/a/68799162,Neo4j，How to return nodes and relations where pathes between two nodes more than one,true,"I would try this:

    MATCH path=(p1:Person)-[:STAFF]-&gt;(c:Company)&lt;-[:STAFF]-(p2:Person)
    WHERE id(p1) &gt; id(p2)
    WITH p1,p2, COLLECT(path) AS paths
    WHERE SIZE(paths) &gt; 1
    RETURN paths

  ",3,68799162
2268,https://stackoverflow.com/a/69143655,"Correct order of operations in neo4j - LOAD, MERGE, MATCH, WITH, SET",false,"1. I don&#39;t think that&#39;s possible, LOAD CSV goes over one row at a time, so at row 1, it doesn&#39;t know how many more rows will follow.  
I guess you could create virtual nodes and relationships, aggregate those and then use those to create the real nodes, but that would be way more complicated. [Virtual Nodes/Rels](https://neo4j.com/labs/apoc/4.1/virtual/virtual-nodes-rels/)
2. That depends on the questions/queries you want to ask.  
A graph database is optimised for following relationships, so if you often do a query where the category is a criteria (e.g. `MATCH (c: Category {category_id: 12})-[r]-(:Compound)` ), it might be more performant to create a label for it.  
If you just want to get the category in the results (e.g. `RETURN compound.category`), then it&#39;s fine as a property.
",0,69143655
2269,https://stackoverflow.com/a/68789814,Neo4j: It possible to set nodes color programmatically?,false,"AFAIK you cannot do this inside of Neo4j. It is really a front-end task. There are multiple free front-end tools for personal use (including ours). that offer functionality to style nodes, also based on property values. ",1,68789814
2270,https://stackoverflow.com/a/68789709,how to replace a property in a neo4j relationship,true,"`MERGE` finds you the relationship (if it exists) , `SET` only sets a property on a relationship once you have found /created it.


For relationships, make are you first find the start and end nodes, once you have them

assuming you have found the  `(start)` and `(end)` nodes

you can do  

    // Find the rel, or create it if it does not yet exist
    MERGE (start)-[r:MyRELTYPE]-&gt;(end)
    // Set the property value
    SET r.myProperty =  myPropertyValue",1,68789709
2271,https://stackoverflow.com/a/68789560,"Filter a list with multiple conditions using WITH in Cypher,Neo4j",true,"Your `UNWIND` seems to return a list of maps, not a map. But the good thing is that with apoc, you can convert it easily.

this works:

    WITH [
            [
                {
                    thirdParty: &quot;Supermarkets&quot;
                },
                {
                    category: &quot;Groceries&quot;
                }
            ],
            [
                {
                    category: &quot;Rent&quot;
                }
            ],
            [
                {
                    thirdParty: &quot;Education&quot;
                },
                {
                    category: &quot;Education&quot;
                }
            ]
        ]
    AS tagsList
    
    WITH tagsList, [&#39;Groceries&#39;,&#39;Subscription TV&#39;,&#39;Telecommunications&#39;] as list
    UNWIND tagsList as tags
    WITH list,
         apoc.map.fromPairs(
            REDUCE(arr=[],tag IN tags | 
                   arr+[[keys(tag)[0],tag[keys(tag)[0]]]]
            )
         ) AS tagMap
    WHERE tagMap.category IN list AND tagMap.thirdParty IS NOT NULL
    RETURN tagMap

returns

    {
      &quot;thirdParty&quot;: &quot;Supermarkets&quot;,
      &quot;category&quot;: &quot;Groceries&quot;
    }",0,68789560
2272,https://stackoverflow.com/a/68786149,Neo4j 4.3 - Deprecation of size function and pattern comprehension,false,"I think `SIZE(COLLECT (other))`  also works

The new syntax offers a lot more possibilities, because you can combine it with `WHERE` clause and you can also avoid `OPTIONAL MATCH` in many cases.",0,68786149
2273,https://stackoverflow.com/a/68796159,Neo4j 4.3 - Deprecation of size function and pattern comprehension,false," 
Use this function below:
  

    length()

It is a replacement for size() exclusively for paths.  

 

     Quote: No longer works for paths. Only works for strings, lists and pattern expressions.

Reference: https://neo4j.com/docs/cypher-manual/current/deprecations-additions-removals-compatibility/#cypher-deprecations-additions-removals-4.0

 ",0,68796159
2274,https://stackoverflow.com/a/68782415,Can&#39;t run the node2vec algorithm with two weighted relationships,false,"The relationship weight property parameter can only take a single property name as the value. You could either use cypher projections to unify your relationship property name:

    CALL gds.graph.create.cypher(&#39;test&#39;,
    &#39;MATCH (n) RETURN id(n)&#39;,
    &#39;MATCH (s)-[r:locin|hasprop]-(t)
     RETURN id(s) as source, id(t) as target, coalesce(r.weight, r.weight2) as weight&#39;)

And then run the node2vec as follows:

    CALL gds.beta.node2vec.write(&#39;test23&#39;, 
    {embeddingDimension: 10, writeProperty: &quot;embeddingNode2vec&quot;,
     relationshipTypes:[&#39;locin&#39;,&#39;hasprop&#39;] 
    ,relationshipWeightProperty:&#39;weight&#39; } )

Or you could refactor your stored graph to have the weight property on both relationships:

    MATCH ()-[r:hasprop]-&gt;()
    SET r.weight = r.weight2

And then project the graph using the unified weight property:

    CALL gds.graph.create(&#39;test23&#39;,&#39;*&#39;,
     {hasprop:{type:&#39;HAS_PROPERTIES&#39;, orientation:&#39;UNDIRECTED&#39;, properties:&#39;weight&#39;},   
     locin:{type:&#39;LOCATES_IN&#39;, orientation:&#39;UNDIRECTED&#39;, properties:&#39;weight&#39;} })


Now you can run the node2vec with the same procedure as above.


",0,68782415
2275,https://stackoverflow.com/a/68781368,py2neo recursive matching,true,There is no way to do this with the matchers. You&#39;ll have to use Cypher.,1,68781368
2276,https://stackoverflow.com/a/68768894,how we can set Pipeline for postgres database to neo4j database?,false,"In my case, I used the JDBC driver to connect from Neo4j to PostgresQL.
You can find more information in the [documentation][1].
Basically, there is an APOC procedure that fetches data from Neo4j, which you can then store to Neo4j. Here is an example query:

    WITH &#39;jdbc:postgresql://&#39; + {sql_uri} + &#39;/&#39; + {sql_db} + &#39;?user=&#39; + {sql_username} +&#39;&amp;password=&#39;+{sql_password} as url,
    &#39;SELECT * FROM public.table WHERE foo = &#39;x&#39;)&#39; as eracun_query
    CALL apoc.load.jdbcParams(url, eracun_query,[]) yield row
    CREATE (n:Node)
    SET n += row

As you can see, you can define the SQL select statement to fetch any relevant data you might want from the postgreSQL database. You can then store its results with Cypher. If you are dealing with lots of data, I would suggest using `apoc.periodic.iterate` procedure for batching purposes.

  [1]: https://neo4j.com/labs/apoc/4.3/database-integration/load-jdbc/
",0,68768894
2277,https://stackoverflow.com/a/68762132,Neo4J crashes after installing APOC plugin,false,"This usually happens for two reasons:

First is version mismatch. You can check which version you should use based on the version matrix, which is available at: https://github.com/neo4j-contrib/neo4j-apoc-procedures#version-compatibility-matrix. Unfortunately, it is not always up to date, but the APOC versions are if I understand correctly:

APOC 4.1.x.x -&gt; Neo4j 4.1.x

APOC 4.2.x.x.-&gt; Neo4j 4.2.x 

APOC 4.3.x.x -&gt; Neo4j 4.3.x

If I had to guess, you are probably using Neo4j 4.3 or 4.1 and using an APOC that is designed to work with Neo4j 4.2.

The other issue is that sometimes you have multiple APOC plugin files in the plugin folders, so that will also crash Neo4j.",0,68762132
2278,https://stackoverflow.com/a/68764431,Cypher - Gantt chart from variable length relationships,true,"Did you try this?

    MATCH p= (start:File)-[:TRIGGER*0..3]-&gt;(end:File)
    WHERE NOT EXISTS (()-[:DependantOn]-&gt;(start))
    RETURN end, MAX(length(p))+1 AS level

It would return 29 at L3, where it should be I guess, because it only depends on items at L2",0,68764431
2279,https://stackoverflow.com/a/68749220,Return all paths and cost between two nodes in neo4j,false,"To start off, you can just prepend a zero to the cost array. Next, I create a list of array that are used to calculate the cumulative sum of cost along the way using the `apoc.coll.sum` function. Probably there are more options how to calculate the cumulative sum of elements in a list, but this is simplest I could think of:

    MATCH p=(o)-[r*0..]-&gt;(x)
    WHERE ID(o) =13 AND ID(x) = 14
    // Prepend a zero
    WITH [x in nodes(p) | id(x)] as list_path, [0] + [y in r | y.cost] as cost_path
    // Create list of lists 
    RETURN list_path, [i in range(1, size(cost_path)) | apoc.coll.sum(cost_path[..i])] as cost, apoc.coll.sum(cost_path) as total_cost
    ORDER BY total_cost DESC


Output:

    ╒═══════════╤═══════════════════════════╕
    │&quot;list_path&quot;│&quot;cost&quot;                     │
    ╞═══════════╪═══════════════════════════╡
    │[0,1]      │[0.0,50.0]                 │
    ├───────────┼───────────────────────────┤
    │[0,2,4,3,1]│[0.0,50.0,90.0,120.0,170.0]│
    └───────────┴───────────────────────────┘

You can convert the elements in the cost array to integer if that is what you prefer.",1,68749220
2280,https://stackoverflow.com/a/68743365,How to create dynamic node relation in neo4j for dynamic data?,true,"Hi I see that Organisation is part of the Author data, so you have to model it like wise. So for instance (Author)-[:AFFILIATED_WITH]-&gt;(Organisation)

When you use apoc.load.json which supports a stream of author objects you can load the data. 

I did some checks on your JSON structure with this cypher query:
```
call apoc.load.json(&quot;file:///Users/keesv/work/check.json&quot;) yield value
unwind value as record
WITH record.Author as author
WITH author.identifier[0].`idtype:auid` as authorId,author,  author.organization[0] as organizations
return authorId, author, organizations
```

To get this working you will need to create include apoc in the plugins directory, and add the following two lines in the apoc.conf file (create one if it is not there) in the &#39;conf&#39; directory.

```
apoc.import.file.enabled=true
apoc.import.file.use_neo4j_config=false
```

I also see a nested array for the organisations in the output why is that and what is the meaning of that? 

And finally I see also in the JSON that an organisation can have a reference to other organisations. 

explanation 
In my query I use UNWIND to unwind the base Author array. This means you get for every author a &#39;record&#39; to work with. 

With a MERGE or CREATE statement you can now create an Author Node with the correct properties. With the FOREACH construct you can walk over all the Organization entry and create/merge an Organization node and create the relation between the Author and the Organization. 

here an &#39;psuedo&#39; example 
```
call apoc.load.json(&quot;file:///Users/keesv/work/check.json&quot;) yield value
unwind value as record
WITH record.Author as author
WITH author.identifier[0].`idtype:auid` as authorId,author,  author.organization[0] as organizations
// creating the Author node
MERGE (a:Author { id: authorId })
SET a.familyName = author.familyName
...
// walk over the organizations
// determine 
FOREACH (org in organizations | 
  MERGE (o:Organization { id: ... })
  SET o.name = org.text
  ...
  MERGE (a)-[:AFFILIATED_WITH]-&gt;(o)
  // if needed you can also do a nested FOREACH here to process the Org Org relationship
)
```

Here is the JSON file I used I had to change something at the start and the end
```
[
   {
      &quot;Author&quot;:{
         &quot;seq&quot;:&quot;3&quot;,
         &quot;type&quot;:&quot;abc&quot;,
         &quot;identifier&quot;:[
            {
               &quot;idtype:auid&quot;:&quot;10000000&quot;
            }
         ],
         &quot;familyName&quot;:&quot;xyz&quot;,
         &quot;indexedName&quot;:&quot;MI&quot;,
         &quot;givenName&quot;:&quot;T&quot;,
         &quot;preferredName&quot;:{
            &quot;familyName&quot;:&quot;xyz1&quot;,
            &quot;givenName&quot;:&quot;a&quot;,
            &quot;initials&quot;:&quot;T.&quot;,
            &quot;indexedName&quot;:&quot;bT.&quot;
         },
         &quot;emailAddressList&quot;:[
            
         ],
         &quot;degrees&quot;:[
            
         ],
         &quot;@id&quot;:&quot;https:abc/2009127993/author/person/3&quot;,
         &quot;hasAffiliation&quot;:[
            &quot;https:abc/author/organization/1&quot;
         ],
         &quot;organization&quot;:[
            [
               {
                  &quot;identifier&quot;:[
                     {
                        &quot;@type&quot;:&quot;idtype:uuid&quot;,
                        &quot;@subtype&quot;:&quot;idsubtype:affiliationInstanceId&quot;,
                        &quot;@value&quot;:&quot;aff2&quot;
                     },
                     {
                        &quot;@type&quot;:&quot;idtype:OrgDB&quot;,
                        &quot;@subtype&quot;:&quot;idsubtype:afid&quot;,
                        &quot;@value&quot;:&quot;12345&quot;
                     },
                     {
                        &quot;@type&quot;:&quot;idtype:OrgDB&quot;,
                        &quot;@subtype&quot;:&quot;idsubtype:dptid&quot;
                     }
                  ],
                  &quot;organizations&quot;:[
                     
                  ],
                  &quot;addressParts&quot;:[
                     
                  ],
                  &quot;sourceText&quot;:&quot;&quot;,
                  &quot;text&quot;:&quot; Medical University School of Medicine&quot;,
                  &quot;@id&quot;:&quot;https:abc/author/organization/1&quot;
               }
            ],
            [
               {
                  &quot;identifier&quot;:[
                     {
                        &quot;@type&quot;:&quot;idtype:uuid&quot;,
                        &quot;@subtype&quot;:&quot;idsubtype:affiliationInstanceId&quot;,
                        &quot;@value&quot;:&quot;aff1&quot;
                     },
                     {
                        &quot;@type&quot;:&quot;idtype:OrgDB&quot;,
                        &quot;@subtype&quot;:&quot;idsubtype:afid&quot;,
                        &quot;@value&quot;:&quot;7890&quot;
                     },
                     {
                        &quot;@type&quot;:&quot;idtype:OrgDB&quot;,
                        &quot;@subtype&quot;:&quot;idsubtype:dptid&quot;
                     }
                  ],
                  &quot;organizations&quot;:[
                     
                  ],
                  &quot;addressParts&quot;:[
                     
                  ],
                  &quot;sourceText&quot;:&quot;&quot;,
                  &quot;text&quot;:&quot;K  University&quot;,
                  &quot;@id&quot;:&quot;https:efg/author/organization/2&quot;
               }
            ]
         ]
      }
   }
]
```
IMPORTANT create unique constraints for Author.id and Organization.id!! 

In this way you can process any json file with an unknown number of author elements and an unknown number of affiliated organisations",1,68743365
2281,https://stackoverflow.com/a/68746419,Neo4J Cypher Query on 5M nodes,true,"I would do this:

    MATCH (b1:Business)
    WITH b1
    MATCH(b2:Business) WHERE b1.name[0]=b2.name[0] AND b1&lt;&gt;b2
    WITH b1,b2,apoc.create.uuid() as uuid
    MERGE (b1)-[d:MCC_NAME]-&gt;(b2)
    SET …

Make sure you have an index set on `name`.
When you do not want to have the edges to be bi-directional, you could do

    WHERE id(b1)&gt;id(b2)",0,68746419
2282,https://stackoverflow.com/a/68740484,How to get Only Unique node in Neo4j Query,true,"If you want to return a node and edge array, I would suggest the following cypher query:

    MATCH (n:Class)
    WITH collect(n) as nodeArray
    MATCH (c1:Class)-[rel]-&gt;(c2:Class)
    WITH nodeArray, collect([c1,rel,c2]) as edgeArray
    RETURN nodeArray, edgeArray

You could obviously construct the edgeArray differently, but I don&#39;t know what is your preferred structure.",1,68740484
2283,https://stackoverflow.com/a/68742779,How to switch between databases in neo4j using java,true,"When you create a session, you can pass a `SessionConfig` instance with the database name, built via `SessionConfig.Builder`: https://neo4j.com/docs/api/java-driver/current/org/neo4j/driver/SessionConfig.Builder.html#withDatabase-java.lang.String-.",1,68742779
2284,https://stackoverflow.com/a/68731950,Neo4j cypher return node when any one string in it&#39;s property array is matched,true,"Try using the ```IN``` clause to search within the array:

    MATCH (n:Example) WHERE &#39;a&#39; IN n.names RETURN n",1,68731950
2285,https://stackoverflow.com/a/68729855,Express Router doesn&#39;t route as expected,true,"Your first route needs to include the name parameter. Express routes aren&#39;t inclusive of any others defined elsewhere, so you need to spell it out a bit.
    
    router.get(&#39;/:name/1&#39;, (req, res, next) =&gt; {",3,68729855
2286,https://stackoverflow.com/a/68721600,Neo4j - Load CSV with headers containing dots?,true,"Importing form csv is usually something you do for initial creation of the graph. So I would not worry too much about what looks pretty as long as it gets the job done.

It is absolutely fine to have dots in the headers and you can use:

```
RETURN row.`column1.name` as name, row.`column.age` as age
```

If you want to avoid using back ticks use:

```
RETURN row[&#39;column1.name&#39;] as name, row[&#39;column.age&#39;] as age
```",2,68721600
2287,https://stackoverflow.com/a/68747956,Remove a property keys from all node in neo4j,false,"It seems you have the osmid on your relationship and not on your nodes actually. The query to remove properties from a relationship is:

    MATCH ()-[r]-&gt;()
    REMOVE r.osmid",1,68747956
2288,https://stackoverflow.com/a/68718144,Can&#39;t load CSV from Drive to Neo4j,true,"You need to use the download link instead of the sharing link. This works for me:

    LOAD CSV WITH HEADERS FROM &quot;https://drive.google.com/u/0/uc?id=12DiEwM8XatMZBXA6TdekxWl8qrsgVj3l&amp;export=download&quot; as row
    RETURN row LIMIT 5

I got the download link by clicking on the download icon, which redirects you. You have to be fast to copy the redirect link and it should work. Perhaps there is a method with which you could reconstruct the query manually, so you don&#39;t have to be extremely fast to copy the download link, but I am not aware of it.",1,68718144
2289,https://stackoverflow.com/a/68707518,Find all pair shortestpath from no label nodes and loading for ever,false,"The db schema is empty because your nodes don&#39;t have any labels.
You can add a label to your nodes and then the schema will also be available like so:

    MATCH (n)
    SET n:Node

The code for your all pairs shortest path is correct, it is just a very expensive algorithm. And once you have calculated all the paths, you only return the 10 shortest paths between a pair of nodes, so it might make more sense to store the results back to your graph. A big factor in algorithm speed is also the number of relationships you have.",0,68707518
2290,https://stackoverflow.com/a/68694929,Python &amp; Neo4j &amp; JSON - For each user create NODE,false,"This is a syntax error. You should format your input file per column and NOT Json like format. There is no shortcut.

Change the code as below (as an example of user, thrn add more column names for other columns)

     Old: for User in UsersFile [&#39;Users&#39;]:
     New: 
     For context in UsersFile [&#39;Users&#39;]:
         User = context.user
Because you want to pass the usercxt value and not the json string {Usercxt: &quot;sample usercxt&quot;}

Then change this too

      Old: tx.run(&quot;CREATE (n:User $Usercxt);&quot;, Usercxt=json.dumps(User))

     New: tx.run(&quot;CREATE (n:User {usercxt: $Usercxt});&quot;, Usercxt=User)

The reason is you cannot use a json like formatted string when creating a node. It is NOT doing a string replacement when you do this: $Usercxt -&gt; {usercxt: &quot;sample usercxt&quot;}.

The syntax stays the same as below

     Create (:Label {prop: value})

Hope this helps.",0,68694929
2291,https://stackoverflow.com/a/68687347,"compilation issues for neo4j-graph-api, neo4j-logging, neo4j-procedure-api with neo4j 4.3.2",false,"I found the issue. The main problem was &#39;class file has wrong version 55.0, should be 52.0&#39;. This is caused when the Jar that I have included in the project was compiled with Java 11. The person who compiled that Jar could have used Java 11 only features and hence had to generate the bytecode that is only compatible with JDK 11 or higher.

My IDE was using java 8. When I changed my IDE to use Java 11, it compiled the project.",0,68687347
2292,https://stackoverflow.com/a/68681434,Neo4j Community Server: Cannot select my database in the remote interface,true,"Please look for this configuration in &lt;neo4j_home_dir&gt;/conf/neo4j.conf file. Then change it to

     old: dbms.default_database=neo4j

     New: dbms.default_database=dicom

Then restart your neo4j instance.",0,68681434
2293,https://stackoverflow.com/a/68766024,Does neo4j MERGE ON MATCH ON CREATE have a property maximum limit?,false,"neo4j does not limit the number of properties to be set，
This should be a driver problem",0,68766024
2294,https://stackoverflow.com/a/68678792,Cypher: filter out nodes with certain paths,true,"I would approach it like this 

    // collect the unwanted endpoints
    MATCH (to: SpecialToLabel)
    WHERE (to.`to_prop` in $UnwantedValues)
    WITH COLLECT(to) AS unwantedEndpoints
    
    // only use the &#39;from&#39; nodes that do not have a relation to one of the unwantedEndpoints
    MATCH p=(from: SpecialFromLabel)-[r:SPECIAL_REL]-&gt;(to: SpecialToLabel)
    WHERE NONE( n IN [(from)-[:SPECIAL_REL]-&gt;(m) | m] WHERE n IN unwantedEndpoints)
    RETURN p

==== UPDATED , and applied to Movie dataset====

    // be careful not to re-use the bindings!
    MATCH (persons:Person)-[a:ACTED_IN]-&gt;(m:Movie) 
    WHERE ((m.title in [&quot;Speed Racer&quot;])) 
    
    with collect(m) as excluded  
    
    MATCH (p:Person)-[:ACTED_IN]-&gt;(:Movie)  
    WHERE  none(n in [(p)-[:ACTED_IN]-&gt;(m2:Movie)| m2] where n in excluded)  
    
    RETURN DISTINCT p.name,[(p)-[:ACTED_IN]-&gt;(m3:Movie)| m3.title]
    ORDER BY p.name",1,68678792
2295,https://stackoverflow.com/a/68662980,How can I Limit nodes on each level of children in tree with cypher query,false,"I guess you have to filter out the paths first. My approach would be to make sure that all children in the path are among the first 5 child nodes of the previous parent . I don&#39;t have a dataset ready to test it, but it could be along the lines of this

    MATCH path = (jon:Person )-[:PARENT_OF*]-&gt;(leaf:Person)
    // limit the number of paths, by only considering the ones that are not parent of someone else.
    WHERE NOT (leaf)-[:PARENT_OF]-&gt;(:Person)

    // and all nodes in the path (except the first one, the root) be in the first five children of the parent
    AND 

    ALL(child in nodes(path)[1..] WHERE child IN [(sibling)&lt;-[:PARENT_OF]-(parent)-[:PARENT_OF]-&gt;(child) | sibling][..5])

    WITH collect(path) as paths
    CALL apoc.convert.toTree(paths) yield value
    RETURN value


another approach, perhaps faster, would be to first collect all the first five children of descendants of jon

    // find all sets of &quot;firstFiveChildren&quot;
    MATCH (jon:Person { name:&#39;jon&#39;}),
         (p:Person)-[:PARENT_OF]-&gt;(child)
    WHERE EXISTS((jon)-[:PARENT_OF*]-&gt;(p))
    WITH jon,p,COLLECT(child)[..5] AS firstFiveChildren
    // create a unique list of the persons that could be part of the tree
    WITH jon,apoc.coll.toSet(
     apoc.coll.flatten(
       [jon]+COLLECT(firstFiveChildren)
     )
    ) AS personsInTree
    
    
    MATCH path = (jon)-[:PARENT_OF*]-&gt;(leaf:Person)
    WHERE NOT (leaf)-[:PARENT_OF]-&gt;(:Person)
    AND ALL(node in nodes(path) WHERE node IN personsInTree)
    WITH collect(path) as paths
    CALL apoc.convert.toTree(paths) yield value
    RETURN value;

UPDATE

The issue with the data is that the tree is not symmetric, e.g. not all the paths have the same depth. node d0 for instance has no children. So if you pick five children at the first level, you may not be getting any deeper.

I added a slightly different approach, that should work with symmetric trees, and which allows you to set the number max number of children per node.  Try it with 3, and you will see that you only get nodes from the first level., with 8 you get more.

    // find all sets of &quot;firstChildren&quot;
    WITH 8 AS numberChildren
    
    MATCH (jon:Person { name:&#39;00&#39;}),
           (p:Person)-[:PARENT_OF]-&gt;(child)
    WHERE EXISTS((jon)-[:PARENT_OF*0..]-&gt;(p))
    WITH jon,p,COLLECT(child)[..numberChildren] AS firstChildren
    
    // create a unique list of the persons that could be part of the tree
    WITH jon,apoc.coll.toSet(
     apoc.coll.flatten(
       [jon]+COLLECT(firstChildren)
     )
    ) AS personsInTree
    
    
    
    MATCH path = (jon)-[:PARENT_OF*]-&gt;(leaf:Person)
    WHERE NOT (leaf)-[:PARENT_OF]-&gt;(:Person)
    AND ALL(node in nodes(path) WHERE node IN personsInTree)
    
    WITH collect(path) as paths
    CALL apoc.convert.toTree(paths) yield value
    RETURN value

",0,68662980
2296,https://stackoverflow.com/a/68655582,Neo4J Cypher: Set property only if it is null but still return the node,false,"What about adding the property as a discriminator for the match?

```
  MATCH (u:User)
  WHERE u.uuid=$userId AND IS NULL u.unsubscribedAt
  SET u.unsubscribedAt = timestamp()
  RETURN u
```",3,68655582
2297,https://stackoverflow.com/a/68655822,Neo4J Cypher: Set property only if it is null but still return the node,true,"You can use [coalesce][1] to achieve this. It returns the first non-null value it&#39;s passed, so it will resolve the existing value if already present

      MATCH (u:User)
      WHERE u.uuid=$userId
      SET u.unsubscribedAt = coalesce(u.unsubscribedAt, timestamp())
      RETURN u


  [1]: https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-coalesce",4,68655822
2298,https://stackoverflow.com/a/68655850,Neo4J Cypher: Set property only if it is null but still return the node,false,"

if you do not mind the property being overwritten with its original value, you could also do this :

    MATCH (u:User {uuid:$userId})
    SET u.unsubscribedAt = COALESCE(u.unsubscribedAt,timestamp())
    RETURN u",1,68655850
2299,https://stackoverflow.com/a/68665996,Neo4j transaction with array of queries with js-neo4j-driver,false,"First, if you have an array, you might want to iterate over it. Second, `tx.run()` returns a Promise that you need to catch if it fails. In your code, it is called 4 times in a row, but only the last one waits for the result and catches the error. I looks like some lines of the code are missing.

neo4j-driver documentation gives a good example on explicit transactions: https://github.com/neo4j/neo4j-javascript-driver#explicit-transactions

The queries are executed sequentially. If one fails the whole transaction will be rolled back.

```javascript
async function neo4jTransaction(queryArray) {

  const session = driver.session();

  const txc = session.beginTransaction();

  try {

    for (const query of queryArray) {
      await txc.run(query || &#39;RETURN 0&#39;);
    }

    await txc.commit();

  } catch (e) {

    await txc.rollback();
    return Promise.reject(e);

  } finally {

    await session.close();

  }

}
```",0,68665996
2300,https://stackoverflow.com/a/68657143,Regex match items in property list,true,"If you want that `any` of the items in the list matches your expression and return the file only if one matches, you can do something like this : 

```
MATCH (f:File)
WHERE ANY(x IN f.env WHERE x =~ &#39;JVM.*&#39;)
RETURN f.id, f.env


╒══════╤══════════════════════════════╕
│&quot;f.id&quot;│&quot;f.env&quot;                       │
╞══════╪══════════════════════════════╡
│123   │[&quot;JVM_OPTS&quot;,&quot;JAVA_HOME&quot;,&quot;CWD&quot;]│
└──────┴──────────────────────────────┘
```

If you&#39;re interested to return the file in any case and return the items in the list that match your expression, you can do this instead : 

```
MATCH (f:File)
RETURN f.id AS id, [x IN f.env WHERE x =~ &#39;JVM.*&#39;] AS env

╒════╤════════════╕
│&quot;id&quot;│&quot;env&quot;       │
╞════╪════════════╡
│123 │[&quot;JVM_OPTS&quot;]│
└────┴────────────┘
```",1,68657143
2301,https://stackoverflow.com/a/68650630,Return paths to nodes with more than N relationships,true,"I would try something like this

    MATCH p=(u:User)-[*..2]-&gt;(r:Repository)
    WITH r,
         COLLECT(p) AS ps,
         COUNT(DISTINCT u) AS userCount
    WHERE userCount &gt; 100
    UNWIND ps AS p
    RETURN p",1,68650630
2302,https://stackoverflow.com/a/68645238,Display intermediary nodes and relationships when finding path between two nodes,true,"Try

    match path=(u:User{login: &quot;userA&quot;})-[*..2]-&gt;(r:Repository)-[HAS_STATUS]-&gt;(s:Status) 
    return path

About the “for some reason” : the Neo4j viz has an autocomplete that displays edges between neighbours. Even when these edges are not returned by the query.",1,68645238
2303,https://stackoverflow.com/a/68681547,How do I fetch all the data or just the size of it in Neo4j?,false,"[Here](https://neo4j.com/blog/data-profiling-holistic-view-neo4j/) is a good blog about data profiling of a neo4j database: https://neo4j.com/blog/data-profiling-holistic-view-neo4j/

You can get the total number of nodes and edges and sizes. Thanks.",1,68681547
2304,https://stackoverflow.com/a/68687156,How do I fetch all the data or just the size of it in Neo4j?,true,"There are multiple ways:
- the best one: `CALL apoc.meta.stats yield nodeCount, relCount`
- not so optimial: `match(p) return p;`

The second one should only be used if you were to get the _feel_ of the data, while the first one is what shows the count.",1,68687156
2305,https://stackoverflow.com/a/68638701,Retrieve custom properties with Neo4j/Spring boot,true,"It seems the closest solution you have in Spring Data Neo4j would be to rely on [composite properties][1].


  [1]: https://docs.spring.io/spring-data/neo4j/docs/current/reference/html/#custom.conversions.composite-properties",0,68638701
2306,https://stackoverflow.com/a/68648252,NEO4J 4.3.1 json log format not working for http.log,false,"How did you configure Neo4j ? Testing with a brand new 4.3.1 community shows it is working perfectly fine : 

```
$ cat conf/neo4j.conf | grep format
dbms.logs.default_format=json


$ ./bin/neo4j start
Directories in use:
home:         /Users/christophewillemsen/dev/_graphs/community-4.3.1
config:       /Users/christophewillemsen/dev/_graphs/community-4.3.1/conf
logs:         /Users/christophewillemsen/dev/_graphs/community-4.3.1/logs
plugins:      /Users/christophewillemsen/dev/_graphs/community-4.3.1/plugins
import:       /Users/christophewillemsen/dev/_graphs/community-4.3.1/import
data:         /Users/christophewillemsen/dev/_graphs/community-4.3.1/data
certificates: /Users/christophewillemsen/dev/_graphs/community-4.3.1/certificates
licenses:     /Users/christophewillemsen/dev/_graphs/community-4.3.1/licenses
run:          /Users/christophewillemsen/dev/_graphs/community-4.3.1/run
Starting Neo4j.
Started neo4j (pid:93326). It is available at http://localhost:7474
There may be a short delay until the server is ready.


$ tail -f logs/neo4j.log
{&quot;time&quot;:&quot;2021-08-04 08:50:10.777+0000&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;message&quot;:&quot;Remote interface available at http://localhost:7474/&quot;}
{&quot;time&quot;:&quot;2021-08-04 08:50:10.779+0000&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;message&quot;:&quot;Started.&quot;}
{&quot;time&quot;:&quot;2021-08-04 08:50:18.061+0000&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;message&quot;:&quot;Neo4j Server shutdown initiated by request&quot;}
{&quot;time&quot;:&quot;2021-08-04 08:50:18.061+0000&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;message&quot;:&quot;Stopping...&quot;}
{&quot;time&quot;:&quot;2021-08-04 08:50:25.835+0000&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;message&quot;:&quot;Stopped.&quot;}
{&quot;time&quot;:&quot;2021-08-04 08:51:28.216+0000&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;message&quot;:&quot;Starting...&quot;}
{&quot;time&quot;:&quot;2021-08-04 08:51:30.014+0000&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;message&quot;:&quot;======== Neo4j 4.3.1 ========&quot;}
{&quot;time&quot;:&quot;2021-08-04 08:51:31.369+0000&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;message&quot;:&quot;org.neo4j.internal.kernel.api.security.AbstractSecurityLog$SecurityLogLine@2b15ba1a&quot;}
{&quot;time&quot;:&quot;2021-08-04 08:51:31.369+0000&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;message&quot;:&quot;org.neo4j.internal.kernel.api.security.AbstractSecurityLog$SecurityLogLine@796fe2b5&quot;}
{&quot;time&quot;:&quot;2021-08-04 08:51:32.024+0000&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;message&quot;:&quot;Bolt enabled on localhost:7687.&quot;}
{&quot;time&quot;:&quot;2021-08-04 08:51:32.605+0000&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;message&quot;:&quot;Remote interface available at http://localhost:7474/&quot;}
{&quot;time&quot;:&quot;2021-08-04 08:51:32.606+0000&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;message&quot;:&quot;Started.&quot;}
```",0,68648252
2307,https://stackoverflow.com/a/68630257,Query Neptune nodes with Cypher not working in Node.js,true,"According to the error message, it looks like the node being returned contains a datetime property and in the 1.0.5.0R0 release of openCypher for Neptune returning of datetime properties is not yet supported via the Bolt connected.  Returning datetime values is currently supported using the HTTPS endpoint as described here: https://docs.aws.amazon.com/neptune/latest/userguide/access-graph-opencypher-queries.html  ",2,68630257
2308,https://stackoverflow.com/a/68633998,Liquigraph schema files missing?,true,"This should be fixed now. 
I just deployed a new version of the website and misconfigured a couple of things (wrong `CNAME` file location, wrong schema files location).

https://www.liquigraph.org/schema/1.0/liquigraph.xsd and http://www.liquigraph.org/schema/1.0/liquigraph.xsd should work fine now.

More recent releases of Liquigraph also support schema location redirects such as the latest 3.x and 4.x. Make sure to upgrade!",1,68633998
2309,https://stackoverflow.com/a/68623193,Neo4j list NOT IN another list query,false,"This should do it:

    MATCH (c:City)&lt;-[LIVES_IN]-(p:Person)
    WITH p, COLLECT(DISTINCT c) AS personCities
    MATCH (p)-[:LIKED]-&gt;(r:Restaurant)-[:LOCATED_IN]-&gt;(rc:City)
    WHERE NOT rc IN personCities
    RETURN p.person_name, collect(r.restaurant_name)",0,68623193
2310,https://stackoverflow.com/a/68619528,Neo4J : How to Order results by attributes value,false,"you can sort by property value . imagine `(p:Person)` and `(c:City)` nodes

    RETURN p.name AS Person, c.name AS City
    ORDER BY City

another example

    WITH p,c
    ORDER BY p.birthdate
    RETURN p.name AS Person, c.name AS City

in case you want to order by age. 

if your cities have to be in an order based on a specific property, add e.g.  `index` to the city node , and do something like:

    WITH p,c
    ORDER BY c.index
    RETURN p.name AS Person, c.name AS City
",0,68619528
2311,https://stackoverflow.com/a/68616477,NOT operator fails to filter as expected in cypher query,false,"Ok, silly me.

The problem is not in the logical equivalence between the two statements (`x.action_code=&#39;PULL&#39;` and `NOT x.action_code IN [&#39;MV&#39;, &#39;SPT&#39;]`).

It&#39;s due to the conflict between `WHERE b.action_code=&#39;INS&#39;` and `NOT x.action_code IN [&#39;MV&#39;, &#39;SPT&#39;]`. Since the path I&#39;m interested in consists of WorkOrderNodes that have `INS` work actions, by not including them in the action list would remove all paths found in the previous conditions.

This is the solution:

```
MATCH p=(a)&lt;-[*]-(b:WorkOrderNode)
WHERE ID(a)=107
AND b.action_code=&#39;INS&#39;
AND NONE(x in nodes(p) WHERE exists(x.action_code) AND NOT x.action_code in [&#39;MV&#39;, &#39;SPT&#39;, &#39;INS&#39;])
RETURN b
```",1,68616477
2312,https://stackoverflow.com/a/68616632,NOT operator fails to filter as expected in cypher query,true,"if you want to make sure that the final node of the path (b) always has b.action_code=&#39;INS&#39; and none of the other nodes has &#39;INS&#39;, perhaps a better way would be to use

    NONE(x in nodes(p)[..-1]    .....  NOT x.action_code in [&#39;MV&#39;, &#39;SPT&#39;])

instead of  


    NONE(x in nodes(p) ... 

",2,68616632
2313,https://stackoverflow.com/a/68613287,Neo4j index query runs slowly,true,"I would suggest you upgrade to the latest Neo4j version as there have been some upgrade to the order by operations from the 4.0.6 version.
Also, there is a tiny bit of query optimization that you could make, it probably won&#39;t make a big difference, but it is still nice to implement it:

    match (u:User)
    WITH u
    ORDER BY u.tsScan
    LIMIT 100
    RETURN u.id as id

This way you don&#39;t have to access the id property for all the users in your database, but you only access the id property for the resulted 100 users. Also, make sure to create an index on *tsScan* property.",0,68613287
2314,https://stackoverflow.com/a/68609760,Set relationship property in a range in Neo4j,false,"my best guess

    relationshipProperty: {
                            name:&#39;myProperty&#39;,
                            type: &#39;RANDOM&#39;,
                            min : 40.0,
                            max : 80.0
                          }

",0,68609760
2315,https://stackoverflow.com/a/68607472,convert gremlin queries to cypher query,false,"I noticed that you have already been discussing this already with Michael Hunger, who happens to be one of the most knowledgeable people when it comes to this kind of things.  I don&#39;t think that there is anything better than the bolt driver at this moment.

The number of 10000 query statements makes me wonder whether there isn&#39;t a pattern in the structure of these statements? In our own platform, we have a mechanism to write part of the queries (Cypher, Gremlin, Sparql) dynamically. It might be an approach that could work for your case as well.",0,68607472
2316,https://stackoverflow.com/a/68600892,What is the correct way to represent dates in a graph database (Neo4j)?,false,"best way is to use the neo4j date / time format : https://neo4j.com/docs/cypher-manual/current/syntax/temporal/

But this should do it, given the date format that you use:

    MATCH (p:People {name:&quot;Sally&quot;})
    WITH p.date_of_birth AS date_of_birth ,date() AS now
    // convert the stringDate into a date in the datetime format
    WITH   now,
           date(
                {year:toInteger(right(date_of_birth,4)), 
                 month:toInteger(substring(date_of_birth,3,2)), 
                 day: toInteger(left(date_of_birth,2))
                }) AS date_of_birth 
    RETURN duration.between(dateOfBirth,now).years AS age",2,68600892
2317,https://stackoverflow.com/a/68597343,How to get data with relationship in neo4j?,true,"I believe the best approach would be to use the ˙collect` clause twice:

    MATCH (c:Category)--&gt;(p:Product)
    WITH {name:c.name, products: collect(p.name)} as single_product
    RETURN collect(single_product) as result

",1,68597343
2318,https://stackoverflow.com/a/68590415,Cypher: Getting n neighboring Nodes for each Node of certain type,true,"To get the 5 rels with the highest scores, this should do it. 

    MATCH (n:Artist)-[r:similar_to]-&gt;(:Artist)
    WITH n,r 
    ORDER BY r.score DESC
    RETURN n, COLLECT(r)[..5] AS relsWithHighestScores",0,68590415
2319,https://stackoverflow.com/a/68593426,Count the number of different types of edges of a node,false,"You have to carry along the original account in the WITH statement, so you can COUNT and COLLECT for each account.

Also, use OPTIONAL MATCH, otherwise you will get nothing in case the account does not have a phone , for example.",0,68593426
2320,https://stackoverflow.com/a/68587384,Cypher variable path condition filtering,true,"Did you try something like this?

    MATCH path=(account {id..})-[:transfer*1..2]-&gt;(otherAccount:Account))
    WHERE ALL (edge IN rels(path) WHERE transferDate &gt;  ...  AND .... )
    RETURN COLLECT(DISTINCT otherAccount) AS otherAccounts",0,68587384
2321,https://stackoverflow.com/a/68588736,Cypher variable path condition filtering,false,"Correct Answer:

MATCH path=(account:Account{id:15393163051738})-[:transfer*1..3]-&gt;(otherAccount:Account)
WHERE ALL (edge IN relationships(path) WHERE edge.transferDate &gt; 1276657248987  AND edge.transferDate &lt; 1330135293550 )
WITH COLLECT(DISTINCT otherAccount) AS disOtherAccount",0,68588736
2322,https://stackoverflow.com/a/68586519,How can I define a Neo4j node property from 2 possible paths with a cypher query?,true,"This could be an approach:

    MATCH (k:KeyNode)&lt;-[:BASED_ON]-(n)-[:CONTROLS|:MODIFIES]-&gt;()
        WHERE id(k)=123456
    OPTIONAL MATCH (n)&lt;-[:LABEL_A_REL]-(c:Controller)-[:CONTROLS]-&gt;(r1:Resource)-[:TYPE_OF]-&gt;(rt1:ResourceType)
    OPTIONAL MATCH (n)-[:LABEL_NOT_A_REL]-&gt;(r2:Resource)-[:TYPE_OF]-&gt;(rt2:ResourceType)
    
    // COALESCE to deal with precedence
    WITH COALESCE(r1,r2) AS r,
         COALESCE(rt1,rt2) AS rt
    
    OPTIONAL MATCH (r)-[:PARENT*]-&gt;(ro:Room)
    RETURN ID(r) as resourceId, ID(ro) as siteId, ID(rt) as rt:ResourceType 

",1,68586519
2323,https://stackoverflow.com/a/68579803,Find closest node that matches criteria but cannot have intermediary nodes that have certain properties,true,"Might not be the most optimized, but I would try the following:

    MATCH p=(a)&lt;-[*]-(b:WorkOrderNode {action_code: &#39;INS&#39;})
    WHERE ID(a)=105 AND 
    NONE(node IN nodes(p) WHERE node:WorkOrderNode AND node.action_code IN [&#39;MV&#39;, &#39;SPT&#39;])
    RETURN b, length(p) as distance
    ORDER BY distance
    LIMIT 1",1,68579803
2324,https://stackoverflow.com/a/68605909,Field-level cypher statements do not work when accepting parameters in Apollo-server,false,"The library `&quot;neo4j-graphql-js&quot;: &quot;^2.19.2&quot;` does not seem to pass on custom parameters unless you create a mutation. Try the following way:

```
type Question {
  id: ID! @id
  required: Boolean
}

extend type Mutation {
  testing(someId: ID!): Boolean
    @cypher(
      statement: &quot;&quot;&quot;
      MATCH (q:Question {id: $someId}) RETURN q.required
      &quot;&quot;&quot;
    )
}
```

```
mutation {
  testing (someId: &quot;12345678-1234-1234-1234-0123456789ab&quot;) 
}
```

",0,68605909
2325,https://stackoverflow.com/a/68568548,How to remove NEO4J from CE edition,false,"I recreate an empty ENO4J on CE. .. by ref. other post on this stackoverFlow.

1. stop neo4j
2. remove /var/lib/neo4j/data/databases/neo4j
3. remove /var/lib/neo4j/data/transactions/neo4j
4. start neo4j

You have to remove the neo4j directory under transactions too.",0,68568548
2326,https://stackoverflow.com/a/68568568,How to remove NEO4J from CE edition,false,"ref. you can find out why the neo4j database could not startup from following log file.

/var/log/neo4j/debug.log

Caused by: java.lang.RuntimeException: Fail to start &#39;DatabaseId{483e7f9b[neo4j]}&#39; since transaction logs were found, while database files are missing.
",0,68568568
2327,https://stackoverflow.com/a/68561508,Giving conditions to Neo4j Nodes,false,"I&#39;m not sure, if I understand you correctly: You just want a query that matches the graph in the second figure? Or am I missing something?

You can `MATCH` more complex patterns that are not just linear:

```
MATCH (n:label {Name_1: &#39;A&#39;}), (m:label {Name_1: &#39;F&#39;}), (o:label {Name_1: &#39;E&#39;})
MATCH (n)--(p)--(q)--(r),
      (p)--(m),
      (p)--(o)
RETURN n, m, o, p, q, r
```

Or more compact:

```
MATCH (n:label {Name_1: &#39;A&#39;})--(p)--(q)--(r),
      (p)--(m:label {Name_1: &#39;F&#39;}),
      (p)--(o:label {Name_1: &#39;E&#39;})
RETURN n, m, o, p, q, r
```

",0,68561508
2328,https://stackoverflow.com/a/68547980,Neo4j - Mass edit node properties - i.e. mass edit all keys(n),true,"
You will need APOC to create dynamic properties: take a look at the following post: https://dzone.com/articles/neo4j-dynamically-add-propertyset-dynamic-property

    CALL apoc.create.setProperty(c, collUPPERKeys, replace(...))

Similarly for removing dynamic properties, you will need APOC as well.

    CALL apoc.create.removeProperties(c, collKeys)
YIELD node

If we put it all together:


    MATCH (c:Category)
    WITH c 
    UNWIND keys(c) as collKeys
    WITH collKeys,c
    WITH collKeys, REPLACE(toUPPER(collKeys),&quot; &quot;, &quot;_&quot;) as collUPPERKeys,c
    WHERE collKeys &lt;&gt; &#39;source&#39;
    // set dynamic properties
    CALL apoc.create.setProperty(c, collUPPERKeys, replace(toUPPER(c.collKeys),&quot; &quot;, &quot;_&quot;)) YIELD node as foo
    // remove dynamic properties
    CALL apoc.create.removeProperties(c, [collKeys]) YIELD node
    return c

    

",1,68547980
2329,https://stackoverflow.com/a/68542303,Connecting one node to multiple Neo4j,true,"Does the following work?

```cypher
:auto USING PERIODIC COMMIT 
LOAD CSV WITH HEADERS FROM &#39;file:///LabSample.csv&#39; AS row
CREATE (i:ID) SET i += row 
CREATE (l:laboratory {name:&quot;New York&quot;})
MERGE (i)-[:MADE]-&gt;(l)
```

Basically remove the `MATCH` since it would rebind `i` to all the nodes matching the new pattern.

Side note: node labels are usually written in PascalCase, so favor `Id` over `ID` and `Laboratory` over `laboratory`.",1,68542303
2330,https://stackoverflow.com/a/68530348,Get node label name from csv file,false,"from neo4j [community][1] [dana.canzano][2]&#39;s answer. It could be implemented by apoc library. Here is the code.

    load csv with headers from &#39;file:///B.csv&#39; as row 
    call apoc.create.node([row.label],{name: row.name}) 
    yield node return count(node);
You can find more details in community [page][1]


  [1]: https://community.neo4j.com/t/get-node-label-name-from-csv-file/41994
  [2]: https://community.neo4j.com/badges/29/hot-link?username=dana.canzano",0,68530348
2331,https://stackoverflow.com/a/68538873,neo4j - Exporting data to SQL/MS Access via apoc.load.jdbcUpdate,true,"It appears I have something that works now using a CREATE function then adding an ALTER TABLE statement for each element in the rows (after UNWIND.)

Effectively I unwind the list into a table format then the apoc function runs table with some default column and then run ALTER table commands to edit for each column but it also allows me to modify the data type for each row (in the example below)

It does seem redundant to run each line to the apoc.load.jdbcUpdate() function it allows me to have some control and doesn&#39;t really impact speed. (creates ~100 columns in 54ms for a larger data set which doesn&#39;t seem to bad)

```
:param exportUrl =&gt; &#39;jdbc:ucanaccess:///artifacts/export/sample.accdb&#39;

WITH [&#39;colA&#39;, &#39;colB&#39;, &#39;colC&#39;, &#39;colD&#39;, &#39;colE&#39;, &#39;colF&#39;, &#39;colG&#39;, &#39;colH&#39;, &#39;colI&#39;, &#39;colJ&#39;] AS listCOLS
UNWIND listCOLS as columnNAMES
WITH columnNAMES,
 &#39;CREATE Table TBL_ATTR ([DEFAULT] TEXT(12))&#39; as statement
CALL apoc.load.jdbcUpdate($exportUrl, statement) YIELD row
WITH columnNAMES,
CASE columnNAMES  //modify data types for various data
     WHEN &quot;colB&quot; THEN &#39;ALTER TABLE TBL_ATTR ADD COLUMN &#39; + columnNAMES +  &#39; DOUBLE&#39;
     WHEN &quot;colC&quot; THEN &#39;ALTER TABLE TBL_ATTR ADD COLUMN &#39; + columnNAMES +  &#39; INTEGER&#39;
     WHEN &quot;colH&quot; THEN &#39;ALTER TABLE TBL_ATTR ADD COLUMN &#39; + columnNAMES +  &#39; DATE&#39;
     WHEN &quot;colJ&quot; THEN &#39;ALTER TABLE TBL_ATTR ADD COLUMN &#39; + columnNAMES +  &#39; TEXT(12)&#39;
ElSE &#39;ALTER TABLE TBL_ATTR ADD COLUMN &#39; + columnNAMES + &#39; TEXT(25)&#39;
END as statement
WITH columnNAMES, statement
CALL apoc.load.jdbcUpdate($exportUrl, statement) YIELD row
return count(row);

```
While the function executes successfully and I can see the columns correctly reflected in the export file, I do receive an error so not sure what is throwing the exception.

```
Failed to invoke procedure `apoc.load.jdbcUpdate`: Caused by: org.hsqldb.HsqlException: object name already exists: TBL_ATTR
```

",0,68538873
2332,https://stackoverflow.com/a/68513153,Should I use neo4j when want to save d3 force graph for next time rendering?,false,"The main reason for using a native graph database is hardly ever pure visualization. But yes, your d3 or any other library you will use , will expect a list of nodes and edges. There are many tools , including ours (Graphileon) that do that conversion of a set of nodes/edges or entire paths for you. 

disclosure:I work for graphileon",0,68513153
2333,https://stackoverflow.com/a/68525434,Neo4j: Unsupported administration command: CREATE DATABASE demo,true,"In the URL you used to install Neo4j, there is a remark about the community version of Neo4j and how it doesn&#39;t support multiple databases.

&gt; Note: The Community Edition of Neo4j supports running a single
&gt; database at a time. Additionally, the Community version does not
&gt; include the capability to assign roles and permissions to users so
&gt; those steps are not included in this tutorial. For more information
&gt; about various features that are supported by the Community Edition of
&gt; Neo4j, consult the Neo4j Documentation here.",2,68525434
2334,https://stackoverflow.com/a/68502572,Adding a relationship leads to an error in Graph Data Science Library,false,"The problem was that the name of the relationship was already used for a node. 
I changed the name for the relationship and now it works.

Seems that GDSL also needs different labels for the nodes and relationships.",0,68502572
2335,https://stackoverflow.com/a/68484449,How to fetch nodes and all their children in Spring Data Neo4j,false,"To get all the paths, you can use a variable-length pattern

    MATCH path=(person)-[parentOf:PARENT_OF*]-&gt;(child)
    WHERE person.parentId IS NULL
          AND NOT (child)-[:PARENT_OF]-&gt;()
    RETURN path",1,68484449
2336,https://stackoverflow.com/a/68495031,How to fetch nodes and all their children in Spring Data Neo4j,true,"I think we can agree that the first query by its nature does only one hop because you explicitly say with `(person)-[parentOf:PARENT_OF]-&gt;(children)` that you only want to find the direct children.

The suggestion @Graphileon gave goes into the right direction but from its return part only provides an unordered set of nodes and relationships.
Spring Data Neo4j can only assume that all Persons have the same importance and thus returns a collection of all Persons.

What I would suggest is to stay with the path-based approach but modifying the return statement in a way that Spring Data Neo4j and you agree on ;)

```
MATCH path=(person)-[:PARENT_OF*]-&gt;(child:Person)
WHERE person.parentId IS NULL
RETURN person, collect(nodes(path)), collect(relationships(path))
```

Reference: https://docs.spring.io/spring-data/neo4j/docs/current/reference/html/#custom-queries.for-relationships.long-paths

Another approach could also be that you are using the so-called derived finder methods in your repository:
```
List&lt;Person&gt; findAllByParentIdIsNull();
```
Or if you want to have it _pageable_ (don&#39;t forget some ordering because the data could get returned randomly otherwise):
```
Page&lt;Person&gt; findAllByParentIdIsNull(Pageable pageable);
```

This creates the internal query generator which will do an explorative search (non-path based queries) over the data with multiple cascading queries.

There are (in general) a few things to keep in mind when making the decision:

1. The path-based approach could really ramp up the memory usage in the database if you have a lot of hops and branches which leads to relative slow response times. I assume that won&#39;t be a problem for your domain above but this is always something I would keep an eye on.
2. In both cases (path-based or cascading queries) you will end up with three buckets of data: The root node, all relationships and all related nodes. The mapping will take some time because Spring Data Neo4j would have to match every returned relationship with the right related node for each relationship it wants to map. There is nothing wrong with this but the result of having a cyclic mapped domain.",1,68495031
2337,https://stackoverflow.com/a/68469052,GRAND Stack queries always returns NULL,false,"Neo4j GraphQL autogenerates the queries and mutations for you. In your `typeDefs` remove the manual queries: 

```gql
type Query {
    features: [Feature]
    symptoms: [Symptom]
}
```",0,68469052
2338,https://stackoverflow.com/a/68462169,"Cypher Conditional `ORDER BY` clause (same property, differ ASC/DESC)",true,"You can add a column with a sortValue like this

    RETURN  n.value,
            CASE WHEN sortType = ‘DESC’ THEN n.value * -1 ELSE n.value END AS sortValue
    ORDER BY sortValue

Adding the sortValue in your RETURN statement makes that you get either

    | value | sortValue |
    |     1 |          1|
    |     2 |          2|
    |     3 |          3|


OR

    | value | sortValue |
    |     3 |         -3|
    |     2 |         -2|
    |     1 |         -1|


You can use this mechanism also in case you want to have flexibility with regard to which column you want to sort, as long as you make sure that you put the right value in the sortValue column.",1,68462169
2339,https://stackoverflow.com/a/68728235,"Cypher Conditional `ORDER BY` clause (same property, differ ASC/DESC)",false,"You can add 2 expressions for ORDER BY:
```ORDER BY 
     CASE WHEN sortType = &quot;ASC&quot; THEN n.value ELSE null END ASC,
     CASE WHEN sortType = &quot;ASC&quot; THEN null ELSE n.value END DESC
```
They will be both applied, but the first one won&#39;t do anything when sortType is not &quot;ASC&quot; and the second won&#39;t do anything when the sortType is &quot;ASC&quot;.",0,68728235
2340,https://stackoverflow.com/a/68453173,Neo4j create node with conditions,false,"I understand this question as follows:

When I ask for neighbours of A, it should only return those neighbours that, if they themselves have other neighbours, all have `booleanProp = true`

This should get you there

    MATCH path=(n:Label {name:&#39;A&#39;})-[:MYREL]-&gt;(m)
    
    WHERE ALL (k IN [(m)--(l) | l.booleanProp] WHERE k)
    
    RETURN path",0,68453173
2341,https://stackoverflow.com/a/68458397,Neo4j not returning nested records consistently,false,"This should work (first collect the toppings for each pizza, then collect the pizzas and their toppings)


    MATCH (o:order)
    WHERE id(o) = $id
    OPTIONAL MATCH (o)-[:ORDER_INCLUDES]-&gt; (p:pizza)
    WITH o, p
    OPTIONAL MATCH (p) -[:WITH_TOPPING]-&gt; (t:topping)
    WITH o,p, COLLECT(t) AS toppings
    RETURN o,COLLECT ({pizza:p,toppings:toppings}) AS pizzas


Buon appetito",1,68458397
2342,https://stackoverflow.com/a/68463772,Neo4j not returning nested records consistently,false,"To prevent the record from splitting, the following had to be removed

    OPTIONAL MATCH (e:event) WHERE (e) -[:FOR]-&gt; (o) OR (e) -[:FOR]-&gt; (pizza)

Now this is the solution I&#39;m working with

    WITH (o:order)
    WHERE ID(o) = &lt;some id&gt;
    OPTIONAL MATCH (o) -[:ORDER_INCLUDES]-&gt; (p:pizza)
    WITH o, p
    OPTIONAL MATCH (p) -[:WITH_TOPPING]-&gt; (t:topping)
    OPTIONAL MATCH (p) &lt;-[:FOR]- (e:event)
    WITH o, {
      pizza: p,
      time: MAX(e.time),
      toppings: COLLECT(DISTINCT t)
    } AS pi
    RETURN o, MAX(pi.time) AS time, COLLECT(DISTINCT pi) AS pizzas",0,68463772
2343,https://stackoverflow.com/a/68438202,Is it OK to have millions of directed relationships between two nodes in Neo4j? Will it add to latency in fetching the data?,true,"I assume in the future, you may want to add other data to transactions, like the :Card :Device or :Platform on which it was triggered/Executed. As you probably know, you cannot create an edge between an edge and a vertex.

I would therefore recommend to use `(:Transaction)` vertices, with edges to the `(:Account`) vertices. You could use `[:SENDER]`  and `[:RECEIVER]` types for the edges.


 ",0,68438202
2344,https://stackoverflow.com/a/68441039,Is it OK to have millions of directed relationships between two nodes in Neo4j? Will it add to latency in fetching the data?,false,"Here is how I&#39;ve modeled this in the past. You might need to make a few adjustments to model it in Neo4j, but the general gist is there. Sample projects attached. 
_______

&gt; Because a customer might have multiple accounts

**Customer -(CUSTOMER_ACCOUNT)- Account**

&gt; Capture the directionality of the transactions

**Account - (SEND_TRANSACTION)-&gt; Transaction**

**Account &lt;-(RECEIVE_TRANSACTION)-Transaction**

&gt; Here I capture a running total of min_Send, min_receive, max_send, max
&gt; receive, transaction_send_count, transaction_recive_count, etc

Account -(SEND_TO)-&gt; Account 
______________

I&#39;ve open-sourced the project here:

- https://github.com/TigerGraph-DevLabs/AMLSim_Python_Lab

Sample Google Colab:

- https://colab.research.google.com/drive/1QnYXgypDYKMxuGfMLEtWcIVkp61njkrw?usp=sharing
_____________",0,68441039
2345,https://stackoverflow.com/a/68424036,Neo4J Plug In Won&#39;t Compile Due to Version Mismatch,false,"I finally fixed this.  The solution was: (i) cut existing java code (and POM file); (ii) delete original project altogether; (iii) create a new maven project but choose JDK 16 as SDK this time; and (iv) paste Java code and POM xml into new project.  Then I built it, and ran maven clean package, inserted the target snapshot into the plug ins folder and ... it finally worked.",0,68424036
2346,https://stackoverflow.com/a/68576771,jqassistant-maven-plugin: cannot connect browser to embedded Neo4j,true,"After setting `&lt;embeddedBoltPort&gt;45856&lt;/embeddedBoltPort&gt;` (an arbitrary high number) I can finally connect. For some reason the port was not allowed to come up, even changing it to something commonly used like 8080 did not work.

I do not understand why this happened, because the port was not used. When testing a used port the correct exception appears that it is already in use. **I can only assume some weird security setting at the client**.

My only suggestion for the jqassistant-maven-plugin would be to test if all required ports are up and running even when no exception occured during startup.

Thanks anyone for sharing ideas to track this down.",0,68576771
2347,https://stackoverflow.com/a/68424217,(Neo4j 3.5) Executing query with two parts and the second one consists on a group of matches where at least one needs to be fulfilled,true,"Since you do not know which of the three matches in the second part will yield results, I would try something along the lines below:

NOTE I used ASSOCIATED instead of ASOCIATED


    MATCH (n)&lt;-[:ASSOCIATED|COMMENTED|HAS_ATTACHMENT]-(t)-[rel:COMPLETED|PENDING]-&gt;(ob)&lt;-[:HAS_OPEN_OBJECT|HAS_CLOSED_OBJECT]-(do)
    WHERE 
          (n:Action AND n.name CONTAINS &#39;body&#39;)
          OR
          (n:Comment AND n.body CONTAINS &#39;body&#39;)
          OR 
          (n:Attachment AND n.name CONTAINS &#39;body&#39;)
    RETURN COLLECT(DISTINCT {data_object_uid: do.uid})",2,68424217
2348,https://stackoverflow.com/a/68405652,Less than operator issue in neo4j,true,"From your comment
`MATCH (n:ProjectField) Where n.value &lt; &quot;41&quot; RETURN n output: &quot;value&quot;: &quot;100&quot; &quot;value&quot;: &quot;40214&quot; &quot;value&quot;: &quot;12345&quot;` i assume the values you compare are string values (hece the `&quot;&quot;`).
In that case cypher uses string comparison and since 1 is smaller than 4 in the first char it think 100 is smaller than 41.

You can try to update the string numbers to integers or compare the integervalues of `n.value` using `toInteger`.",0,68405652
2349,https://stackoverflow.com/a/68394917,Can we match subgraphs in cypher?,false,"Maybe the [APOC path expander](https://neo4j.com/labs/apoc/4.1/graph-querying/path-expander/) procedures serve your needs. You have much control over how the graph should be traversed.

However, you don&#39;t get a subgraph into one variable as you have in mind:

`CALL apoc.path.expandConfig(n, { ... }) YIELD path` will return multiple rows (one row for each found path).

`CALL apoc.path.subgraphAll(n, { ... }) YIELD nodes, relationships` will return lists of all found nodes and relationships.
",1,68394917
2350,https://stackoverflow.com/a/68396378,Can we match subgraphs in cypher?,false,"

    MATCH path1=(n)-[r]-(m)-[s]-(p),
          path2=(m)-[j]-(u)
    RETURN apoc.coll.toSet(nodes(path1),nodes(path2)) AS subGraphNodes,
           apoc.coll.toSet(rels(path1),rels(path2)) AS subGraphRelationships

Would return the distinct nodes and rels for each matching subgraph.


If you just need the virtual subgraph, you can use

    apoc.graph.fromPaths()",0,68396378
2351,https://stackoverflow.com/a/68374094,Nodes without names in Neo4j,false,"LOAD CSV processes your data line by line. The easiest fix would be to repeat the question on each line and use

    MERGE (q:Question {name:line.name})

to avoid duplication.

BTW  : I don&#39;t think there is something like &quot;sub-nodes&quot;, I would call give them a label &#39;AnswerOption&#39; ;) ",1,68374094
2352,https://stackoverflow.com/a/68382550,How to query a Neo4j relationship in R?,false,"I figured it out! I am using a template and didn&#39;t realize that my schema was being inferred from Neo4j, so I wasn&#39;t allowed to change it. I changed my index.js to include a console print out of my schema and found the name of the relationship I needed. 

   

        const inferAugmentedSchema = driver =&gt; {
      return inferSchema(driver).then(result =&gt; {
        console.log(result.typeDefs)
        return makeAugmentedSchema({
          typeDefs: result.typeDefs
        });
      });
    };


I know a lot more of the template than I did yesterday, haha!",0,68382550
2353,https://stackoverflow.com/a/68364671,Neo4j foreach clause to loop through elements of string array,false,"You are probably looking for `UNWIND`.

&gt; With `UNWIND`, you can transform any list back into individual rows. These lists can be parameters that were passed in, previously `collect`-ed result or other list expressions.
https://neo4j.com/docs/cypher-manual/4.3/clauses/unwind/

With `UNWIND` you can turn `string_arrays` into individual rows, perform `MATCH` to find the name, and finally aggregate the names as a list:

```
UNWIND string_arrays AS pk
MATCH (g:Ingredient) WHERE g.pk = pk
RETURN collect(g.name) AS names
```

However, if you already have multiple rows with `MATCH (r:Recipe)`, this probably would mix up the lists. So you might need to call `UNWIND` within a [subquery](https://neo4j.com/docs/cypher-manual/4.3/clauses/call-subquery/):

```
WITH &quot;Ingredients: &quot; AS s
MATCH (r:Recipes) WHERE r.ingredients_list ~= &quot;Ingredients: .*&quot;
WITH split(substring(r.ingredients_list, size(s), size(r.ingredients_list))) AS string_arrays
CALL {
  WITH string_arrays
  UNWIND string_arrays AS pk
  MATCH (g:Ingredient) WHERE g.pk = pk
  RETURN collect(g.name) AS names
}
RETURN names
```",0,68364671
2354,https://stackoverflow.com/a/68369188,Neo4j foreach clause to loop through elements of string array,false,"    WITH &quot;Ingredients: &quot; AS s
    MATCH (r:Recipes) WHERE r.ingredients_list ~=           &quot;Ingredients: .*&quot;
    // carry along the r to keep the recipes apart
    WITH r,split(substring(r.ingredients_list, size(s), size(r.ingredients_list))) AS string_arrays
    
    UNWIND string_arrays AS pk
    
    MATCH (g:Ingredient) WHERE g.pk = pk
    
    // return the Recipes node (or just its id) and the ingredient names
    RETURN r,collect(g.name) AS names",0,68369188
2355,https://stackoverflow.com/a/68407323,NEO4J How to make graph with relationships,true,"For the first question:

&gt; How can I create a graph in NEO4J where the nodes are my unique page names and the relationships between nodes are drawn if there is a similarity score between them (so if the sim-score is 0 they don’t draw a relationship)?

I think a better approach is to remove in advance the rows with similarity = 0.0 before ingesting them into Neo4j. Could it be something feasible? If your dataset is not so big, I think it is very fast to do in Python. Otherwise the solution you provide of deleting after inserting the data is an option. 
In case of a big dataset, maybe it&#39;s better if you load the data using **apoc.periodic.iterate** or ```USING PERIODIC COMMIT```.

Second question

&gt; I want to know if there is an easy way to figure out which node had the most relationships to other nodes?

This is an easy query. Again, you can do it with play Cypher or using APOC library:
```lang-cypher
# Plain Cypher
MATCH (n:Page)-[r:SIMILAR]-&gt;()
RETURN n.name, count(*) as cat
ORDER BY cnt DESC

# APOC 
MATCH (n:Page)
RETURN apoc.node.degree(n, &quot;SIMILAR&gt;&quot;) AS output;
```

**EDIT**
To display the similarity scores, in Neo4j Desktop or in the others web interfaces, you can simply: click on a SIMILARITY arrow --&gt; on the top of the running cell the labels are shown, click on the SIMILAR label marker --&gt; on the bottom of the running cell, at the right of *Caption*, select the property that you want to show (*similarity* in your case)

Then all the arrows are displayed with the similarity score

[![enter image description here][1]][1]
 


  [1]: https://i.stack.imgur.com/QOJVt.png",1,68407323
2356,https://stackoverflow.com/a/68424107,NEO4J How to make graph with relationships,false,"To the second question:  I think you should keep a clear separation between the way you store data and the way you visualize it. Having the similarity score (a property of the SIMILARITY edge) as a &quot;label&quot;  is something that is best dealt with by using an adequate viz library or platform. Ours (Graphileon) could be such a platform, although there are also others. 

We offer the possibility to &quot;style&quot; the edges with so-called selectors like

`&quot;label&quot;:&quot;(%).property.simScore&quot;`  that would use the simScore as a label. On top of that you could do thing like  

    &quot;width&quot;:&quot;evaluate((%).properties.simScore &lt; 0.500 ? 3 : 10)&quot;

or 

    &quot;fillColor&quot;:&quot;evaluate((%).properties.simScore &lt; 0.500 ? grey : red)&quot;

to distinguish visually high simScores.

Full disclosure :  I work for Graphileon.
",0,68424107
2357,https://stackoverflow.com/a/68518005,jQAssistant: How does the store reset work?,false,"The defined behavior is such that the store is reset before scanning the first module of a reactor build. So usually there is no need to explicitly the reset behavior if all required modules can be scanned within the same build reactor.

Vice versa: reset must be deactivated for scans within a build reactor (e.g. a `mvn package` command) if an existing scan from a previous reactor build shall be extended.

The reset behavior of the scan goal can be controlled via the reset flag:

    &lt;plugin&gt;
      &lt;groupId&gt;com.buschmais.jqassistant&lt;/groupId&gt;
      &lt;artifactId&gt;jqassistant-maven-plugin&lt;/artifactId&gt;
      &lt;configuration&gt;
        &lt;store&gt;
          &lt;uri&gt;bolt://my-neo4j-store.com:7687&lt;/uri&gt;
          &lt;username&gt;neo4j&lt;/username&gt;
          &lt;password&gt;reallysecret&lt;/password&gt;
          &lt;encryption&gt;false&lt;/encryption&gt;
        &lt;/store&gt;

        &lt;reset&gt;false&lt;/reset&gt; &lt;!-- true is the default setting to clear the store at the beginning of each reactor build --&gt;

      &lt;/configuration&gt;
    &lt;/plugin&gt;

Please update your configuration (you used `resetStore` within another `configuration` section).",0,68518005
2358,https://stackoverflow.com/a/68544376,jQAssistant: How does the store reset work?,false,"Ah, now I see what the problem is: The configuration for resetting the store is called `reset` and **not** `resetStore`. When I use `reset` as proposed by Dirk Mahler, everything works fine!

Instead of [looking at the source][1] I read the [documentation][2], which is wrong. I will write a bug in GitHub.

Dirk, thanks a lot for the suppport!


  [1]: https://github.com/jQAssistant/jqa-maven-plugin/blob/master/src/main/java/com/buschmais/jqassistant/scm/maven/ScanMojo.java#L56
  [2]: https://jqassistant.github.io/jqassistant/doc/1.10.0/manual/index.html#_plugin_configuration",0,68544376
2359,https://stackoverflow.com/a/68328091,How to Create and Use New Database for Neo4j Unit Test?,false,"I do not use setting.py to identify my Neo4j database. I have functions which I call for Neo4j and they load or query the database. The database is a variable used throughout my python code so that it can be easily changed and propagated to all the downstream code. 

Here are a couple of these functions:

    from neo4j import GraphDatabase
    from pandas import DataFrame
    
    neo4jdriver=GraphDatabase.driver(Neo4Server, auth=(Neo4UserName,Neo4Pswd),database=&#39;neo4j&#39;)
    neo4jsession = neo4jdriver.session(database=&#39;neo4j&#39;)
    
    def CypherToPandas(Q, database):
        driver=GraphDatabase.driver(Neo4Server, auth=(Neo4UserName,Neo4Pswd),database=database )  #&quot;neo4j&quot;))  #AzureLib.Neo4Pswd))
        with driver.session(database=database) as cyphersession:
            rslt = cyphersession.run(Q)
            df = DataFrame(rslt.data())
            cyphersession.close()
            driver.close()
            return df
    
    def CypherToText(Q, database):
        driver=GraphDatabase.driver(Neo4Server, auth=(Neo4UserName,Neo4Pswd),database=database )  #&quot;neo4j&quot;))  #AzureLib.Neo4Pswd))
        with driver.session(database=database) as cyphersession:
            rslt = cyphersession.run(Q)
            r = rslt.data()
            cyphersession.close()
            driver.close()
            return r

 
",0,68328091
2360,https://stackoverflow.com/a/68352180,"Building a product recommendation system, collaborative filtering and graph database",true,"Neo4j is perfectly suited for this problem. What you must realize is that it makes sense to have a batch process to calculate similarity between users or items when you scale to millions of users and store it to Neo4j. Then you can provide very fast response times. If you want to calculate similarity between millions of users at every step, that might not be the most effective process. So it is a trade-off between precalculated similarities and doing on the fly similarity calculations. For example, you can pre-calculate similarities between items every day and take a window of x days of purchase as your &quot;training&quot; data. Then you can easily provide &quot;Users also bought this&quot; recommendations. There are also options to use more advanced techniques like GNN to provide recommendations. For example look at this project: https://github.com/AliciaFrame/GDS_Retail_Demo

So all in all, Neo4j is completely suitable for recommendations, there have been books written just about recommendations and graphs (Neo4j). ",0,68352180
2361,https://stackoverflow.com/a/68308691,Cypher query to find users who are connected to at least two other user in given list,true,"When you say &quot;at least 2 users&quot; then it should be &gt;= rather than =.  Then you count distinct users m that are followed by another users p1, p2,..,pn. 

    WITH [&quot;123&quot;, &quot;456&quot;, &quot;789&quot;] as ids
    MATCH (p:user)-[:follower]-&gt;(m:user)
    WHERE m.id in ids
    WITH p, count(DISTINCT m) as cnt where cnt &gt;= 2
    RETURN p

If you want to return users m then do a collect and check the size.

    WITH [&quot;123&quot;, &quot;456&quot;, &quot;789&quot;] as ids
    MATCH (p:user)-[:follower]-&gt;(m:user)
    WHERE m.id in ids
    WITH p, collect(DISTINCT m) as m_users where size(m_users) &gt;= 2
    RETURN p, m_users

EDIT:
 

&gt;1. Do a match of users from the id list
&gt;2. Using OPTIONAL match, find all followers to m
&gt;3. Check if the count is &gt;= 2 OR no connection to the list OR connection within the list
&gt;4. Return distinct followers p and users m

    WITH [ &quot;222&quot; , &quot;333&quot;, &quot;789&quot;] as ids
    MATCH (m:user) WHERE m.ID in ids
    WITH collect(m) as ms
    OPTIONAL MATCH (p:user)-[:follower]-&gt;(m) WHERE m in ms  
    WITH p, ms, collect(DISTINCT m) as m_users  
      WHERE size(m_users) &gt;= 2 OR p is null OR p in ms
    WITH p,  ms + m_users as allUsers
    UNWIND allUsers as m
    RETURN distinct p, m

See below result:
 [![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/KfJXE.png",1,68308691
2362,https://stackoverflow.com/a/68348180,How to delete a relationship of a neo4j node in spring data,false,"The warning message is exactly what leads into the situation you are faced with.
Because you are using an assigned, manual provided id, Spring Data Neo4j cannot differentiate if the object is new or not.
The solution is to provide a `@Version` field in the entity (like `@Version Long version`).
From this SDN can derive the information if the element comes from the database or was newly created.

As a consequence of the wrongly assumed new state of the entity, no relationships will be deleted because it is not necessary from the persistence logic.",0,68348180
2363,https://stackoverflow.com/a/68372801,How to delete a relationship of a neo4j node in spring data,false,"    @Query(&quot;MATCH(user1:User {mobile: $mobile1})-[c:CONTACT]-(user2:User {mobile:$mobile2}) DETACH DELETE c&quot;)
    public String deleteContact(String mobile1, String mobile2);

Have found the above solution very easy and good in performance I think. @meistermeier point is also valid and considerable.",0,68372801
2364,https://stackoverflow.com/a/68303376,How to calculate the price of Neo4j enterprise if i get data from S3,false,"There are two components of the cost. Those of Neo4j per se and then of the virtual machine. The latter will be based on the size of the database which can be computed (approximated) based on the number of nodes, relationships and edges. 

[https://neo4j.com/hardware-sizing/][1]


  [1]: https://neo4j.com/hardware-sizing/

You&#39;ll have to work with Neo4j or the hosting platform on the cost of their software.

",0,68303376
2365,https://stackoverflow.com/a/68297325,How to read a simple graphml file in Neo4J,true,"Make sure you&#39;ve setup up a project with a Database Management System (DBMS) and a local database.

After that you need to install a plugin called [APOC][1] it provides neo4j with additional functionality i.e. to import .graphml files. This can be done by clicking on the DBMS (No button, just the cell) and selecting &#39;Plugins&#39; on the right tabs, see [Image 1][2]  
Then create  or modify the `apoc.conf` file in the conf folder which you can access by starting the DBMS of your database and on the top where is shows Active DBMS select the three dots on the right to and select &#39;Open Folder&#39; and &#39;Configuration&#39;, see [Image 2][3]   
**Make sure** the line `apoc.import.file.enabled=true` is in the `apoc.conf` file.  
Now open another folder, following the same steps as above but choosing &#39;Import&#39; instead. Place your .graphml file here which you would like to read.
Finally restart the DBMS, open the Neo4jBrowser and type the following command in the top row: `CALL apoc.import.graphml(&quot;file://YOURFILE.graphml&quot;, {})` and replace YOURFILE.  

That&#39;s it, for further reading I would recommend the [APOC Import Graphml docs][4]


  [1]: https://neo4j.com/labs/apoc/4.1/
  [2]: https://i.stack.imgur.com/yDKDp.png
  [3]: https://i.stack.imgur.com/IqTD5.png
  [4]: https://neo4j.com/labs/apoc/4.1/import/graphml/",1,68297325
2366,https://stackoverflow.com/a/68283298,An unusual cypher query challenge: finding intersections with nodes grouped by label,false,"A simple anonymous pattern match will get you results, e.g.: 

    MATCH (u:User {id:&#39;1&#39;})--&gt;()&lt;--(a:Ad)
    RETURN DISTINCT a.id, ...
    [ORDER BY] 
    [LIMIT 1]

It would need profiling to understand how it behaves on your dataset, but it is unlikely to meet your efficiency needs. 

Forcing the random sort order will slow the query down further, e.g.

    MATCH (u:User {id:&#39;1&#39;})--&gt;()&lt;--(a:Ad)
    WITH a, rand() as sortOrder
    RETURN DISTINCT a.id, ..., sortOrder
    ORDER BY sortOrder ASC 
    LIMIT 1

If I try something similar on one of my graph databases (on an m5.xlarge EC2 instance), where there are about 35k &#39;u&#39; nodes, 600k &#39;a&#39; nodes and 17 million edges between them - when profiling I see 11,054,599 total db hits in 9852 ms!

The APOC / GDS path functions don&#39;t seem to meet your needs.
Though you could look at writing a user defined function based on e.g. [APOC&#39;s Neighbors code][1]

How fast is the graph growing and how frequently is it updated? 
Just wondering whether there might be other approaches (e.g. pre-computed graph embedding) that could help with your response time requirement.


  [1]: https://github.com/neo4j-contrib/neo4j-apoc-procedures/blob/4.2/core/src/main/java/apoc/neighbors/Neighbors.java",0,68283298
2367,https://stackoverflow.com/a/68286026,An unusual cypher query challenge: finding intersections with nodes grouped by label,true,"Did you try something along these lines, a two step approach, subtracting the labels of the &quot;tags&quot; from the Ad of those from the user?

    MATCH (u:User {id:&#39;1&#39;})--&gt;()&lt;--(a:Ad)
    WITH DISTINCT u,a
    WHERE 
         SIZE(apoc.coll.subtract( 
                                  [(a)--&gt;(tag) | labels(tag)[0]],
                                  [(u)--&gt;(tag)&lt;--(a) | labels(tag)[0]]
                                )
             ) = 0
    RETURN a,rand() AS rand
    ORDER BY rand LIMIT 1",1,68286026
2368,https://stackoverflow.com/a/68277210,How to query a limit of employees under all companies?,false,"Not elegant but it should get what you want. Returns all Company nodes, three Person nodes and the total of Person nodes connected to the Company Node


    MATCH (c:Company)-[:EMPLOYS]-&gt;(p:Person)
    WITH c, collect(p) as people
    RETURN c, people[0..3], size(people) as total
    ORDER by c.name;",0,68277210
2369,https://stackoverflow.com/a/68369435,How to query a limit of employees under all companies?,false,"This returns up to 3 employees (even when there are none)

    MATCH (c:Company)
    WITH c,
         [(c)-[:EMPLOYS]-&gt;(p:Person)| p] AS persons
    RETURN c, persons[0..3], size(persons) as total
    ORDER by c.name",0,68369435
2370,https://stackoverflow.com/a/68570899,How to create queries using runtime managed labels using Neo4j-OGM?,false,"The `Filter` in Neo4j-OGM are property based and sadly cannot help you with this.
But you _could_ use the Neo4j CypherDSL if you do not want to write your own statements.

For this you can add the following dependency to your project
```
&lt;dependency&gt;
    &lt;groupId&gt;org.neo4j&lt;/groupId&gt;
    &lt;artifactId&gt;neo4j-cypher-dsl&lt;/artifactId&gt;
    &lt;version&gt;2021.3.0&lt;/version&gt; // &lt;- currently the latest version
&lt;/dependency&gt;
```

and use it for example like this in combination with a Neo4j-OGM `Session`:
```
Node node = Cypher.node(&quot;Contact&quot;, &quot;Label_added_in_labels&quot;);
Statement statement = Cypher.match(node.named(&quot;n&quot;)).returning(node).build();
Iterable&lt;User&gt; contacts = session.query(Contact.class, statement.getCypher(), Collections.emptyMap());
```",0,68570899
2371,https://stackoverflow.com/a/68270582,how do I create unique constraints on two properties in neo4j?,true,"It has this documentation:

https://neo4j.com/docs/cypher-manual/current/administration/constraints/#query-constraint-node-key

    CREATE CONSTRAINT [constraint_name] [IF NOT EXISTS]
    ON (n:LabelName)
    ASSERT (n.propertyName_1,
    n.propertyName_2,
    …
    n.propertyName_n)
    IS NODE KEY
    [OPTIONS &quot;{&quot; option: value[, ...] &quot;}&quot;]

    FOR EXAMPLE:
        CREATE CONSTRAINT uSourceTarget IF NOT EXISTS ON (m:route) ASSERT (m.source, m. target) IS NODE KEY

NB: Only applicable for Enterprise Edition (NOT community edition)",0,68270582
2372,https://stackoverflow.com/a/68272145,How to write ShortestPath cypher in neo4j for the Game of Thrones Dataset,false,"Without a starting node to query, it will do a database scan with all combinations of all characters in your dataset. If there are 2k characters in Game of Thrones then you are doing 4,000,000 (2k x 2k ) combinations.  Doing this will cause your query to hang and will not complete. You should start with given characters then work your way up.

    WITH [&#39;Tyrion Lannister&#39;, &#39;Arya Stark&#39;] as characters
    MATCH (n1:Person ) WHERE n1.name in characters 
    WITH n1
    MATCH (n2:Person) where n2.name &lt;&gt; n1.name
    MATCH p=shortestPath((n1)-[ :INTERACTS*]-(n2))
    RETURN DISTINCT length(p) as len, n1.name as Name1, n2.name as Name2 ORDER by len DESC, Name1, Name2

    Example:
    ╒═════╤══════════════════╤════════════════════════╕
    │&quot;len&quot;│&quot;Name1&quot;           │&quot;Name2&quot;                 │
    ╞═════╪══════════════════╪════════════════════════╡
    │14   │&quot;Arya Stark&quot;      │&quot;Mathis Rowan&quot;          │
    ├─────┼──────────────────┼────────────────────────┤
    │14   │&quot;Arya Stark&quot;      │&quot;Myles Mooton&quot;          │
    ├─────┼──────────────────┼────────────────────────┤
    │14   │&quot;Arya Stark&quot;      │&quot;Rhonda Rowan&quot;          │
    
    ....
    ├─────┼──────────────────┼────────────────────────┤
    │6    │&quot;Tyrion Lannister&quot;│&quot;Dacey Mormont&quot;         │
    ├─────┼──────────────────┼────────────────────────┤
    │6    │&quot;Tyrion Lannister&quot;│&quot;Dagos Manwoody&quot;        │
    ├─────┼──────────────────┼────────────────────────┤
    │6    │&quot;Tyrion Lannister&quot;│&quot;Dalla&quot;                 │
    └─────┴──────────────────┴────────────────────────┘",0,68272145
2373,https://stackoverflow.com/a/68270964,simple example of working with neo4j python driver?,false,"&gt; ```Python
&gt; def raw_query(query, **kwargs):
&gt;     neodriver = neo_connect()  # cached dbconn
&gt;     with neodriver.session() as session:
&gt;         try:
&gt;             result = session.run(query, **kwargs)
&gt;             return result.data()
&gt; ```

This is perfectly fine and works as intended on my end.

The error you&#39;re seeing is stating that there is a connection problem. So there must be something going on between the server and the driver that&#39;s outside of its influence.

Also, please note, that there is a difference between all of these ways to run a query:
 - ```Python
   with driver.session():
       result = session.run(&quot;&lt;SOME CYPHER&gt;&quot;)
   ```
 - ```Python
   def work(tx):
       result = tx.run(&quot;&lt;SOME CYPHER&gt;&quot;) 

   with driver.session():
       session.write_transaction(work)
   ```

The latter one might be 3 lines longer and the team working on the drivers collected some feedback regarding this. However, there are more things to consider here. Firstly, changing the API surface is something that needs careful planning and cannot be done in say a patch release. Secondly, there are technical hurdles to overcome. Here are the semantics, anyway:

 - Auto-commit transaction. Runs only that query as one unit of work.
   If you run a new auto-commit transaction within the same session, the previous result will buffer all available records for you (depending on the query, this will consume a lot of memory). This can be avoided by calling `result.consume()`. However, if the session goes out of scope, the result will be consumed automatically. This means you cannot extract further records from it. Lastly, any error will be raised and needs handling in the application code.
 - Managed transaction. Runs whatever unit of work you want within that function. A transaction is implicitly started and committed (unless you rollback explicitly) around the function.
  If the transaction ends (end of function or rollback), the result will be consumed and become invalid. You&#39;ll have to extract all records you need before that.  
  This is the recommended way of using the driver because it will not raise all errors but handle some internally (where appropriate) and retry the `work` function (e.g. if the server is only temporarily unavailable). Since the function might be executed multiple time, you must make sure it&#39;s idempotent. 

Closing thoughts:  
Please remember that stackoverlfow is monitored on a best-effort basis and what can be perceived as hasty comments may get in the way of getting helpful answers to your questions",0,68270964
2374,https://stackoverflow.com/a/68272328,Neo4j: How to pass a variable to a neo4j query,false,"Try using escape of double quotes:

    (n.APPLICATION=\&quot;{{App_name}}\&quot;)",0,68272328
2375,https://stackoverflow.com/a/68254004,Returning Neo4j map projection with WebFlux,false,"You need to return the actual nodes and relationships, otherwise you&#39;re missing the id-mapping.

There should be examples in the SDN docs.

Best if you have a small reproducible example (e.g. with the default movies graph).

Not sure if there is something off in your SDN setup, in general for such simple queries you should be able to just use a repository and not need to write cypher queries by hand.",1,68254004
2376,https://stackoverflow.com/a/68259665,Returning Neo4j map projection with WebFlux,false,"The general information given by Michael is correct but there is more in you question:
First of all the meta domain model is completely ignored if you are using the `Neo4jClient`. It does not automatically map anything back but uses the driver&#39;s types.
As a result you will end up with an (current state of this answer) `InternalRelationship` which does not have any getter-methods.
I assume that you are serializing the result in the application with Jackson. This is the reason why you see objects that represent the relationships but without any content within.

If you want to get things mapped for you, create also the domain objects properly and use (at least) the `Neo4jTemplate` with your query.
If you model `User`, `Game`, and the relationship properties like `PlayedGame` correctly, a 

`neo4jTemplate.findAll(&quot;MATCH (u:User)&lt;-[rel]-(g:Game) return u, collect(rel), collect(g)&quot;, User.class)` 

will map the results properly. Also if this is all you have, you could also skip the custom query at all and use

`neo4jTemplate.findAll(User.class)`

or

`neo4jTemplate.findById(useId, User.class)`",1,68259665
2377,https://stackoverflow.com/a/68231800,Failed to establish connection to Neo4j usign bolt scheme even after successfully enabling Bolt,false,"Perhaps you&#39;ve already checked this, but if not, can you ensure that port `7687` is also forwarded. When I tunnelled via browser, my expectation was that `7474` would be sufficient, but it turned out that forwarding `7687` is also necessary.",1,68231800
2378,https://stackoverflow.com/a/68232121,Failed to establish connection to Neo4j usign bolt scheme even after successfully enabling Bolt,true,"So, instead of providing localhost in the connection string, I made a silly mistake of writing down the actual IP and that was the reason for connection timeout.",1,68232121
2379,https://stackoverflow.com/a/68234937,How to get portion of variable-length pattern path where relationship attribute &gt;= some value?,true,"You should already get multiple rows with different path lengths. Just look for those paths where all relationships match your criteria.

```sql
MATCH p = (:Person {name: &#39;Jane&#39;})&lt;-[:KNOWS*1..10]-(:Person)
WHERE all(r IN relationships(p) WHERE r.confidence_factor &gt;= 0.75)
RETURN p
```

If you want to extract the nodes from the path without Jane (remove `tail()` if you want Jane to be included):

```sql
MATCH p = (:Person { name: &#39;Jane&#39;})&lt;-[:KNOWS*1..10]-(:Person)
WHERE all(r IN relationships(p) WHERE r.confidence_factor &gt;= 0.75)
UNWIND tail(nodes(p)) as person
RETURN DISTINCT person
```",0,68234937
2380,https://stackoverflow.com/a/68229958,Can&#39;t create fulltext index in neo4j 4.2.X,true,"I am looking at the docs and they seem a bit different. Try the following:

    CREATE FULLTEXT INDEX titlesAndDescriptions FOR (n:MYNODETYPE) ON EACH [n.label]

It seems the above syntax is for Neo4j 4.3+. Syntax for previous versions of Neo4j is as follows:

    CALL db.index.fulltext.createNodeIndex(&quot;titlesAndDescriptions&quot;, [&quot;MyNodeType&quot;], [&quot;label&quot;])

",1,68229958
2381,https://stackoverflow.com/a/68229985,Neo4j: How to get mutual nodes for list of nodes,false,"You also need to match your courses then. You can reuse the same variable to only get the mutual courses:

    MATCH (c:Course)&lt;-[:courses]-(me:Person {uuid: &#39;{my_id}&#39;})-[:friendship*2]-&gt;(p:Person)-[:courses]-&gt;(c)
    WHERE p.uuid&lt;&gt;&#39;{my_id}&#39;
    RETURN distinct(c) as courses",0,68229985
2382,https://stackoverflow.com/a/68234085,Neo4j: How to get mutual nodes for list of nodes,true,"First, find all the distinct persons at level 2 and all the distinct courses they have. Pass these values to the next part of the query using `WITH`.

Then for each of these courses check if `all` the people have it or not.


    MATCH path = (me:Person {uuid: &#39;{my_id}&#39;})-[:friendship*2]-&gt;(p:Person)-[:courses]-&gt;(c:Course)
    WHERE p.uuid&lt;&gt;&#39;{my_id}&#39;
    WITH collect(distinct(c)) as courses, collect(distinct(p)) as persons
    MATCH (c:Course)
    WHERE c in courses and all(p in persons where (p)-[:courses]-&gt;(c))
    RETURN c as courses

**EDIT:**
In case you need courses that have been added by at least two friends, then find the count of persons for each course and filter out.

    MATCH path = (me:Person {uuid: &#39;{my_id}&#39;})-[:friendship*2]-&gt;(p:Person)-[:courses]-&gt;(c:Course)
    WHERE p.uuid&lt;&gt;&#39;{my_id}&#39;
    WITH course, collect(distinct(p)) as persons
    WHERE size(persons) &gt;= 2
    RETURN collect(course) as courses
 ",0,68234085
2383,https://stackoverflow.com/a/68220063,NetworkXError: Input is not a known data type for conversion,false,"I&#39;m not sure exactly what you&#39;re expecting to happen here, but you&#39;re passing a connectivity object (Driver) into the constructor for the NetworkX Graph data type. The error is clearly appearing because NetworkX doesn&#39;t know what do to with that Driver object.

Instead, you&#39;ll need to _extract_ some data from the database by running a Cypher query, and then pass that data into the Graph constructor, assuming you have also coerced it into a form that NetworkX can accept.",1,68220063
2384,https://stackoverflow.com/a/68199045,COLLECT() causes function to enter infinite loading loop,false,"Your `MATCH` is a cartesian product combined with (undefined) variable length paths.
This is a very intensive query.

I would split the query into (1) matching the synonyms and then (2) getting addtional information of the node:

```sql
MATCH (seed:Seed_Term {name: &quot;valuation&quot;})-[r]-(syn), (n)
WHERE (n:Title OR n:Text OR n:Column OR n:RowName OR n:Cell)
AND (
  n.name =~ &quot;(?i).*&quot; + syn.name + &quot;.*&quot; // case insensitive regular expression
  OR n.content =~ &quot;(?i).*&quot; + syn.name + &quot;.*&quot;
)
WITH seed, n, r, collect(syn.name) AS synonyms
MATCH (n)&lt;-[*]-(z:Pdf)&lt;-[*]-(b:Label)
RETURN n.name AS node,
       synonyms,
       seed.name AS seed_term,
       b.labelName AS company,
       z.year AS year,
       type(r) AS rel_type
LIMIT 1000
```

I haven&#39;t tested this query, but maybe it leads you into the right direction.",0,68199045
2385,https://stackoverflow.com/a/68201750,Unable to connect to Neo4j with rusted_cypher,true,"It seems that rusted cypher doesn&#39;t work anymore with the changed database URLs, which are now `http(s)//:host:7474/db/&lt;database&gt;/tx`

But I found these two drivers that look more promising, recently updated and using bolt: 

https://github.com/lucis-fluxum/bolt-rs


https://github.com/yehohanan7/neo4rs

docs: https://docs.rs/neo4rs/0.5.8/neo4rs/
",2,68201750
2386,https://stackoverflow.com/a/68196899,Neo4j get all parents and grand parents,true,"If you need parents and grandparents in one list then you can use:

    MATCH (a) WHERE a.id = 1  
    WITH a 
    OPTIONAL MATCH (a)-[:PARENT*1..2]-&gt;(pg)  
    RETURN a, collect(pg) as parents

In case you need parents in one and grandparents in another list:

    MATCH (a) WHERE a.id = 1   
    WITH a  
    OPTIONAL MATCH (a)-[:PARENT]-&gt;(p)   
    OPTIONAL MATCH (p)-[:PARENT]-&gt;(gp)   
    RETURN a, collect(p) as parents, collect(gp) as grandparents


`WITH` is used to pass the matched node to the following sub-queries.

`OPTIONAL MATCH` is used so that the query returns results even if parents or grandparents nodes are not available for any node.


**Suggestion:** 
consider using labels for nodes e.g. Person",2,68196899
2387,https://stackoverflow.com/a/69097728,What causes ArrayIndexOutOfBoundsException when importing csv in neo4j?,false,"I had the same problem when trying to upload a huge document. Unfortunately, this exception does not provide you with supplemental information; it just flags a formatting issue of the file.
 
I used the &quot;,&quot; separator and it continuously failed. As a result, I analyzed the data and decided to use a different separator; for example, none of my fields contained the character &quot;&gt;&quot;, so I have used it as a separator and avoided the error.",1,69097728
2388,https://stackoverflow.com/a/69124637,What causes ArrayIndexOutOfBoundsException when importing csv in neo4j?,false,I had some strings with backslashes (which escaped the following tab). Deleting them solved it for me.,0,69124637
2389,https://stackoverflow.com/a/68214483,Map the id to its dateRange and return the result,false,"I&#39;m not an Java expert, but as far as I understand the docs `ArrayList.remove()` returns the element that was removed from the list. So, `id.remove(0)` will return `123`. I don&#39;t understand why you are calling `id.remove(0)`.

You have 2 options:

(1) Put the corresponding id into the `dateRangeMapList`:

```sql
UNWIND $dateRanges AS dateRange
MATCH (f:File)-[c:CHANGED]-(fo:Folder)
WHERE c.changedDate &lt; dateRange.endDate AND c.changedDate &gt; dateRange.startDate 
RETURN dateRange.startDate, dateRange.endDate, f, fo,  dateRange.id AS id
```

```java
dateRangeMapList =&gt; [
  { id=&quot;123&quot;, startDate=&quot;2021-01-09&quot;, endDate=&quot;2021-01-15&quot; },
  { id=&quot;234&quot;, startDate=&quot;2021-01-15&quot;, endDate=&quot;2021-01-21&quot; }
]
```

(2) Iterate over both arrays like a for loop (avoid calling `id.remove(0)`):

```sql
UNWIND range(0, size($dateRanges)) AS index
MATCH (f:File)-[c:CHANGED]-(fo:Folder)
WHERE c.changedDate &lt; $dateRanges[index].endDate AND c.changedDate &gt; $dateRanges[index].startDate 
RETURN $dateRanges[index].startDate, $dateRanges[index].endDate, f, fo, $id[index] AS id
```

```java
dateRangeMapList =&gt; [
  { startDate=&quot;2021-01-09&quot;, endDate=&quot;2021-01-15&quot; },
  { startDate=&quot;2021-01-15&quot;, endDate=&quot;2021-01-21&quot; }
]
id =&gt; [&quot;123&quot;, &quot;234&quot;]
```",0,68214483
2390,https://stackoverflow.com/a/68336536,Forced to use wss:// when behind proxy from https to http,false,I managed to get rid of wss by adding another nginx proxy to set the https url as upstream server in location.proxy_pass. It won&#39;t show wss/neo4j+s/bolt+s any more once you visit the web by the http url. Hopefully it will help for anyone has the similar issue as me.,0,68336536
2391,https://stackoverflow.com/a/68150195,Neo4j - Java heap space java.lang.OutOfMemoryError: Java heap space,false,"Increase your jvm heap size in neo4j configuration file found in config folder then do a restart.

     file: &lt;neo4j-home&gt;/conf/neo4j.conf

Here is the documentation about it.
https://neo4j.com/docs/operations-manual/current/configuration/neo4j-conf/#neo4j-conf-JVM",1,68150195
2392,https://stackoverflow.com/a/68149904,"Sending Ionic push notifications, neo4j",false,"You can send push notification using [OneSignal][1] which support Nest you can check this plugin [onesignal-api-client-nest][2]

and for ionic you can check the official plugin from [here][3]


  [1]: http://onesignal.com/
  [2]: https://www.npmjs.com/package/onesignal-api-client-nest
  [3]: https://ionicframework.com/docs/native/onesignal",1,68149904
2393,https://stackoverflow.com/a/68140879,Create nodes if optional match returns null,true,"`MERGE` always matches or creates the whole pattern. So, you might want to split up the `MERGE` clause, so that it matches or creates each node and the relationship:

```
MERGE (n:url {url_addr:&#39;test.com&#39;}) // match or create url node
MERGE (o:device {mode:&#39;iphone&#39;})    // match or create device node
MERGE (n)-[:FROM_DEVICE]-&gt;(o)       // match or create relationship
```

You might also want to have a look at conditional cypher execution with APOC procedures:
https://neo4j.com/labs/apoc/4.2/cypher-execution/conditionals/",1,68140879
2394,https://stackoverflow.com/a/68150265,For the given multiple nodes find a node,true,"EDITED:
For a given two Exam nodes, you can find the enrolled User node on both Exams (mtech and mca) by doing 1) an undirected match to User node 2) collect the exam names 3) then check if both names mtech and mca are in the collection

     MATCH (u :User) - [ :enrolled] - (e :Exam)
     WHERE e.name in [ &#39;mtech&#39;, &#39;mca&#39; ]   // assuming that an index is created for Exam.name
     WITH collect(distinct e.name) as exams, u
     WHERE ALL(ex in [ &#39;mtech&#39;, &#39;mca&#39; ] where ex in exams )
     RETURN u 
 

",1,68150265
2395,https://stackoverflow.com/a/68123480,Is apoc.rel.startNode removed from apoc 4.2.0.0?,false,"In 4.x, APOC core procs/functions are bundled with Neo4j and can be moved from the labs folder to the plugins folder for installation. It&#39;s possible that the function in question wasn&#39;t included in this core library.

You can look for and download the appropriate full version of APOC here, that will include functions and procedures beyond what is contained in the APOC core library.

https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases

Make sure you remove the existing jar when you add in the full jar, as if you try to start up with both in the plugins folder you&#39;ll encounter errors.",1,68123480
2396,https://stackoverflow.com/a/68126416,Issues using UNWIND to load data to Neo4j using python,false,"I can&#39;t read the error clearly due to bad formatting, but which version of Neo4j are you running? The parameter syntax changed a while ago from `{var}` to `$var`. That might be the cause.

Also, have you considered using py2neo&#39;s bulk load API, which wraps this kind of statement for you?
https://py2neo.org/2021.0/bulk/index.html",1,68126416
2397,https://stackoverflow.com/a/68117583,Deciding whether or not to pass an argument to a method in a using statement,true,"There&#39;s no need to create two `using` blocks. According to [the source][1], the `.Session()` overload that does not take any arguments, simply calls the other overload passing `null` to it. You could simply do the same.

Create an object of type `Action&lt;SessionConfigBuilder&gt;` whose value is determined by the version and then pass it to the `.Session()` method. It should look something like the following:

    var action = specificVersion ? SessionConfigBuilder.ForDatabase(db) : null;

    using (var conn = GraphDatabase.Driver(connectionString, AuthTokens.Basic(user, pass))
                                   .Session(action))
    {
    
    }


  [1]: https://github.com/neo4j/neo4j-dotnet-driver/blob/3b3abc065c4eca4adffe4b2d3dd724ba3f174879/Neo4j.Driver/Neo4j.Driver.Simple/DriverExtensions.cs#L37
",0,68117583
2398,https://stackoverflow.com/a/68103114,Neo4J Cypher - Find integer attributes,true,"Your query to update to integer is correct.


To clarify your assumptions, please run below queries in your neo4j desktop or browser and you will see what is going on.

     1. RETURN toInteger(&quot;2021-06-18T06:00:00&quot;)

     2. RETURN toInteger(null)

Both of them will return NULL.  It means your claim below is NOT true

&gt; This returns 1 - my NULL record, for some reason. But NOT the
&gt; STR, as I would have expected.

You did return 1 but is it the string value of records (&#39;30&#39;) rather than the NULL value.

Then when you run your query below
&gt; WHERE n.records = tointeger(n.records)

&gt; And this returns 0 - which again, I am not sure why.

It is because the integer value of a string date type is also NULL. Thus it will return no matching record.

If you want to count all nodes with non-integer attribute, including nulls then you can run below query.


    MATCH(n:logs)
    WHERE n.records &lt;&gt; tointeger(n.records) OR n.records is null
    RETURN count(distinct n) as cnt

    Result:  2

Remember, if n.records = &quot;2021-06-18T06:00:00&quot; then you need to convert it to an epoch value (the integer value of time in seconds or millis since 1/1/1970). If not, then tointeger(n.records) is null and will not match in your query.  

Do something like below:

    MATCH (n:logs)
    WHERE tointeger(n.records) is null
    SET n.records = datetime(n.records).epochMillis
    RETURN n

Then do your original query (this is correct!), to clean up other non-integer values.

    MATCH(n:logs)
    WHERE n.records &lt;&gt; tointeger(n.records)
    SET n.records = tointeger(n.records)",2,68103114
2399,https://stackoverflow.com/a/68176700,How to run batch transactions in neo4j,false,"It&#39;s due to throttle of apoc.spatial.geocodeOnce API calls. There&#39;s a rate-limiter on the number of requests you can make to the server.

You can buy google geocode API Key, configure inside **apoc.conf** file like,

    apoc.spatial.geocode.provider=google
    apoc.spatial.geocode.google.throttle=1
    apoc.spatial.geocode.google.key={YOUR_API_KEY}

Note - throttle here, is in mSec

",1,68176700
2400,https://stackoverflow.com/a/68091099,Count the number of neighbors for each node in Cypher,false,"First set it to zero for everyone because some people won&#39;t have any movies:

```cypher
MATCH (v:Person)
SET v.movies = 0
```

Then the key is to use a `WITH` clause, otherwise aggregation doesn&#39;t work.
```cypher
MATCH (v:Person)-[:ACTED_IN]-&gt;(m:Movie)
WITH v, count(*) AS movies
SET v.movies = movies
```",0,68091099
2401,https://stackoverflow.com/a/68108388,Clarification on order and size of network,true,"Yes, it&#39;s a common property of graphs, as the number of potential relationships between nodes increases at a rate proportional to the square of the number of nodes (exact formula below). Take a look how interconnections work between groups as the group scales.

While we could actually create the nodes, we can simulate this by just looking at the count of all possible combinations that could produce valid non-redundant relationships, and show the count when the set is maximally connected.

```
WITH range(1,100) as id
UNWIND id as a
UNWIND id as b
WITH a, b
WHERE a &lt; b
RETURN count(*)
```

If they&#39;re all linked, without redundant relationships we end up with 4950 relationships from 100 maximally linked individuals. For 1000 people maximally connected you would have 499500 relationships. For 10000 you would have a little short of 49995000 relationships. 

There&#39;s a formula to capture this, the number of edges possible for a complete graph, and it&#39;s even more simple to apply it than our prior query:

    WITH 100 as n
    RETURN (n * (n - 1)) / 2.0

Social networks are all about the myriad of connections between individuals, and as you can see as the number of nodes increase, the possible relationship count between them can skyrocket, even if they don&#39;t approach a complete graph.

You can also consider that within a social graph, there will likely be quite a few clusters of friends where each cluster might be maximally connected, and that will push up the relationship count, moreso with the size of the cluster.",1,68108388
2402,https://stackoverflow.com/a/68088570,NestJS / TypeOrm / Neo4j : Nest can&#39;t resolve dependencies of the NEO4J_DRIVER,true,"I think you missed driver to install.
Try this npm i neo4j-driver.",0,68088570
2403,https://stackoverflow.com/a/68099735,NestJS / TypeOrm / Neo4j : Nest can&#39;t resolve dependencies of the NEO4J_DRIVER,false,"From my perspective, you&#39;re using wrong method, instead of `forRootAsync` you should use `forRoot` on `Neo4jModule`",0,68099735
2404,https://stackoverflow.com/a/68089062,"Ne04j Graph Nodes, Expand a spanning tree but stop at specific node (but don&#39;t stop for other nodes)",false,"Couldn&#39;t you use a depth search in your case?

    MATCH path = (p:Person {pcode: 123456})-[:RELATIONSHIP_NAME*1..3]-&gt;(terminator:Loaction)  
    WHERE terminator.LocCode = 1   
    RETURN path  ",0,68089062
2405,https://stackoverflow.com/a/68131491,When to use labels and relation types indexing from Neo4j 4.3?,true,"Eventually, I got an answer [on the Neo4j forum][1].

  [1]: https://community.neo4j.com/t/when-to-use-labels-and-relation-types-indexing-from-neo4j-4-3/40187

Essentially, label/type indices are useful for filters on label/types like: WHERE label = x OR label = y.
",0,68131491
2406,https://stackoverflow.com/a/68084608,Return nodes together with relations,true,"If you want to retrieve relationship information, you must request it in your Cypher request.
For example, if you want to retrieve all the nodes with a `friends_with` relationship

`MATCH (a:person)-[r:friends_with]-(b:person) RETURN a,r,b`

Thus you will recover the nodes and the relationships of the people concerned.
Of course, you can adapt this query, depending on whether you want to know only the original node, only have the relation, etc ...

If you want to get ALL the nodes with an `is_friends` relation:

`MATCH (a)-[r:friends_with]-() RETURN a,r`

So you will turn all the node and the relationship too",1,68084608
2407,https://stackoverflow.com/a/68073076,Recommendations for a Graphical DBMS using Aerospike as backend?,true,This is non-trivial but you can leverage work shared by others. Take a look at: https://github.com/Playtika/aerospike-janusgraph-storage-backend ,2,68073076
2408,https://stackoverflow.com/a/68070561,Create &quot;[FOLLOW]&quot; relation between multiple :Users who &quot;[:RATED]&quot; arbitrary :Movies,false,"Let me walk you through creating one relationship, you can mimic it for the rest. Assuming that your nodes with the label User have a name parameter. 

    MATCH (m1:Movie)&lt;-[r1:RATED]-(e:User {name: &#39;elisha&#39;})
    WITH m1,e
    MATCH (m3:Movie)&lt;-[r3:RATED]-(g:User {name: &#39;garfield&#39;})
    WITH m3, g
    .
    .
    CREATE (e)-[:FOLLOW]-&gt;(g)
    CREATE (e)-[:FOLLOW]-&gt;(h)

",0,68070561
2409,https://stackoverflow.com/a/68075360,Find all nodes where property does NOT match condition,false,"Are you trying to run this in a for loop? If so that would explain the behavior: with each iteration you would be firing a query: &quot;delete all nodes exception the one with this specific id&quot;. All it requires is two separate runs on two different ids for it delete everything.

If you have a list of ids and want to delete only nodes without those ids, there&#39;s a better (and correct) way to do this: pass in the list of ids, MATCH to the nodes with those ids and collect them, then MATCH to all nodes that aren&#39;t in that list and delete those:

```
MATCH (node:Node)
WHERE node.nodeId IN $nodeIds // best to have an index on :Node(nodeId), and make sure you&#39;re using the right type between your parameters and the type of the properties
WITH collect(node) as keepNodes
WHERE size(keepNodes) &gt; 0 // to prevent mistakes in the MATCH, which might result in an empty collection, and thus wipe out all your nodes
MATCH (node:Node)
WHERE NOT node IN keepNodes
DETACH DELETE node
```",0,68075360
2410,https://stackoverflow.com/a/68069296,NestJS Neo4j : Cannot find module &#39;neo4j-driver/types/integer&#39; or its corresponding type declarations,false,"You should either downgrade the `neo4j-driver` to 4.1.0 (that&#39;s what `nest-neo4j` 0.1.4 has been tested with) or...
remove `neo4j-driver` entirely from your direct dependencies, since `nest-neo4j` already depends on it. That way, nest-neo4j is always responsible for the driver version it works with, avoiding conflicts like this.",0,68069296
2411,https://stackoverflow.com/a/68057020,Division operator in Neo4j,true,"The default value appears to be integer, so an easy way to fix this is to use `toFloat`:

```
CREATE (n:Person {name: &#39;Andy&#39;, sal: toFloat(1)/2, title: &#39;Developer&#39;})
WITH n
MATCH (n:Person)
RETURN n
```",0,68057020
2412,https://stackoverflow.com/a/68040897,Google colab to neo4j database connectivity error: service unavailable,false,"Yes, well, you can&#39;t connect to localhost from Google Colab, because the localhost for the notebook is completely different than your machine IP. Either expose your localhost outwardly, or create a VM on a cloud, or use a Neo4j Sandbox version, which is already exposed to the internet: https://neo4j.com/sandbox/",1,68040897
2413,https://stackoverflow.com/a/68028469,Loading data slow in NEO4J when adding many node properties,true,"The Eager operator is there to preserve Cypher semantics, but becomes a major headache due to its consequences when processing large data sets, such as with a LOAD CSV. There are planned changes to mitigate this, but that&#39;s for the future.

More info here:
https://community.neo4j.com/t/cypher-sleuthing-the-eager-operator/10730

For workarounds, we can either do some contortions in the query, or more easily, make this into 3 passes: once to MERGE your `from` nodes, once to MERGE your `to` nodes, and a third to MATCH to both and then MERGE the relationship between them.

EDIT:

Thanks to the query plan you provided, we can see that your MERGEs are not backed by an index, that&#39;s why we see NodeByLabelScans in the plan. **Per row**, for each of the two nodes, every single one of the :ipobj nodes is being checked and filtered, and that&#39;s not going to be efficient.

You need an index to make this fast.

What uniquely identifies an :ipobj node? If it&#39;s just the `ip` property then create a unique constraint on that. If it&#39;s a combination of properties, then create a node key constraint, or at least an index on the given properties.

My comments about working around the Eager issue still stand, but you need to support your MATCH and MERGEs (especially when performing loading!) with indexes or constraints to make them efficient.",0,68028469
2414,https://stackoverflow.com/a/68026868,Py2neo (Neo4j) insert / create Relationships in bulk,false,"Py2neo has a bulk API that you might find useful:
https://py2neo.org/2021.1/bulk/index.html",1,68026868
2415,https://stackoverflow.com/a/68015535,import csv file in Neo4j?,false,look at the encoding of your .csv file if it&#39;s `UTF-8` and not `latin1` (`ISO-8859-1`),0,68015535
2416,https://stackoverflow.com/a/68104432,spring data neo4j 6 @Query @Param can&#39;t access 2nd level children,false,"I got this worked with the following SpEL way

https://docs.spring.io/spring-data/neo4j/docs/6.1.1/reference/html/#custom-queries.spel

eg: ```{name: :#{#rel.language.name}}```",0,68104432
2417,https://stackoverflow.com/a/68038520,A very hard Neo4j question to mimic the double for loop?,false,"You have to learn to think differently. Graphs change your world view!

Me, my friend and friend of my friend are all Persons. Thus, you want one node label and 3 nodes linked together. Try this

    create (p1:Person{name:&#39;Me&#39;})
    create (p2:Person{name:&#39;My Friend&#39;})
    create (p3:Person{name:&#39;Friend of my Friend&#39;})
    merge (p1)-[r1:friend]-(p2)
    merge (p2)-[r2:friend]-(p3)

Then

    match p=(a:Person{name:&#39;Me&#39;})-[r:friend*0..5]-&gt;(b:Person) return p


    

",0,68038520
2418,https://stackoverflow.com/a/68010863,How to remove 0xa0 in Neo4j csv data?,false,"\xa0 is actually non-breaking space in Latin1 (ISO 8859-1), also chr(160). You should replace it with a space.

     replace(u&#39;\xa0&#39;, u&#39; &#39;)

Let me know if it works and give me a sample csv file to trst it out.",0,68010863
2419,https://stackoverflow.com/a/67996463,Is there a way to include hyperlinks in nodes in neo4j?,true,"A standard string property would work just fine. It works as a regular hyperlink in the Neo4j browser.

    CREATE (n:Sample {link: &quot;https://google.com&quot;}) RETURN n;",0,67996463
2420,https://stackoverflow.com/a/67999546,spring data neo4j 6 @Query passing list param throws ConverterNotFoundException on converting from List&lt;Pojo&gt; to type [org.neo4j.driver.Value],true,"Thanks for asking this, I think this is just a missing feature: https://github.com/spring-projects/spring-data-neo4j/issues/2292",2,67999546
2421,https://stackoverflow.com/a/68803403,spring data neo4j 6 @Query passing list param throws ConverterNotFoundException on converting from List&lt;Pojo&gt; to type [org.neo4j.driver.Value],false,"The fix [link](https://github.com/spring-projects/spring-data-neo4j/issues/2292) is working in locally build inputs. Thanks [@Michael Simons](https://stackoverflow.com/a/67999546/4527149)

But, if the input is via http payload, then we need Entity level change for **@RequestBody** to get serialized and pass through the SDN.

    @RelationshipProperties
    @Data
    public class KnowsEntity {
    
        @JsonView(Views.Public.class) // it might not be needed
        @Id
        @GeneratedValue
        private Long id;
    
        @JsonView(Views.Public.class)
        @Property
        private Boolean read;
    
        @JsonView(Views.Public.class)
        @Property
        private Boolean write;
    
        @JsonView(Views.Public.class)
        @TargetNode
        private Language language;
    
    }
    
    @Node(primaryLabel = &quot;LANGUAGE&quot;)
    public class Language {
    
        @JsonView(Views.Public.class)
        @Id
        private String name;
    
    }

    public class Views {
        public static class Public {
        }
    }

and in controller get param as 

    @RequestBody @JsonView(Views.Public.class) Set&lt;KnowsEntity&gt; knows",0,68803403
2422,https://stackoverflow.com/a/67986430,How to create a relationship property in graphql type definitions using neo4j-graphql library,false,"**AS OF 15/06/2021**

Relationship properties are not supported by the Neo4j GraphQL Library. We are working on it right now and you can see the RFC for it here https://github.com/neo4j/graphql/pull/193. ",1,67986430
2423,https://stackoverflow.com/a/67983556,Cypher Query returning more edge types than asked for,true,"It seems like you are hitting a Neo4j Browser configuration issue. By default, the browser shows all relationships between the resulting nodes. You can disable this configuration in the &quot;Browser settings tab&quot;:

[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/7liYx.png
",1,67983556
2424,https://stackoverflow.com/a/67992059,Neo4j How to query to all children nodes,true,"Perhaps you are looking for:

```
MATCH (u:UserNode{promoterName:&quot;Antal&quot;})-[:PROMOTER_OF*]-&gt;(c:UserNode)
RETURN c;
```
You can add a number together with the asterisk (e.g. PROMOTER_OF* 3) or a range (e.g. PROMOTER_OF* 1..5). 
If you have a lot of data I do not recommend using a bare asterisk.
",0,67992059
2425,https://stackoverflow.com/a/67977829,Cypher query in a neo4j graph,true,"I would try this:
```
MATCH (:Reader) - [:recommend] -&gt; (b:Book) 
RETURN 
    count(1) AS `Number of Recommendations`, 
    b AS `Book`
ORDER BY `Number of Recommendations` DESC
LIMIT 1
```
I would leave off the `LIMIT` clause until you make sure it&#39;s doing what you want. I don&#39;t have your database, so I can&#39;t test this, but maybe this will work as a first stab at it.",0,67977829
2426,https://stackoverflow.com/a/67973637,neo4j performance issue when filtering nodes,false,"I would go with this:
```
MATCH (a)-[*]-&gt;(b)-[*]-&gt;(c)
```
This allows any number of nodes between `a` and `b` and between `b` and `c`. Depending on the number of nodes you have, this might not be very performant. In that case, I would work with indices (which are cheap in Neo4j) to speed things up, and perhaps even script your Cypher query using Python and dynamic string replacement. ",0,67973637
2427,https://stackoverflow.com/a/67952807,GraphQL Apollo types generation on React Native,false,"
After many hours, I fixed this issue by using the following config:
```
module.exports = {
  client: {
    includes: [&#39;graphql/**/*.ts&#39;],
  },
};
```

My guess is that apollo-cli found some `gql` tags in all the React Native generated code.

P.S. I tried to use specific keywords so that Google will show this result to people that have the same issue and are stuck.",0,67952807
2428,https://stackoverflow.com/a/67948329,How to optimize and improve neo4j cypher query with multiple match and an increase number of where clauses,false,"Assuming that you provide a collection of :Food nodes in an array, you could do 

    MATCH (f:Food)--(r:Restaurant)-[:LOCATED_IN]-(c1:City{name:&#39;London&#39;}) 
    WHERE f IN $foodNodes
    RETURN r.name as restaurant, COLLECT(DISTINCT f.name) AS foods

to retrieve the restaurants and their foods.",0,67948329
2429,https://stackoverflow.com/a/67936560,Using GDS to make a neo4j undirected graph,false,"Yes, that is possible, there is a type parameter where you can input the wildcard option:


    CALL gds.graph.create(&#39;myGraph3&#39;, 
       &#39;*&#39;, 
       {ALL: {orientation: &#39;UNDIRECTED&#39;, type:&#39;*&#39;}})
",0,67936560
2430,https://stackoverflow.com/a/67929551,Neo4j Aura and uuid issue,false,"Thanks for being my rubber ducks.

This is the diff that made it work:

    +      WITH oldDp, oldDp.id AS oldId, sr, q
           DETACH DELETE oldDp
    -      MERGE (sr)-[:HAS_DATA_POINT]-&gt;(dp:DataPoint {id: coalesce(oldDp.id, apoc.create.uuid())})-[:FOR_QUESTION]-&gt;(q)
    +      MERGE (sr)-[:HAS_DATA_POINT]-&gt;(dp:DataPoint {id: coalesce(oldId, apoc.create.uuid())})-[:FOR_QUESTION]-&gt;(q)


I&#39;m sure there&#39;s a ton of optimizations to be done, but this is good enough for now and it works. Still no idea why aura just behaves so different at times.",1,67929551
2431,https://stackoverflow.com/a/67922794,Sum values from relationships list in Neo4j,true,"You can try [REDUCE][1]

`return reduce(total = 0, r IN relationships(p) | total + r.amount) AS total`


  [1]: https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-reduce",0,67922794
2432,https://stackoverflow.com/a/67920769,Connect Spring Boot 2.4.x to neo4j-3.4.x,false,"Neo4j 3.4 is not maintained anymore, upgrade at least to 3.5: https://neo4j.com/developer/kb/neo4j-supported-versions/",0,67920769
2433,https://stackoverflow.com/a/67924052,spring data neo4j 6.1.1 Repository Relationship primary_id not allowing to use UUID String where as for Node Primary_id UUID String is working,true,"You cannot access relationship properties directly via repositories.
Those classes are just an encapsulation for properties on relationships and are not meant to represent a &quot;physical&quot; relationship or more a relationship entity.
Repositories are for `@Node` annotated classes solely.

If you want to access and modify the properties of a relationship, you have to fetch the relationship defining entity.
A relationship on its own is always represented by its start and end node.

The lately introduced required `@Id` is for internal purposes only.
If you have a special need to persist an id-like property on the relationship, it would be just another property in the `@RelationshipProperties` annotated class.",1,67924052
2434,https://stackoverflow.com/a/68262290,How to convert a record or list into JSON format using python?,false,"You can get the `result.data()` which is a dictionary.

You can also iterate over the records in the cursor and convert one by one, and extract the fields you want, which is what the [linked example][1] above does - pass the cursor and use the `blob[&#39;field&#39;]` syntax

```python
def serialize_genre(genre):
    return {
        &#39;id&#39;: genre[&#39;id&#39;],
        &#39;name&#39;: genre[&#39;name&#39;],
    }
```


  [1]: https://neo4j.com/developer/python-movie-app/#_whats_going_on_with_the_serializer",0,68262290
2435,https://stackoverflow.com/a/67912415,Neo4j: Applying index and constraint changes query results,true,"Yes, this is a good illustration of a bug that was fixed in Neo4j 4.2.3, and happens when the label is present in an OPTIONAL MATCH on a previously-bound variable.

From the changelog:

&gt; Fixed a bug where an index scan would be used to solve an OPTIONAL MATCH incorrectly.

https://github.com/neo4j/neo4j/wiki/Neo4j-4.2-changelog#423

The workaround until the fix was to remove the redundant label.

We highly recommend staying updated to at least the latest patch for your minor version to avoid known and fixed bugs.",1,67912415
2436,https://stackoverflow.com/a/68184449,Exception when writing transactions in Neo4j python driver: &quot;neo4j.exceptions.AuthError: {code: None} {message: None}&quot;,false,"I recently experienced this error, and the cause ended up being an issue with my username/password. I had them wrong in the config file I was referencing. It was confusing because the error didn&#39;t appear until the row where I call the `.run()` method, even though I establish the session earlier in the code.",1,68184449
2437,https://stackoverflow.com/a/69147085,Exception when writing transactions in Neo4j python driver: &quot;neo4j.exceptions.AuthError: {code: None} {message: None}&quot;,true,"Below is a partial answer — it will work to set your password initially, but you may be unable to change it.

- To set the password initially from the command line, run `sudo /usr/bin/neo4j-admin set-initial-password YOUR_PASSWORD_HERE`.
- Alternatively, you can run a curl request against the neo4j server as described [here](https://stackoverflow.com/a/32151519/1467342).
- If you&#39;ve already set your password, you may need to remove the auth.ini file (more on that [here](https://stackoverflow.com/questions/27645951/how-to-configure-user-and-password-for-neo4j-cluster-without-rest-api/32151519#32151519)).
- Restart the server using `sudo neo4j restart` so it will accept your new password. On debian, if you don&#39;t use sudo, it will just time out.

Personally, I was able to set my password, but am now unable to change it. I&#39;m not sure if this is a bug, but both the command line and curl reset approaches are reporting success without changing the password, even after a restart. ",1,69147085
2438,https://stackoverflow.com/a/67911900,How to find all maximal cliques in Neo4J?,false,"&gt; Any other way to approach this?

I would write my own code.  Since I prefer C++ I came up with this:

    void cPathFinder::cliques()
    {
        // working copy on input graph
        auto work = myGraph;
    
        // store for maximal clique collection
        std::vector&lt;std::vector&lt;int&gt;&gt; vclique;
    
        while (1)
        {
            std::vector&lt;int&gt; clique;
    
            while (work.nodeCount())
            {
                if (!clique.size())
                {
                    // start by moving an arbitrary node to the clique from the work graph
                    auto nit = work.nodes().begin();
                    clique.push_back(nit-&gt;first);
                    work.removeNode(nit-&gt;first);
                    continue;
                }
                bool found = false;
    
                // loop over nodes remaining in work graph
                for (auto &amp;u : work.nodes())
                {
                    // loop over nodes in clique
                    for (int v : clique)
                    {
                        if (work.includes_link(v, u.first) ||
                            work.includes_link(u.first, v))
                        {
                            // found node in work that is connected to clique nodes.
                            // move it to clique
                            clique.push_back(u.first);
                            work.removeNode(u.first);
                            found = true;
                            break;
                        }
                    }
                    if (found)
                        break;  // found a node to add to clique
                }
                if (!found)
                    break;      // no more nodes can be added, the clique is maximal
            }
    
            if (!clique.size())
                break;          // did not find a clique
    
            // add to collection of maximal cliques
            vclique.push_back(clique);
        }
    
        // Display results
        for (auto &amp;c : vclique)
        {
            std::cout &lt;&lt; &quot;clique: &quot;;
            for (int n : c)
                std::cout &lt;&lt; myGraph.name(n) &lt;&lt; &quot; &quot;;
            std::cout &lt;&lt; &quot;\n&quot;;
        }
    }

For this input

    l 1 5
    l 1 3
    l 2 8
    l 2 6
    l 3 1
    l 3 7
    l 4 8
    l 4 6
    l 5 1
    l 5 7
    l 6 4
    l 6 2
    l 7 3
    l 7 5
    l 8 2
    l 8 2

I get this output

clique: 5 1 3 7
clique: 8 2 6 4

To check this, here is what graphViz produces with the same input

[![enter image description here][1]][1]

You can find the complete code [here][2].


  [1]: https://i.stack.imgur.com/PLrbK.png
  [2]: https://github.com/JamesBremner/PathFinder2",0,67911900
2439,https://stackoverflow.com/a/67880125,Neo4j Update node with aggregated count,true,"I was looking through similar questions and although i didn&#39;t find the precise use of aggregates in setting data I did manage to reverse engineer an example into this:

    MATCH (n:node)-[]-&gt;()
    WITH n, count(*) as c
    SET n.data = c

Which appears to work!",0,67880125
2500,https://stackoverflow.com/a/67879403,Create 2 relationships with one match query?,true,"Yes, and we would encourage the second approach since it&#39;s more concise (you usually don&#39;t need to re-MATCH to nodes that are already in scope).

You&#39;re likely getting a syntax error, though, so either use one CREATE with comma-separated patterns, or two CREATEs without any comma between them.

Like so:

    MATCH (a:link)
      MATCH (b:node {id:a.us_node_id})
        CREATE (b)-[:ds_link]-&gt;(a),
               (a)-[:us_node]-&gt;(b)",1,67879403
2501,https://stackoverflow.com/a/67878319,neo4j two fulltext searches in one subquery,true,"We can use the results of the first search to boost the score of the second, based on which movie node the actor node acted in.

You haven&#39;t told us what you want to do with the scores mathematically, so for this example I&#39;ll just add them. 

```
CALL db.index.fulltext.queryNodes(&#39;movie_search&#39;, &#39;Matrix&#39;)
YIELD score, node as movie
WITH collect([movie, score]) as movieScores

CALL db.index.fulltext.queryNodes(&#39;actor search&#39;, &#39;Fish&#39;)
YIELD score, node as actor
MATCH (actor)-[:ACTED_IN]-&gt;(movie:Movie)
WITH score, actor, movie, coalesce([pair IN movieScores WHERE pair[0] = movie | pair[1]][0], 0) as movieScore
RETURN movie.title as movie, actor.name as actor, score + movieScore as totalScore
ORDER BY totalScore DESC
```

What we&#39;re doing is collecting the movies and their scores into a list that we can cross reference later. After we get the actor node we find all movies they acted in, and for each row find the movie/score pair for that movie (using coalesce() to use a default of 0 if none was found), then we add the scores and sort them.",0,67878319
2502,https://stackoverflow.com/a/67853544,How can I upload database data to Neo4j?,false,"So, copy the database content to the neo4j data folder. Once you have that, open the neo4j.conf file and set the following configuration:

    dbms.default_database=chloroplast_DB

I am not exactly sure that is the database name, use the same name as is the database folder and then start the database.",0,67853544
2503,https://stackoverflow.com/a/67843771,Embedded Neo4j with Graph Data Science - BFS Procedure appears to be missing,true,"The required procedure is conveniently called &quot;TraverseProc&quot; and allows use of both BFS and DFS.

The file doesn&#39;t include the name of the callable, either. Discovered it through search of all my neo4j dependencies with 

    find . -name &quot;*.jar&quot; -exec zipgrep &quot;gds.alpha&quot; &#39;{}&#39; \;
(from https://stackoverflow.com/questions/10331025/how-to-search-for-a-string-in-jar-files)",0,67843771
2504,https://stackoverflow.com/a/67842446,Do not return set of nodes from a specific path in Cypher,false,"I would suggest it would be best to check if the nodes are in a list, and to prove out the approach, start with a very simple example. 

Here is a simple cypher showing one way to do it.  This approach can then be extended into the complex query, 

    // get first two product IDs as a list
    MATCH (p:Product)
    WITH p LIMIT 2
    WITH COLLECT(ID(p)) as list
    RETURN list
    
    // now show two more product IDs which not in that list
    MATCH (p:Product)
    WITH p LIMIT 2
    WITH COLLECT(ID(p)) as list
    MATCH (p2:Product)
    WHERE NOT ID(p2) in list
    RETURN ID(p2) LIMIT 2

Note: I&#39;m using the ID() of the nodes instead of the entire node, same dbhits but may be more performant...",0,67842446
2505,https://stackoverflow.com/a/67869260,Failed after retried for 6 times in 30000 ms when accessing API with neo4j database,false,"There&#39;s no real coding answer here, the only thing that sticks out to me is a lack of `await` before the `neo4jClient.ConnectAsync()` call.

Other than that, you&#39;d need to check the connection, network etc. If it&#39;s local - then I&#39;m not sure - I guess you can try/catch this - but that&#39;s kind of what has happened under the hood.

",0,67869260
2506,https://stackoverflow.com/a/67827450,Correct use of UNWIND and COLLECT,true,"So the part you&#39;re missing is how grouping keys work in aggregations. The non-aggregation terms act as the grouping key, providing context for the rows that will be emitted, and for what rows the aggregations are being applied.

Your collect() aggregation has no other terms, so there is no grouping key, and you end up with a single list.

If you want the collect() to apply per session_id, then you need to include the session_id as a non-aggregation term so it can act as a grouping key for the aggregation:

```
...
unwind session_ids as session_id
MATCH (property:Product)&lt;-[contains:CONTAINS]-(target:Session {session_id: session_id})
with session_id, collect(distinct id(property)) as vector
return vector
```

That will mean that per session_id, you collect the distinct ids of the product nodes for each session.

You can leave out the session_id in the RETURN if you want. The rows are already constructed in the state you want from the aggregation you performed in the WITH clause, so even if you omit the session_id, you will still have 2 rows of results, with a vector for one session on one row, and a vector for the other session on the next row.",1,67827450
2507,https://stackoverflow.com/a/67832848,SCP : Failed to download a file from a VM in Azure,false,"A error like that suggests (as in [this thread][1]) that something (policy, firewall) is blocking SSH inbound traffic.

Outgoing SSH seems allows, since an `ssh azureuser@ip_vm` is working.


  [1]: https://www.linode.com/community/questions/19682/unable-to-ssh-from-private-ip",0,67832848
2508,https://stackoverflow.com/a/67825556,How can I create two node types from one csv in neo4j?,false,"The answer is:

LOAD CSV WITH HEADERS FROM &#39;csvFilePath&#39; as row MERGE(people: People {name:row.name}) MERGE(address:Address {name:row.address})
MERGE (people)-[r:WENT_TO]-&gt;(address) RETURN people,address;",0,67825556
2509,https://stackoverflow.com/a/67827569,Speed up Neo4j relationship creation,false,"Do you have an index on :Node(node_id)? You NEED this for your MATCH operations to be performant.

https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/",1,67827569
2510,https://stackoverflow.com/a/67810788,How to make relationships between already created nodes of different columns from a single csv file?,true,"You can ignore the cartesian product warning, since that exact approach is needed in order to create the relationships that form the patterns you need.

As for the multiple relationships, it&#39;s possible you may have run the query twice. The second run would have created the duplicate relationships. You could use MERGE instead of CREATE for the relationships, that would ensure that there would be no duplicates.",0,67810788
2511,https://stackoverflow.com/a/67810940,Is there a definite answer for the performance of 1st level depth query search in Neo4j (or any other graph db) vs. SQL/NoSQL?,false,"A depth of 1 shouldn&#39;t result in much difference in performance, I&#39;d think. However, that does depend on two factors: the indexes you&#39;ve set up, and the depth of expansion.

For both Neo4j and your relational db, you would want a supporting index on the starting node in the graph (the person or post whose likes/views you want to get). For the relational db, you would also want an index to support the join operation being used to get at the connected nodes.

For Neo4j, the expansion to the connected nodes is directly proportional to the number of nodes you are expanding to, since this is just pointer chasing between the nodes and relationships forming your graph. No indexes are used for that.

For a relational database, the relationship would likely be modeled as a table join (which should be index-backed), and that cost will be proportional to the size of the tables being joined, so as more data is added to the graph (no matter of whether it is connected to the user who you are querying for), it will be impacting your execution time.

Thankfully for your case only a single table join would be needed. You may not see a big difference between a graph db and a relational db. Neo4j tends to shine when many (possibly an unbounded number) of traversals are needed, like the friend-of-a-friend queries or those with longer patterns. If your use cases include longer patterns, especially if the types of the node expanded to are not known ahead of time, then Neo4j would be very helpful, especially as the data in your database grows, since traversal performance is proportional only to the directly connected data, not the total number of nodes of the given labels.",0,67810940
2512,https://stackoverflow.com/a/67810988,How can I limit the number of changes that can be changed with a set in Cypher?,true,"LIMIT can only be applied to WITH or RETURN. In this case, you need a WITH clause to apply the LIMIT before you SET.

    MATCH (c:Persona)
    WHERE NOT (c)-[:JUEGA_A]-&gt;(d:Deporte{name:&#39;tenis&#39;}) 
    WITH c
    LIMIT 5
    SET c:Model_Data, c.es_tenista=0;",1,67810988
2513,https://stackoverflow.com/a/67796720,create relationship between existing nodes in Py4neo,false,"I figured out, For the people that want to try this implementation and is using py2neo V4, try using graph.run()

    for tupla in genes2:
        graph.run(&quot;MATCH(a:GEN{name:$name}) MATCH(b:GEN{name:$name1}) CREATE (a)-[:REGULATES]-&gt;(b)&quot;,name=tupla[0],name1=tupla[1])

remember that the query has to be in the first argument and then you declare the $`variables` separated by &quot;,&quot;
at less this works when you have already created the nodes and does not duplicate the existing ones.",0,67796720
2514,https://stackoverflow.com/a/67798883,Get all Nodes and Relationships with Propperties outgoing from one StartNode,false,"I found an APOC function which currently does what I want to. 
Get All nodes after the searched one, and give the complete subgroup with relationships back. 
Looks currently good. 
Any suggestion how to store this data back in data models in C#? (whats best way?) 

     var result = tx.Run($@&quot;MATCH (p:WiringDiagram {{wiringid:1}})
                            CALL apoc.path.subgraphAll(p, {{
                                 relationshipFilter: 
                                 &quot;&quot;partOf|has_pin|connectedWith&quot;&quot;,
                                 filterStartNode:false,
    	                         minLevel: 0,
                                 maxLevel: 10
                                }})
                              YIELD nodes, relationships
                             RETURN nodes, relationships;&quot;);

And after that I&#39;ve got two lists, one with all the nodes, and one with all relationships with start/endnode id

[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/aDFy9.png",0,67798883
2515,https://stackoverflow.com/a/67789294,neo4j can&#39;t see database from terminal,false,"From the Neo4j desktop, you&#39;ll see the Start/Stop and Open buttons for a project database. Just to the right of these are 3-dots. Click on that and then open folder. This will get you to the various folders for the database. It&#39;s useful for seeing the size of the database, working with the config file, managing transaction logs, etc. ",0,67789294
2516,https://stackoverflow.com/a/67776839,What is difference between ANY and IN clause in Neo4j?,false,"In your simple example case the results are the same.

However `any()` allows more complex means of filtering, especially when we aren&#39;t using this to simply detect membership of a known value in a list:

    MATCH (n:Person) 
    WHERE any(color in n.liked_colors WHERE (n)&lt;-[:KNOWS|MARRIED*]-(other:Person {eyes:color}))

Find a person where for any of their liked colors, we can traverse the given pattern to find another person with eyes of that color.",0,67776839
2517,https://stackoverflow.com/a/67789579,How to unit-test code depending on a complex graph database interaction,false,"You could have separate Python functions for connecting to the database, querying it and processing the return. For the latter the Python pandas package has a nice capability. use this, where Q is your cypher query and Neo4jServer might be remote or local as in Neo4Server =&quot;bolt://{IP or localhost}:7687&quot;. If you&#39;re using Neo4j 4.x, you need to specify the specific database.

    from neo4j import GraphDatabase
    from pandas import DataFrame
    
    def CypherToPandas(Q, database):
        driver=GraphDatabase.driver(Neo4Server, auth=(Neo4UserName,Neo4Pswd),database=database ) 
        with driver.session(database=database) as cyphersession:
            rslt = cyphersession.run(Q)
            df = DataFrame(rslt.data())
            cyphersession.close()
            driver.close()
            return df

I have a variety of functions that can be repurposed for a variety of uses. The Neo4j code is separate from the business logic. You can then run the unit tests and, when tested, seamlessly incorporate them into your solution.

",1,67789579
2518,https://stackoverflow.com/a/67774467,Neo4j query without specifying relation type,true,"You can check the equality of the relationships in the `WHERE` clause. 

    MATCH path=(a)-[r]-&gt;(b)-[r2]-&gt;(c) 
    WHERE type(r)=type(r2)  
    RETURN path


*P.S.: If you are viewing this result in the Neo4j browser, then it &quot;connects the result nodes&quot; which means it adds extra relationships between nodes that don’t match the criteria. Don’t forget to uncheck the **&quot;connect result nodes&quot;** option in the from the settings.*",3,67774467
2519,https://stackoverflow.com/a/67831759,@Transactional in Spring Data Neo4j 6,true,"The method needs to have a _public_ visibility. Otherwise Spring cannot create the needed infrastructure around this (proxy related).

There is a little bit more information around this in the documentation https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction-declarative-annotations
A few lines under the linked section there is a box

&gt; When you use proxies, you should apply the @Transactional annotation
&gt; only to methods with public visibility. If you do annotate protected,
&gt; private or package-visible methods with the @Transactional annotation,
&gt; no error is raised, but the annotated method does not exhibit the
&gt; configured transactional settings. If you need to annotate non-public
&gt; methods, consider using AspectJ (described later).

",1,67831759
2520,https://stackoverflow.com/a/67809523,How to use node_modules in Deno as typescript imports?,false,"If you look at the Node compatibility layer README in std you will realize that right now there is no compatibility module for the net library. The compatibility will improve day by day, but take into account that Deno is not a drop in replacement for Node, but a whole new thing that won&#39;t work with Node libraries by default

https://deno.land/std@0.97.0/node",1,67809523
2521,https://stackoverflow.com/a/67774002,Neo4j Liquigraph datasource - expected single matching bean but found 2,true,"I reconfigured Liquigraph with the following:

    @Bean
    @ConfigurationProperties(
            prefix = &quot;liquigraph&quot;,
            ignoreUnknownFields = false
    )
    public LiquigraphProperties liquigraphProperties() {
        return new LiquigraphProperties();
    }
    
    @Bean
    public SpringLiquigraph liquigraph(ResourceLoader loader, LiquigraphProperties properties) {
        String jdbcServerDatabaseUri = properties.getUrl();
    
        final HikariConfig config = new HikariConfig();
        config.setJdbcUrl(jdbcServerDatabaseUri);
        config.setUsername(properties.getUser());
        config.setPassword(properties.getPassword());
        DataSource dataSource = new HikariDataSource(config);
    
        SpringChangelogLoader changelogLoader = new SpringChangelogLoader(loader);
        return new SpringLiquigraph(dataSource, changelogLoader, properties.getChangeLog(), properties.getExecutionContexts());
    }",0,67774002
2522,https://stackoverflow.com/a/67749900,Use NestJS framework and Neo4j,true,"I think you are missing or installed the latest `neo4j-driver`, you will need to install 4.2.3 or below to make `nest-neo4j` works.

```
npm install neo4j-driver@4.2.3
// or
yarn add neo4j-driver@4.2.3
```

For a full example, you can follow this: https://github.com/neo4j-examples/nestjs-neo4j-realworld-example

To use nestjs, you need to integrate neo4j with the framework so that it can be injected in your services. I don&#39;t think there is an easy way to use neo4j with nestjs unless you don&#39;t need the injection.",0,67749900
2523,https://stackoverflow.com/a/67807940,Related to neo4j and csv files,true,"After a long conversation, I cannot leave this thread without an answer.

    allery.csv:
    START,Patient_id,DESCRIPTION
    01/05/1982,1d604da9-9a81-4ba9-80c2-de3375d59b40,Latex allergy
    10/25/1982,034e9e3b-2def-4559-bb2a-7850888ae060,Shellfish allergy
    10/25/1982,034e9e3b-2def-4559-bb2a-7850888ae060,Pollen allergy


    LOAD CSV WITH HEADERS FROM &quot;file:///allergy.csv&quot; as row
    CREATE (a: allergy {name: row.DESCRIPTION, id:row.Patient_id}) 
    WITH row, a
    MERGE (p:patient {id: row.Patient_id})
    WITH p, a
    MERGE (p)- [:has_alleries] -&gt; (al:allergy) 
    WITH al, a
    MERGE (al) &lt;- [:allergy] - (a);

COMMENTS to your teacher:

1) the allergy node between allergy and patient is not needed. You can go from allergy to patient directly.
2) the relationship type &quot;allergy&quot; is the same with a node &quot;allergy&quot;. You can use a different label say, latex allergy - :of_type  -&gt; allergy.
3) allergy node id is the same with same with patient id. It is not appropriate.

RESULT:
[![enter image description here][1]][1]



  [1]: https://i.stack.imgur.com/pnoLe.png",0,67807940
2524,https://stackoverflow.com/a/67741367,Neo4j apoc will not export,false,"So it turns out the plugins was duplicated and also I needed the whitelist:

	dbms.security.procedures.unrestricted=apoc.*
	dbms.security.procedures.whitelist=*
	apoc.import.file.enabled=true
	apoc.export.file.enabled=true

Along with this, I set `dbms.directories.import=/` which then allowed me to export along with creating the graph.xml file and setting permissions on it *before* neo4j could write to it.

If in doubt - pray about it! God always answers.",0,67741367
2525,https://stackoverflow.com/a/67755292,"Find most suitable nodes from a starting node, start and end nodes are indirectly connected and edges are weighted",false,"&gt; A perfect match would be when the green node connects to all blue
&gt; nodes the violet one connects to.

I ***think*** that this means there is a path from a green node to a violet one that passes through just one blue node.  If there is more than one violet node that is just one blue node away from a green node, then you want all such vilet nodes.  Please confirm this.

If my guess about your requirement is correct, then the Dijsktra algoritm will give your answer.  The algorithm will tell you how far away every violet node is from each green node - so you can filter out the ones that are exactly two hops away.

Do you have a sample dataset?",1,67755292
2526,https://stackoverflow.com/a/67739730,Neo4j Browser Crash grey screen,true,"You need an index on :Doss(Num) or this won&#39;t be able to finish in a reasonable amount of time.

The key is that most Cypher operations execute per row. So the second MATCH is being executed per each result from the first MATCH. 

If you don&#39;t have an index, then this will likely be doing a NodeByLabelScan for `a`, and then another NodeByLabelScan **per `a` node** and filtering to find matches for `b`.

Basically, you will be performing a total of 6M + 1 label scans, and filtering across 6M * 6M rows, and that&#39;s just not a good idea.

If you add the index, then you will be doing only one NodeByLabelScan, and then 6M index seeks to find, per row, all `b` nodes with the same num as `a`.

You should be able to run an EXPLAIN on the query to confirm how the planner wants to execute this.",0,67739730
2527,https://stackoverflow.com/a/67728906,GraphQL sorting of queries broken on Neo4j Aura,true,"Yes, a problem with a buggy APOC jar in the latest Aura push. I believe all apoc.coll functions and procs may be affected.

It&#39;s being worked on, you can monitor status here:

https://status.neo4j.io/",2,67728906
2528,https://stackoverflow.com/a/68413771,The is no procedure with the name &#39;gds.alpha.ml.nodeClassification.train&#39;,false,The node classification algorithm (as well as the link prediction algorithm) was provided in GDS version 1.5.  v1.4 still had the other beta algorithms that you are likely referring to.  So you will need to upgrade to that in order to make node classification work.,0,68413771
2529,https://stackoverflow.com/a/67711127,Cypher init script Neo4j 4.2 docker not working,false,"Well this behavior works only when you create a separate apoc.conf file and place it beside neo4j.conf

my apoc.conf now looks like this:

    apoc.initializer.neo4j.1=CALL apoc.cypher.runSchemaFile(&quot;file:////var/lib/neo4j/db_init_scripts/db_ddls.cypher&quot;)
    apoc.initializer.neo4j.2=CALL apoc.cypher.runFile(&quot;file:////var/lib/neo4j/db_init_scripts/db_schema.cypher&quot;);

And log files have outputs:

    2021-05-26 18:51:06.068+0000 INFO  [neo4j/c0fb7489] successfully initialized: CALL apoc.cypher.runSchemaFile(&quot;file:////var/lib/neo4j/db_init_scripts/db_ddls.cypher&quot;)
    2021-05-26 18:51:06.882+0000 INFO  Remote interface available at http://localhost:7474/
    2021-05-26 18:51:06.892+0000 INFO  Started.
    2021-05-26 18:51:08.091+0000 INFO  [neo4j/c0fb7489] successfully initialized: CALL apoc.cypher.runFile(&quot;file:////var/lib/neo4j/db_init_scripts/db_schema.cypher&quot;);

",0,67711127
2530,https://stackoverflow.com/a/67702695,Creating node and set ID for it without duplicating field,true,"The two values you see are
  * the internal node identifier `id(n)` of Neo4j, here `12` and
  * an attribute `n.id`, here `1111`.

You can access them both from Cypher unsing the syntax shown above,
`MATCH (n:Entry) RETURN id(n), n.id` yields:

| `id(n)` | `n.id` |
| -------- | -------------- |
| `12`    | `1111`            |

You cannot change the internal ID from Cypher, it is assigned when the node is created by the system. The only way I know to control which node gets which internal ID (you should never have to do this, rethink your software design!) is using the [Neo4j Admin Import](https://neo4j.com/docs/operations-manual/current/tools/neo4j-admin-import/) tool with the `--id-type=ACTUAL` option. This only works for nodes that are batch-imported into a previously empty database however.",4,67702695
2531,https://stackoverflow.com/a/67710076,neo4j matching two different relationships and retrieving count while avoiding cartesian product,true,"The reason why you get multiple/duplicate actors is because the same movie is being reviewed by more than one person (reviewers).  To remove duplicates, you can use the keyword &quot;DISTINCT&quot;.

    MATCH (a:Person)-[r2:REVIEWED]-&gt;(movie:Movie)&lt;-[r:ACTED_IN]-(actors:Person) 
    RETURN movie.title as Movie_name, count(distinct actors) as no_of_cast 
    ORDER BY no_of_cast DESC

Result:

    ╒═══════════════════╤════════════╕
    │&quot;Movie_name&quot;       │&quot;no_of_cast&quot;│
    ╞═══════════════════╪════════════╡
    │&quot;The Replacements&quot; │4           │
    ├───────────────────┼────────────┤
    │&quot;Cloud Atlas&quot;      │4           │
    ├───────────────────┼────────────┤
    │&quot;The Da Vinci Code&quot;│4           │
    ├───────────────────┼────────────┤
    │&quot;The Birdcage&quot;     │3           │
    ├───────────────────┼────────────┤
    │&quot;Unforgiven&quot;       │3           │
    └───────────────────┴────────────┘",0,67710076
2532,https://stackoverflow.com/a/67710700,neo4j matching two different relationships and retrieving count while avoiding cartesian product,false,"You have some other options for improvement.

You don&#39;t really want paths that include the reviewer, that&#39;s what causing a cross product (reviewer rows x actor rows). Instead, this is a condition, that the only movies you are interested in are those where someone has reviewed it. You can move that part of the pattern to the WHERE clause instead:

    MATCH (movie:Movie)
    WHERE ()-[:REVIEWED]-&gt;(movie)
    WITH movie, size((movie)&lt;-[:ACTED_IN]-()) as no_of_cast 
    ORDER BY no_of_cast DESC
    LIMIT 1
    RETURN movie.title as Movie_name, no_of_cast

Note also that instead of doing an aggregation, we&#39;re getting the degree of the :ACTED_IN relationship on the node for the number of cast using size(). This is more efficient, since we don&#39;t need to perform any expansions or aggregations to get this value.

Also we&#39;re waiting until after we&#39;ve gotten our single top result to project that title property. Property access can be expensive, so it&#39;s best to defer it until you have your minimal result set.",0,67710700
2533,https://stackoverflow.com/a/67693667,Toggle relationship in Neo4J,true,"The queries (last two arguments) to `apoc.do.when()` have to be strings, so quote each of them.

Also, in order for each of those queries to use those variables, you need to pass those variables in a parameter map as a 4th argument.

Each of the conditional queries must RETURN something, otherwise there will be no rows yielded and anything after would be a no-op.

The call must `YIELD value`, so that needs to be present, and last, a query cannot end with a procedure call, so you need to RETURN something.

This one should work, you can adjust it as needed:

    MATCH (me:User), (other:User) 
      WHERE ID(me) = $me AND ID(other) = $other 
    OPTIONAL MATCH (me)-[af:FOLLOWS]-&gt;(other) 
    CALL 
      apoc.do.when(
        af IS NULL, 
        &quot;CREATE (me)-[f:FOLLOWS]-&gt;(other) RETURN f&quot;, 
        &quot;DELETE af RETURN null as f&quot;,
        {me:me, af:af}
      ) YIELD value
    RETURN value.f as f",1,67693667
2534,https://stackoverflow.com/a/67691165,Neo4j Timetree query,true,"The easiest way would actually be to avoid the timetree entirely, set the relevant activityAt date property on :Session nodes, create an index on it, then use Cypher to query it leveraging the index.

    MATCH (s:Session)
    WHERE date(&quot;2021-05-20&quot;) &lt;= s.activityAt &lt;= date(&quot;2021-05-28&quot;)
    RETURN s

Timetrees were much more useful before temporal properties and temporal index lookups were introduced in Neo4j 3.4.x. ",0,67691165
2535,https://stackoverflow.com/a/67772082,Combine multiple lists into a single list and output it for each row,true,"Maybe, you could unwind the `names` list at the end to turn the names into individual rows. When doing so, you need to pass `names` to each `WITH` clause.

```sql
WITH [&#39;Keanu Reeves&#39;, &#39;Hugo Weaving&#39;, &#39;Emil Eifrem&#39;] as names
MATCH (p:Person)-[:ACTED_IN]-&gt;(m:Movie)
WHERE p.name in names
WITH names, p, collect(m) as moviesPerActor
WITH names, collect(moviesPerActor) as movies
WITH names, reduce(commonMovies = head(movies), movie in tail(movies) |
 apoc.coll.intersection(commonMovies, movie)) as commonMovies
UNWIND names as name
RETURN name, commonMovies
```",1,67772082
2536,https://stackoverflow.com/a/67687505,connect with service running on host from docker container,false,"you need to use the container service name **neo4j** and default port **7687** to use inside the same docker host.

&gt; bolt://neo4j:7687



    version: &quot;3.8&quot;
    services:
    	neo4j:
    		image: neo4j:3.4.4-enterprise
    		ports:
    			- 7474:7474
    			- 7687:7687
    	my_service:
    		build:
    		  context: .
    		environment:
    		  DATABASE_URL: &quot;bolt://neo4j:7687&quot;",-1,67687505
2537,https://stackoverflow.com/a/68023578,In Neo4j find path from root to a node in a tree,false,"If you import an ontology with neosemantics using the basic settings, you can get the path(s) between a class and it&#39;s parents all the way to the root with the following query. (I&#39;ve imported the ESCO ontology):

    MATCH path = (c:n4sch__Class)-[:n4sch__SCO*]-&gt;(root:n4sch__Class) //(1)
    WHERE c.uri = &quot;http://data.europa.eu/esco/skill/74ce6ebc-8886-437e-bee9-ce5735aaa020&quot;   // (2)
        AND not (root)-[:n4sch__SCO]-&gt;() //(3)
    RETURN path //(4)

 - in (1) we define the exploration pattern: follow SCO relationships all the way. That&#39;s what the asterisk means. 
 - in (2) we specify the starting class by its uri (
   although you could use a label or any other property) 
 - in (3) we
   specify that the root is a root because it&#39;s not the child of any
   other class
 - in (4) we return the whole path. Great for visualisation in the browser [like this one][1]. But if you want to return just a property of the nodes (say for instance the skos:prefLabel) in the path you can use this fragment instead: `RETURN [n in nodes(path) | n.skos__prefLabel]`

 


  [1]: https://i.stack.imgur.com/BFLMS.png",1,68023578
2538,https://stackoverflow.com/a/67691351,Unable to Enable Neo4j spatial extention,false,Its Worked for neo4j 3.4.15 version.,0,67691351
2539,https://stackoverflow.com/a/67674421,Neo4j query WHERE IN a extremely long list,false,"Create an index if not yet existing then use UNWIND which is like a &#39;for loop&#39;.

    1. CREATE INDEX index_name IF NOT EXISTS FOR (n:Foo) ON (n.value)

    2. Run below query
    
       WITH [&#39;value0&#39;, &#39;value1&#39;,...&#39;value9999&#39;] as L
       UNWIND L as inputValue
       MATCH (n)-[r]-&gt;(m) WHERE n.value = inputValue
       RETURN n.id, m.id

",1,67674421
2540,https://stackoverflow.com/a/67740081,Neo4j Docker: Please see the attached cause exception &quot;/var/lib/neo4j/certificates/neo4j.cert (No such file or directory)&quot;,false,"This happens when you have not fix version of your docker image.

If you have somethin like that:
```
docker run \
    --name testneo4j \
    -p7474:7474 -p7687:7687 \
    -d \
    -v $HOME/neo4j/data:/data \
    -v $HOME/neo4j/logs:/logs \
    -v $HOME/neo4j/import:/var/lib/neo4j/import \
    -v $HOME/neo4j/plugins:/plugins \
    --env NEO4J_AUTH=neo4j/test \
    neo4j:latest
```
The issue is coming from the `latest` you should choose a specific version and stick to it otherwise every time there is a major update you could end up with this kind of issue. You can go to [docker hub][1] and select the version you use when you first download your image.

It only probably appears today because you cleanup your computer et remove your NEO4J image and when you run the image again it download the `latest` which is different than the one you use the first you download your initial image.


  [1]: https://hub.docker.com/search?q=neoJ&amp;type=image",0,67740081
2541,https://stackoverflow.com/a/67653191,display all nodes except one type of node,false,"Would this work?

    MATCH (n) 
    // excluding the :TAG nodes
    WHERE NOT n:TAG 
    //or nodes that have a :TAG relationship
    OR EXISTS (n)-[:TAG]-&gt;()

    RETURN n",0,67653191
2542,https://stackoverflow.com/a/67646811,Can I have the command (dependency) for neo4j in build.sbt for spark 3 and scala 2.12 please?,false,"Unfortunately there is a bit of an issue with Bintray shutting down and our dependancies are returning a Forbidden error. 

You can follow the progress about moving to Maven2 [here](https://github.com/neo4j-contrib/neo4j-spark-connector/issues/334).

In the meantime you can download one of the JARs directly and use it in Scala. 

You can find the JARs in the [Github release page](https://github.com/neo4j-contrib/neo4j-spark-connector/releases/tag/4.0.2).

The one you want to use is `neo4j-connector-apache-spark_2.12-4.0.2_for_spark_3.jar`",0,67646811
2543,https://stackoverflow.com/a/67727994,Tweak logging of standalone Neo4j server,false,"I would write out the files to stdout.

```
# forward logs to docker log collector
RUN ln -sf /dev/stdout /logs/debug.log
```

So this is a &#39;docker&#39; solution but handy and works also for other usecases.",0,67727994
2544,https://stackoverflow.com/a/67636335,How to write Cypher query in .net core API,false,"Have you tried just doing:

```
var query = client.Cypher
    .Match(&quot;MATCH (n:learningPaths)--&gt;(m:modules)&quot;)
    .Where(&quot;any(x IN n.modules WHERE x = &#39;any course&#39;)&quot;
    .Return( n =&gt; n.As&lt;learningPaths&gt;());
```",0,67636335
2545,https://stackoverflow.com/a/67662961,Neo4j is returning No Value for cypher query,false,"I don&#39;t think you can unwind a duration. Only lists can be unwinded. You probably want to use `WITH` instead of `UNWIND`.

```sql
MATCH (n:Event)
WITH duration({hours: n.tph, minutes: n.tpm, seconds: n.tps}) AS duration
RETURN duration.minutes
```",1,67662961
2546,https://stackoverflow.com/a/67577916,Cypher join informations from different tables into a single one,true,"If you&#39;re using Neo4j 4.x or higher, you can UNION the results of the queries in a subquery, and outside of it perform a sum() to get the results into a single row per user:

```
CALL {
 MATCH (u:UserNode)-[:PROMOTER_OF*1..]-&gt;(c:UserNode)
 WHERE u.promoterActualRole IN [&quot;GOLD&quot;,&quot;RUBY&quot;,&quot;SAPPHIRE&quot;,&quot;BRONZE&quot;,&quot;EMERALD&quot;, &quot;DIAMOND&quot;]
    AND datetime(c.promoterStartActivity) &gt;= datetime(&quot;2021-02-01T00:00:00Z&quot;) 
    AND datetime(c.promoterStartActivity)&lt;= datetime(&quot;2021-05-31T23:59:59Z&quot;)
    AND c.promoterEnabled = true
    AND u.firstName=&quot;Gianvito&quot;
 WITH u as user, count(c) as num_promoter
 WHERE num_promoter &gt;= 150
 RETURN user, num_promoter, 0 as num_swaggy
 
 UNION
 
 MATCH (u:UserNode)-[:PROMOTER_OF*1..]-&gt;(c:UserNode)
 WHERE u.promoterActualRole IN [&quot;GOLD&quot;,&quot;RUBY&quot;,&quot;SAPPHIRE&quot;,&quot;BRONZE&quot;,&quot;EMERALD&quot;, &quot;DIAMOND&quot;]
    AND datetime(c.subscriptionDate) &gt;= datetime(&quot;2021-02-01T00:00:00Z&quot;) 
    AND datetime(c.subscriptionDate)&lt;= datetime(&quot;2021-05-31T23:59:59Z&quot;)
    AND c.kycStatus = &quot;OK&quot;
    AND u.firstName=&quot;Gianvito&quot;
 WITH u as user, count(c) as num_swaggy
 WHERE num_swaggy &gt;= 1
 RETURN user, 0 as num_promoter, num_swaggy
}

WITH user, sum(num_promoter) as num_promoter, sum(num_swaggy) as num_swaggy
RETURN user.firstName as name, user.email as email , num_promoter, num_swaggy
```

Also you don&#39;t need to use DISTINCT when you&#39;re performing any aggregation, since the grouping key will become distinct automatically as a result of the aggregation.",0,67577916
2547,https://stackoverflow.com/a/67641626,Error when running Zeppelin to connect Neo4j &amp; Spark,false,"You are looking at an outdated version of Zeppelin integration. Nowadays Zeppelin supports querying Neo4j out of the box with https://zeppelin.apache.org/docs/0.8.0/interpreter/neo4j.html.

You can check out how I have done it in my repo: https://github.com/tomasonjo/zeppelin-graph-algo",0,67641626
2548,https://stackoverflow.com/a/67563266,Creating a Relationship between 2 nodes,false,"Load each csv separately.

The first run creates the text nodes. Example:

    LOAD CSV WITH HEADERS FROM &quot;file:///text.csv&quot; AS row1
    MERGE (t:Text {text_id:row1.text_id})
    SET t.text=row1.text

The second run creates the keyword, looks up the text node by id and creates the relationship. Example:


    LOAD CSV WITH HEADERS FROM &quot;file:///keyword.csv&quot; AS row
    MERGE (k:Keyword {keyword:row.Keyword})
    WITH row,k
    MATCH (t:Text {text_id:row.text_id}), 
    MERGE (k)-[:IS_IN]-&gt;(t)",1,67563266
2549,https://stackoverflow.com/a/67572418,Spring Data Neo4j implement relationship entity with @RelationshipProperties and @TargetNode,true,"A relationship with properties does not point towards both entities anymore but is a directed relationship. We do not make any assumptions if the TargetNode is an end or a start node. This is defined in the relationship-defining class.
Assuming the RelationshipValue is used in Decision and this should get connected to Characteristic, you would define something like:
```
@RelationshipProperties
public class RelationshipValue {

    @Id
    @GeneratedValue
    private Long graphId;

    @TargetNode
    private Characteristic characteristic;
```
and in `Decision`
```
public class Decision {

    @Relationship(&quot;HAS_VALUE_ON&quot;) // direction can be OUTGOING (default) or INCOMING
    private RelationshipValue relationshipValue;
}
```


x-post: https://community.neo4j.com/t/spring-data-neo4j-implement-relationship-entity-with-relationshipproperties-and-targetnode/38429/2?u=gerrit.meier",1,67572418
2550,https://stackoverflow.com/a/67572392,Spring Data Neo4j @Properties annotation,true,"You would use the `@CompositeProperty` annotation.
This will work with `Map&lt;String/Enum, Object&gt;`.

Here is the link to the documentation with some further information.
https://docs.spring.io/spring-data/neo4j/docs/current/reference/html/#custom.conversions.composite-properties",1,67572392
2551,https://stackoverflow.com/a/67531582,Neo4j Cypher query of the Datamodel,true,"I think what you&#39;re looking for is `CALL db.schema.visualization`

The output for the Movie Graph is:

[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/N4Rzt.png",1,67531582
2552,https://stackoverflow.com/a/67532685,How to set a property if not exists array in neo4j,false,"A solution I can think of is this one:

Given this node

```
CREATE (p:Test {my_array: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]})
```

you can run this

```
MATCH (p:Test)
WITH p, apoc.coll.contains(p.my_array, &quot;d&quot;) AS propertyExists
WHERE propertyExists = false
SET p.my_array = p.my_array + &quot;d&quot;
RETURN p.my_array
```



Maybe can be improved but I think it kinda work.

As I said in the comment, you need to [install APOC first](https://neo4j.com/labs/apoc/4.1/installation/), and use [apoc.coll.contains](https://neo4j.com/labs/apoc/4.1/overview/apoc.coll/apoc.coll.contains/)",0,67532685
2553,https://stackoverflow.com/a/67569787,How to set a property if not exists array in neo4j,false,"Without using APOC function you can check if an element exists in an array by using the keyword &quot;in&quot;.  

&gt;1. Get all nodes without the element &quot;d&quot;
&gt;2. Update the array by adding another array with one element [&quot;d&quot;]
&gt;3. Return node

    MATCH (t:Test) WHERE NOT &#39;d&#39; in t.my_array
      SET t.my_array = t.my_array + [&#39;d&#39;]
    RETURN t",1,67569787
2554,https://stackoverflow.com/a/67533811,AND clause for matching 3 conditions in NEO4j,true,"If I understood correctly you want all the `:projectFields`&#160;nodes that have the following criteria:

* name = &quot;Photo 5 Description:&quot; and value = &quot;farmhouse&quot;
* name = &quot;Photo 6 Description:&quot; and value = &quot;penthouse roof&quot;
* name = &quot;Photo 7 Description:&quot; and value = &quot;house&quot;

or something like that. All the other conditions that seems to be working.

I&#39;m concerned about the modelling of your domain, but since it&#39;s not your question I&#39;ll leave my considerations for me.

I would try something like this:

```
MATCH (n:TemplateForm)-[r:DEFINED_BY]-(m:ProjectForm)-[s:CONNECTED]-(b:ProjectPage)-[p:CONNECTED]-(d:ProjectField) 
WHERE Id(n) = 907318 
    AND b.name = &quot;REPORT PHOTOS - COVER AND APPENDICES&quot; 
    AND NOT (d.type IN [&#39;imageArray&#39;,&#39;image&#39;,&#39;barSeparator&#39;,&#39;map&#39;]) 
    AND (
        (d.name = &quot;Photo 6 Description:&quot; AND d.value = &quot;penthouse roof&quot;) 
        OR (d.name = &quot;Photo 7 Description:&quot; AND d.value = &quot;house&quot;)
        OR (d.name = &quot;Photo 5 Description:&quot; AND d.value = &quot;farmhouse&quot;)
    )
RETURN d
```

In this way it should return all the `:projectFields` that match one of those criteria, every other combination will be excluded.

I might have understood wrong, if so I&#39;m sorry. 

One thing that I need to suggest is to add at least relationship direction to improve performances.
",0,67533811
2555,https://stackoverflow.com/a/67563294,Disconnect / replace subgraph edges with Cypher,true,"`nodes()` and `relationships()` return collections of nodes, this is why you cannot merge or delete them.

To get from a collection to single nodes or relationships, you can use [UNWIND][1].
An example would be

```
WITH nodes(p) as nodes
UNWIND nodes as node
MERGE (node)-.....
```

or 

```
WITH relationships(p) as rels
UNWIND rels as rel
DELETE rel
```


  [1]: https://neo4j.com/docs/cypher-manual/current/clauses/unwind/",0,67563294
2556,https://stackoverflow.com/a/67577855,Disconnect / replace subgraph edges with Cypher,false,"If you use APOC Procedures, there are various refactoring procedures that can be used to clone a node and its relationships, as well as refactor the relationships, having the effect of redirecting them to the other node (but in reality making copies that point to the other node and deleting the originals)

See `apoc.refactor.cloneNodesWithRelationships()` and `apoc.refactor.to()` (or refactor.from() depending on which end of the relationships should be redirected to the new node).

You can use `call apoc.help(&#39;refactor&#39;)` to see all the refactoring procs once you have APOC installed.",0,67577855
2557,https://stackoverflow.com/a/67563312,How to make a simple Neo4J graph from a single CSV.file,true,"You&#39;ll have to decide on what the labels of your nodes will be and the relationship type but this example should get you started.

```
LOAD CSV WITH HEADERS FROM &#39;file:///org.csv&#39; AS row
MERGE (e:Person {id:row.Employee})
MERGE (l:Person {id:row.Leader})
MERGE (e)-[:REPORTS_TO]-&gt;(l)
```",1,67563312
2558,https://stackoverflow.com/a/67516577,A method to detect non-repetition relation when neo4j is inserted?,false,"MATCH (p:lj_package),(v:lj_package_version) 
WHERE p.lj_package=v.package_id and v.package_id=&#39;3982913&#39; and not  (v)-[:IN]-&gt;(p)  return p,v ;
You only need to filter existing relationships when querying！

    not  (v)-[:IN]-&gt;(p) ",0,67516577
2559,https://stackoverflow.com/a/67512652,Importing a CSV file to neo4j with a column that has csv values,true,"You&#39;ll want to use `split()` on the field, using &#39;,&#39; as the delimiter, to get a list of elements. Then you can either UNWIND or use FOREACH to process the elements of the list, probably to MATCH on nodes with the given id. 

Keep in mind that all fields are treated as strings, so you will have to use `toInteger()` to cast the values if you want to treat them as numerics.",0,67512652
2560,https://stackoverflow.com/a/68103749,Facing IndexEntryConflictException while merging,false,"Stop the instance,
delete the `index` and `schema` directories,
then restart the instance.
It will solve the issue.",0,68103749
2561,https://stackoverflow.com/a/67504673,Is the neo4j documentation inconsistent regarding embedding parameter?,true,"Graph embeddings were introduced in version 1.3 and the tutorial you found is for that version and it uses embeddingSize.  Then 2nd link you found is the recent documentation for node2Vec and it is meant for &gt;= 1.4 version.  Look at the header of your 2nd link and you will see below

    Neo4j Graph Data Science &gt;
    The Neo4j Graph Data Science Library Manual v1.5  &gt;
    Algorithms  &gt;
    Node embeddings  &gt;
    Node2Vec

Neo4j documentations are not up-to-date so if you are really into code, you can look at the github here: https://github.com/neo4j/graph-data-science.  It is changing at speed of light! ",0,67504673
2562,https://stackoverflow.com/a/67499377,"Neo4j streams, fabric integration not working. Log reports &quot;The `USE GRAPH` clause is not available in this implementation of Cypher&quot;",true,"The `USE` clause is currently not supported in this setting (only when connected using a neo4j driver).

Remove the `use integerpolys` from the query and instead configure the streams plugin with the target database directly, according to https://neo4j.com/labs/kafka/4.0/consumer/#_multi_database_support

    streams.sink.enabled.to.integerpolys=true
    
    streams.sink.topic.cypher.twoPoly.to.integerpolys=\
    MERGE (i:IndexedBy {N:event.NN,RowCounter:event.RowCounterr,MaxN:event.nMaxx,Dimension:&quot;2&quot;} ) \
    MERGE (t:TwoSeqFactor {twoSeq:event.tSeqDB} ) \
    MERGE (v:VertexNode        {Vertex:event.vertexDBVertex,Scalar:event.vertexScalarDB,Degree:event.vertexDegreeDB} ) \
    MERGE (e:Evaluate {Value:event.targetEvaluate}) \
    MERGE  (i)-[ee:TwoFactor]-&gt;(t) \
    MERGE (i) -[:IndexedByEvaluate]-&gt;(e) \
    MERGE  (i)-[:VertexIndexedBy]-&gt;(v)

",0,67499377
2563,https://stackoverflow.com/a/68823724,How do I stop/configure Neovis Physics,false,"You can call stabilize on the neovis object assuming it was called `viz` it can be done with the following:

&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;

&lt;!-- language: lang-js --&gt;

    viz.stabilize()

&lt;!-- end snippet --&gt;

",0,68823724
2564,https://stackoverflow.com/a/67486030,Neo4J - Neogma - TypeError: Cannot read property &#39;queryRunner&#39; of undefined,false,"Problem solved! 

Just got a hint from: https://github.com/themetalfleece/neogma/issues/7

To export the file and make use of the neogma object, it needs to be initialized before importing other database-related dependencies. ",0,67486030
2565,https://stackoverflow.com/a/67478118,Neo4j data loading performance: driver vs custom procedure,false,"Keep in mind that procedure code executes on the server itself, it is effectively embedded with Neo4j.

Compare that to the need to transfer all nodes and their properties over the network. That&#39;s a lot of extra I/O that wasn&#39;t needed with procedures.",1,67478118
2566,https://stackoverflow.com/a/67647119,Neo4j data loading performance: driver vs custom procedure,true,"As InverseFalcon points out, the transfer over the bolt protocol comes with speed limitations, not present in procedures. What I was looking for is the embedded DBMS described [here](https://neo4j.com/docs/java-reference/current/java-embedded/include-neo4j/). I am now using this like this:
```java
public class GraphAccess implements AutoCloseable
{
    ...

    private final DatabaseManagementService managementService =
        new DatabaseManagementServiceBuilder(NEO4J_DATA_PATH)
        .setConfig( GraphDatabaseSettings.read_only, true )
                        .setConfig(GraphDatabaseSettings.logs_directory,
                                   NEO4J_LOGS_DIRECTORY).build();
    public final GraphDatabaseService db = managementService.database( NEO4J_DATABASE_NAME );

    public final HashMap&lt;Integer, String&gt; mapNodeProp = new HashMap&lt;&gt;();

    ...

    private void getNodeData() {

        try ( Transaction tx = db.beginTx() ) {
            tx.getAllNodes().forEach((Node n) -&gt; {
                
                final Integer nodeId = (int) n.getId();
                mapNodeProp.put(nodeId, (String) n.getProperty(&quot;name&quot;));
            
            }
        }
    }
}

```

This has the advantage of high throughput (since it doesn&#39;t use the driver, but accesses the neo4j database data directly) and the possibility to use it in the context of a Spring app (since it&#39;s not implemented as a custom procedure).
",0,67647119
2567,https://stackoverflow.com/a/67483925,How can I add another MATCH condition if CASE is such and such in Cypher,false,"Or patter comprehensions that compute a list of data  

    CASE WHEN type.character = &#39;Odborn&#253;&#39; 
    THEN [ (teachingSubject)&lt;--(achievedField) | achievedField] 
    ELSE [] END

",0,67483925
2568,https://stackoverflow.com/a/67471610,Replace a Relationship-Node-&gt;Relationship construct with one Realtionship containing the label of the replaced node,false,"We cannot create a relationship based on a property. You need to create a new relationship and change the type (or relationship name) to your data label name. I used an apoc function to change (or update) that. What I did is 
&gt;1) Find all nodes and relationship that are attached to Data
&gt;2) Create the needed relationship but use a dummy relationship type:  REL
&gt;3) Use apoc function apoc.refactor.setType to change the relationship type from REL to c.label
&gt;4) Don&#39;t forget to remove the dummy relationship REL

    Match (a)-[:Input]-&gt;(c:Data)-[:Output]-&gt;(f)
    CREATE (a)-[r:REL]-&gt;(f) 
    WITH a, r, c, f
    CALL apoc.refactor.setType(r, c.label)
    YIELD input, output
    WITH a, c, f 
    MATCH (a)-[rel:REL]-&gt;(f) 
    DELETE rel
    RETURN a,  f  

BEFORE:
[![enter image description here][1]][1]

AFTER:

[![enter image description here][2]][2]


  [1]: https://i.stack.imgur.com/q61An.png
  [2]: https://i.stack.imgur.com/Kv0iy.png",0,67471610
2569,https://stackoverflow.com/a/67467616,Neo4j: Multiple Possible Nodes from One CSV Column,false,"I would introduce a global label for persons and businesses...

    LOAD CSV WITH HEADERS FROM &quot;....csv&quot; AS file
    MERGE (b:Entity {ID: file.Business_ID) 
    WITH file, b
    MERGE (p:Entity {Gender: file.Gender) 
    WITH file, b, p
    MERGE (b)-[:owned_by] -&gt;(p)

I don&#39;t really know why you use Gender, probably a typo, but anyway... on the first import use a global node label like :Entity to get the ownership relationship in. In subsequent imports you can add secondary :Person or Business label to nodes if needed.",1,67467616
2570,https://stackoverflow.com/a/67470690,Opposed of apoc.text.HexValue in neo4j,false,"There is an APOC function that converts a string character into hex. But 
 there is no function to convert a string &gt; 1 char into hex. https://neo4j.com/labs/apoc/4.1/overview/apoc.text/apoc.text.hexCharAt/

    apoc.text.hexCharAt(text :: STRING?, index :: INTEGER?)

For example: Convert the character &quot;j&quot; into hex. The 5th char (or index 4) of the string Neo4j is converted into hex

    RETURN apoc.text.hexCharAt(&quot;Neo4j&quot;, 4) AS output;

    Result: &quot;006A&quot;
",0,67470690
2571,https://stackoverflow.com/a/67472144,Opposed of apoc.text.HexValue in neo4j,false,"You can create a GH issue for the inverse function.

Until then you can compute it manually too.

```
with &quot;1FE&quot; as hex 
return reduce(res=0, c in split(toUpper(hex),&#39;&#39;) 
| res*16 + 
case c when &#39;F&#39; then 15 when &#39;E&#39; then 14 when &#39;D&#39; then &#39;13&#39; when &#39;C&#39; then 12 when &#39;B&#39; then 11 when &#39;A&#39; then 10 
else toInteger(c) end) 
as value, 0x1FE as comp
```

btw. Cypher also supports hex values: `return 0x1F`",0,67472144
2572,https://stackoverflow.com/a/67470908,Neo4j poor order by query performance,true,"You need to indicate to the planner that your m.score field is numeric, so pulls that from the index. I.e. `where m.score &gt; 0`

You should see it in your query plans.

Your query looks also really convoluted, and generated. But actually not taking into account that always &quot;false&quot; expressions can just be left out from the query parts e.g. `WHERE NOT [] = []` ",4,67470908
2573,https://stackoverflow.com/a/67453099,How to fix timeless execution in cypher query - Neo4j Graph Database?,true,"So, the problem was that every time i use with, i&#39;m working in nested loops. The more nested loops, the slower the query will be. A good way to speed up, is to create simplier queries when it&#39;s possible.

For example in the json file:

    &quot;Weakness_Catalog&quot;: {
       &quot;Weaknesses&quot;: {&quot;Weakness&quot;:[...]}
       &quot;Categories&quot;: {&quot;Category&quot;:[...]}
       &quot;Views&quot;: {&quot;View&quot;:[...]}
       &quot;External_References&quot;: {&quot;External_Reference&quot;:[...]}
    } 

i will execute one query for Weaknesses, one for Categories, one for Views and one for External_References.",0,67453099
2574,https://stackoverflow.com/a/67465960,Graph database nodes and edges change over time,false,"He typical approach is to us validFrom/validTo attributes on vertices and edges. Then you can filter on these attributes when querying the graph. 

Eg.

    CREATE VERTEX Club SET name = &#39;AS Roma&#39;;
    CREATE VERTEX Player name = &#39;Francesco&#39;, surname = &#39;Totti&#39;;
    CREATE EDGE PlaysWith
      FROM (SELECT FROM Player WHERE surname = &#39;Totti)
      TO (SELECT FROM Club WHERE name = &#39;AS Roma&#39;)
      SET
      validFrom = date(&#39;1992-01-01&#39;, &#39;yyyy-MM-dd&#39;)
      validTo = date(&#39;2017-12-032&#39;, &#39;yyyy-MM-dd&#39;);

    MATCH {class:Player, as:p}
          .outE(&quot;PlaysWith&quot;){where:(
              validFrom &lt; date(&#39;2001-01-01&#39;, &#39;yyyy-MM-dd&#39;)
              validTo &gt; date(&#39;2001-01-01&#39;, &#39;yyyy-MM-dd&#39;)
          )}
          .inV(){as:Club, where:(name = &quot;AS Roma&quot;)}
    RETURN $elements;
",0,67465960
2575,https://stackoverflow.com/a/67496749,Graph database nodes and edges change over time,false,"Adding a time dimension nodes and edges in a graph database is a pretty common design pattern. It allows you to capture all states of the data and then view the data at a particular point in time or within a time range.

Here is an InfiniteGraph solution:  

    
    UPDATE SCHEMA {
       CREATE CLASS Team {
          name    : String,
          players : LIST {
                        element: Reference {
                        edgeClass  : PlaysFor,
                        edgeAttribute   : player
                        }, 
                      CollectionTypeName : SegmentedArray
                    }
      }
      CREATE CLASS Player {
         name      : String,
         playsFor  : LIST {
                        element: Reference {
                           edgeClass : PlaysFor,
                           edgeAttribute  : team
                        },
                        CollectionTypeName : SegmentedArray
                      }
      }
      CREATE CLASS PlaysFor {
          dateFrom : Date,
          dateTo   : Date,
          team     : Reference {referenced: Team, inverse: players },
          player   : Reference {referenced: Player,  inverse: playsFor }
       }
    };
    //---------------------------------- Result ------------------------------------
    Done.


Create some player and team data...

    let teamHKiel = CREATE Team { name: &quot;Holstein Kiel&quot; };   
    let teamMainz = CREATE Team { name: &quot;FVZ Mainz 05 II&quot; };
    let teamSpVgg = CREATE Team { name: &quot;SpVgg Unterhaching&quot; };

    let playerRZ = CREATE Player { name: &quot;Robin Zentner&quot; };
    let playerAH = CREATE Player { name: &quot;Alexander Hack&quot; };


Link the players to their teams for specific date ranges.

    CREATE PlaysFor { 
          player: $playerRZ, team: $teamMainz, 
          dateFrom: 2014-08-02, dateTo: 2015-08-01 
    };
    //---------------------------------- Result ------------------------------------
    3-3-1-14
    
    
    CREATE PlaysFor { 
           player: $playerRZ, team: $teamHKiel, 
           dateFrom: 2015-08-02, dateTo: 2016-08-01 
    };
    //---------------------------------- Result ------------------------------------
    3-3-1-19
    
    CREATE PlaysFor { 
           player: $playerAH, team: $teamMainz, 
           dateFrom: 2014-07-02, dateTo: 2017-06-01 
    };
    //---------------------------------- Result ------------------------------------
    3-3-1-22
    
    CREATE PlaysFor { 
           player: $playerAH, team: $teamSpVgg, 
           dateFrom: 2013-07-02, dateTo: 2014-07-01 
    };
    //---------------------------------- Result ------------------------------------
    3-3-1-25

Which team was Robin Zentner playing for on 2016-05-01?

    LET d = 2016-05-01;
    MATCH path = (p:Player {name == &#39;Robin Zentner&#39;}) 
    		     -[:PlaysFor {dateFrom &lt; $d AND dateTo &gt; $d}]-&gt;(t:Team) 
    		RETURN p.name as player, t.name as team;
    //---------------------------------- Result ------------------------------------
    {
      _Projection
      {
        player:&#39;Robin Zentner&#39;,
        team:&#39;Holstein Kiel&#39;
      }
    }

Set a different date.

    //---------------------------------- Statement ---------------------------------
    // LET d = 2015-05-01;
    //---------------------------------- Result ------------------------------------
    Done.

Which team was Robin Zentner playing for on 2015-05-01?   

    MATCH path = (p:Player {name == &#39;Robin Zentner&#39;}) 
           		-[:PlaysFor {dateFrom &lt; $d AND dateTo &gt; $d}]-&gt;(t:Team) 
           		RETURN p.name as player, t.name as team;
    //---------------------------------- Result ------------------------------------                  
    {
      _Projection
      {
        player:&#39;Robin Zentner&#39;,
        team:&#39;FVZ Mainz 05 II&#39;
      }
    }

Who was playing for FVZ Mainz 05 II on 2015-03-01?

    LET d = 2015-03-01;
    //---------------------------------- Result ------------------------------------
    Done.

    MATCH path = (t:Team {name == &#39;FVZ Mainz 05 II&#39;}) 
    			 -[:PlaysFor {dateFrom &lt; $d AND dateTo &gt; $d}]-&gt; 
                 (p:Player) 
    			 RETURN p.name as player, t.name as team;
    //---------------------------------- Result ------------------------------------
    
    {
      _Projection
      {
        player:&#39;Robin Zentner&#39;,
        team:&#39;FVZ Mainz 05 II&#39;
      },
      _Projection
      {
        player:&#39;Alexander Hack&#39;,
        team:&#39;FVZ Mainz 05 II&#39;
      }
    }

#InfiniteGraph",0,67496749
2576,https://stackoverflow.com/a/67918450,Dynamic Neo4j Cypher Query,true,"I did this in the end using the python library py2neo, and created the cypher query using python

    case_when = &#39;&#39;
    accumulator = &#39;&#39;
    for x in range(max_paths):
        accumulator += f&#39;* co2[{x}]&#39;
        case_when += f&#39;when x={x+1} then acc + co2[{x+1}]&#39; + accumulator + &#39; \n &#39;",0,67918450
2577,https://stackoverflow.com/a/67437816,How to connect a remote MS SQL Server in neo4j tool?,false,"As mentioned on the community post, Neo4j Desktop is not a general db management app, it is specifically for managing and working with Neo4j, so MS SQL support will not be added. Please search for other tools that are designed to work with that db.

If you want to connect to an MS SQL server from Neo4j, then you could use APOC to perform a load via JDBC:

https://neo4j.com/labs/apoc/4.1/database-integration/load-jdbc/",0,67437816
2578,https://stackoverflow.com/a/67506057,PreSave/PrePersist/BeforeSave Spring Data Neo4j,true,"I assume that you are talking about Spring Data Neo4j 6, right?

There is now the functionality of a `BeforeBindCallback&lt;T&gt;` in place.
Whenever there is a save or update, SDN will call all registered callback beans before persisting the entity.

In your configuration you would define something like
```
@Bean
public BeforeBindCallback&lt;MyEntity&gt; beforeBindMyEntityCallback() {
    return entity -&gt; {
        entity.setName(&quot;AnotherName&quot;);
        return entity;
    };
}
```
and you can, like every other manually created bean, also provide other dependencies in the parameter list of the bean creation, if needed.

I created a very small example here https://github.com/meistermeier/neo4j-issues-examples/tree/master/so-67424479

This is really missing from the documentation, you are right.",1,67506057
2579,https://stackoverflow.com/a/67422294,Efficiently Find Unique Intermediate Nodes Connecting Two Sets of Nodes in Neo4j/Cypher,false,"You can use a multi match query like this:
```
MATCH p = (drama1:Movie {Genre:&#39;Drama&#39;})-[r1]-(a1)-[r2]-(comedy:Movie {Genre:&#39;Comedy&#39;})-[r3]-(a2)-[r4]-(drama2:Movie {Genre:&#39;Drama&#39;})
MATCH (drama1)-[]-(a:Actor)-[]-(drama2) 
WHERE drama1&lt;&gt;drama2 
RETURN nodes(p)
```
Query explanation:
- The first MATCH find 2 dramas connected by a comedy
- The second MATCH tells that the 2 dramas have to be connected by the same actor
- The WHERE clause indicate that the 2 dramas have to be different
- RETURN clause returns the pattern

There is no much to do to optimize the query because you are not filtering by any property, so you are going through the entire graph. You can try creating an index on &#39;Genre&#39; property but it&#39;s not recomended if you only have two different values.

An other option is using SKIP/LIMIT to retrive patterns in smaller bulks:
```
MATCH p = (drama1:Movie {Genre:&#39;Drama&#39;})-[r1]-(a1)-[r2]-(comedy:Movie {Genre:&#39;Comedy&#39;})-[r3]-(a2)-[r4]-(drama2:Movie {Genre:&#39;Drama&#39;})
MATCH (drama1)-[]-(a:Actor)-[]-(drama2) 
WHERE drama1&lt;&gt;drama2 
RETURN nodes(p) SKIP 0 LIMIT 100000
```
This query gets the first 100k patterns and then you have to increment the skip to get the next 100k (SKIP 100000 LIMIT 100000). By this way you have to run 10 queries to get all patterns.",0,67422294
2580,https://stackoverflow.com/a/67424452,Updating neo4j relationship properties without duplicating the existing relationship,false,"If you want to find a :connect relationship between the nodes (you don&#39;t care what the properties are to match upon) and then update the properties, then only MERGE the relationship, do not include the properties in the pattern. Then use SET to set the properties to the new values:

```
MATCH (a:node), (b:node) 
WHERE a.name = &#39;sw1&#39; AND b.name = &#39;sw2&#39;
MERGE (a)-[r:connect]-(b)
SET r.packets_transmitted = 0, r.packets_recieved = 0
```

If the properties should only be set on creation, then use ON CREATE SET instead.

EDIT: I removed the direction in the MERGE pattern, that will allow it to MERGE to an existing :connect relationship between the nodes, no matter the direction.",0,67424452
2581,https://stackoverflow.com/a/67444467,Updating neo4j relationship properties without duplicating the existing relationship,true,"The answer: 
No need to establish the relationship property when creating the relationship, since the whole code is executed every time and this leads to relationship duplication.  Below is the code after correcting it: 

        cqlCreate_1=f&quot;merge(n:node{{name:&#39;openflow:2&#39;}})&quot;
    with graphDB_Driver.session() as graphDB_Session:
            graphDB_Session.run(cqlCreate_1)
    
    cqlCreate_3=f&quot;merge(m:node{{name:&#39;2e:38:64:0e:e8:1f&#39;}})&quot;
    with graphDB_Driver.session() as graphDB_Session:
            graphDB_Session.run(cqlCreate_3)
    
    cqlCreate_2=f&quot;MATCH (a:node),(b:node) WHERE a.name =&#39;openflow:2&#39;\
    and b.name=&#39;2e:38:64:0e:e8:1f&#39;\
    merge **(a)-[c:connect]-(b)**&quot;
    with graphDB_Driver.session() as graphDB_Session:
            graphDB_Session.run(cqlCreate_2)
    
    cqlUpdate=f&quot;MATCH (a:node)-[c:connect]-(b:node) where a.name=&#39;openflow:2&#39;\
    and b.name=&#39;2e:38:64:0e:e8:1f&#39;\
    set c.p=200&quot;
    with graphDB_Driver.session() as graphDB_Session:
        graphDB_Session.run(cqlUpdate)",0,67444467
2582,https://stackoverflow.com/a/67417001,How can I create GraphQL API&#39;s with Django and Neo4j Database?,false,"I worked with all 3 of the stacks:
- Graphene-Django with Postgresql DB
- Django with Neo4j &amp; Postgresql
- Neo4j

I can tell you actually you can have either one or the other.

**Neo4j** has **it&#39;s own web interface** and **it&#39;s own GraphQL API** Built in:
- http://yourhost:7474/browser/
- http://yourhost:7474/api/

For **Django** to work with **Neo4j** you can use [neomodel][1] or even better the django version of it: [django-neomodel][2] that is using `neomodel` under the hood.


I am actually having a separate setup and I use Django REST Framework and everything I store in Neo4j i expose it in REST endpoints instead of GraphQL.

So I would say you can either Use django-neomodel to manage/work with your data and you can simply decide if you want to:
- use **Graphene-Django** to expose  all of the data Neo4j included
- use **Neo4j GraphQL API**

One thing though...I would still advice you to have a **DEFAULT_DATABASE** one of the Officially supported to handle User related data and authentication.


As a personal remark: Neo4j is a great technology  but is not the fastest when it comes to transaction speed (where Postgres or other relational databases shines).

It is after all a technology running on Java and not on C++ like most of the other Databases out there...so keep that in mind.

Good luck.

  [1]: https://pypi.org/project/neomodel/
  [2]: https://github.com/neo4j-contrib/django-neomodel",1,67417001
2583,https://stackoverflow.com/a/67563751,How can I create GraphQL API&#39;s with Django and Neo4j Database?,false,"I&#39;m running a similar setup, but you&#39;re talking about a lot of things here, it might be easier to understand if you break up the concepts.

It&#39;s easiest to understand if you think about just running Neo4j in Python (independent of Django).


**Neo4j/Python**

1. Get your Neo4j running and be able to connect to it using python (I use py2neo).

I made a video demo of making neo4j flask app starting here: https://www.youtube.com/watch?v=h8cyPIEfxQY&amp;t=1215s

Code for this is here: https://github.com/elena/graph-fun/blob/master/notebook.ipynb


**Django/Graphene**

2. Get your Django project running. Setup  graphene in Django (note, wrapping your head around graphene/graphQL is a whole other thing, but do this step separately, ensure you understand how your conventional Django app can connect to graphene).

Some magic sauce here is that we use GraphiQL to serve GraphQL endpoints: https://github.com/graphql/graphiql this generally makes your life much easier.

These docs: https://www.fullstacklabs.co/blog/django-graphene-rest-graphql

**Python/Graphene/Neo4j**

3. Make a module/app in your Django project for your Neo4j connection and statements. Important to note here is: **graphene doesn&#39;t care where the data comes from**. Just use plain python-graphene to send whatever data to graphene `schema.py`

This is the flask example code (https://github.com/elena/graph-fun/blob/master/app.py), but you can just feed the Neo4j output to your GraphQL python schema.

See, python (not Django) Graphene doesn&#39;t care where data comes from: https://docs.graphene-python.org/en/latest/quickstart/

Finally you can wrap it all up in your django urls to serve using graphiql.

--

So you need django-graphene to server your schema.py/urls, but this *overcomplicates* things. 

You then need to take a step back and use naive python-graphene to serve Neo4j. 

At least that&#39;s what works for me.

",0,67563751
2584,https://stackoverflow.com/a/67407861,neo4j find all friends who posted something I liked,false,"Thanks for the query plans.

We can see that the rows drop to zero on the expansion of `(start)-[:FRIEND]-&gt;(person)`, so one of two things is happening: either :FRIEND isn&#39;t the actual relationship type (probably an issue of mismatched cases), or more likely, all the :FRIEND relationships present are in the opposite direction, incoming to the start node instead of outgoing.

For social graphs like these, since they&#39;re both :Person nodes, there isn&#39;t a way to tell which direction the relationship was created in, and when you query, the direction shouldn&#39;t matter, all that should matter is that a :FRIEND relationship exists.

Try removing the direction from the pattern here: `(start)-[:FRIEND]-(person: Person)` . Provided your relationship type is correct, that should get you the right results.",0,67407861
2585,https://stackoverflow.com/a/67505405,neo4j find all friends who posted something I liked,false,"For simplicity, I would also combine the 3 patterns into a single long pattern. Doing this will ensure that it doesn&#39;t pull extra patterns that don&#39;t fit later patterns (get retrieved, then filtered out later). Here is what that Cypher would look like:

```
MATCH (start:Person)-[:LIKES]-&gt;(post:Post)&lt;-[:POSTED]-(person: Person)
WHERE (start)-[:FRIEND]-(person)
RETURN start, post, person
```",0,67505405
2586,https://stackoverflow.com/a/67653293,neo4j find all friends who posted something I liked,false,"I would start by

    MATCH (me:Person)-[:FRIEND]-(friend:Person)-[:POSTED]-&gt;(post:Post)&lt;-[:LIKES]-(me)
    RETURN DISTINCT friend

To get the (friend:Person) nodes
",0,67653293
2587,https://stackoverflow.com/a/67392075,Coloring arks (relationships) in Neo4j,false,"No, it is not possible. However you can color ALL relationship in Neo4j desktop/browser by 1) click on the relationship  2) choose the color below

See example:[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/sUDJQ.png",0,67392075
2588,https://stackoverflow.com/a/67408822,Coloring arks (relationships) in Neo4j,false,"One way to do this is to use the cypher output to create an svg file in which you can control a variety of parameters including colors. The Neo4j Browser can export a svg (manual process); otherwise you&#39;ll need to create the svg in code.

Some 3rd party tools enable this. I&#39;m using GraphRX.

",0,67408822
2589,https://stackoverflow.com/a/67563934,Ontology Populating,true,"This video could inform your understanding about modelling and imports for graph database design: https://www.youtube.com/watch?v=oXziS-PPIUA

He steps through importing a CSV in to Neo4j and uses python.

The terms ontology and web semantics (OWL) are probably not what you&#39;re asking about (being loans/finance domain, rather than web). Further web semantics is not taken very seriously by professionals these days.

&quot;Graph database modelling&quot; is probably a useful area of research to solve your problem.",0,67563934
2590,https://stackoverflow.com/a/67389430,Neo4J (Cypher) Group the multiple relationships by node,true,"you do not get catwoman because you only match :Player related to batman through a :Game node, you need to also match (u:Player {playerID:&quot;batman&quot;})-[:FOLLOWS]-&gt;(p:Player)

    MATCH (u:Player{playerID:&quot;batman&quot;})
    OPTIONAL MATCH (u)&lt;-[:HAS_PLAYERS]-(g:Game)-[:HAS_PLAYERS]-&gt;(p:Player) 
    RETURN p.playerID, EXISTS((u)-[:FOLLOWS]-&gt;(p)) AS is_followed, COUNT(g) AS num_games, collect(g.gameId) AS games
    ORDER BY num_games DESC
    union
    match (u:Player{playerID:&quot;batman&quot;})-[:FOLLOWS]-&gt;(p:Player)
    where not exists( (u)&lt;-[:HAS_PLAYERS]-(:Game)-[:HAS_PLAYERS]-&gt;(p:Player) )
    RETURN p.playerID, true AS is_followed, 0 AS num_games, [] AS games
[![enter image description here][1]][1]

(could not think of a way to do it wouthout union, but it might be possible)


  [1]: https://i.stack.imgur.com/E3Hk8.png",1,67389430
2591,https://stackoverflow.com/a/67389932,Create a path between two nodes through another node using cypher command in neo4j?,false,"I think this might be what you are looking for: https://neo4j.com/labs/apoc/4.2/overview/apoc.nodes/apoc.nodes.link/. This will take a list of nodes and create relationships between them to give you a path.

You could also do this with Cypher, but it&#39;s a bit more cumbersome. There&#39;s a knowledgebase article showing each method here: https://neo4j.com/developer/kb/creating-and-working-with-linked-lists/.",0,67389932
2592,https://stackoverflow.com/a/67373650,Graph database or relational database for tree structure data,false,"Neo4j can be a good fit here.

Neo4j does use indexes to find starting points in the graph, such as your root nodes. If you&#39;re just using it to get the root node, then that&#39;s a single index lookup for the entire query.

From there, traversing the tree is just traversing relationships, that&#39;s just pointer hopping node reference -&gt; relationship reference -&gt; node reference etc. No joins involved. Then you&#39;re just crunching on the numbers in the nodes per path to get the percentages.",0,67373650
2593,https://stackoverflow.com/a/67405907,Graph database or relational database for tree structure data,true,"Just about any graph database can model the information you are describing. How you go about constructing the queries to get what you want will be different in each product. 

In InfiniteGraph we can model the information using the following schema:

    UPDATE SCHEMA {
    	CREATE CLASS Company {
    		name		: String,
    		industry	: String, 
    		
    		owns		: LIST {
    						element: Reference {
    							edgeClass		: Owns,
    							edgeAttribute	: owns
    						},
    						CollectionTypeName	: SegmentedArray
    					},
    		ownedBy		: LIST {
    						element: Reference {
    							edgeClass		: Owns,
    							edgeAttribute	: ownedBy
    						},
    						CollectionTypeName	: SegmentedArray
    					}
    		
        }
    	
    	CREATE CLASS Owns
        {
    		percentage	: Real { Storage: B32 },
    		owns 		: Reference {referenced: Company, inverse: ownedBy },
    		ownedBy		: Reference {referenced: Company,  inverse: owns }
        }
    };

Then we can load the data you referred to in your question:

    LET coA = CREATE Company { name: &quot;A&quot;, industry: &quot;Manufacturing&quot; };
    LET coB = CREATE Company { name: &quot;B&quot;, industry: &quot;Manufacturing&quot; };
    LET coC = CREATE Company { name: &quot;C&quot;, industry: &quot;Retail&quot; };
    LET coD = CREATE Company { name: &quot;D&quot;, industry: &quot;Construction&quot; };
    
    CREATE Owns { owns: $coB, ownedBy: $coA, percentage: 50.00 };
    CREATE Owns { owns: $coC, ownedBy: $coB, percentage: 50.00 };
    CREATE Owns { owns: $coC, ownedBy: $coD, percentage: 50.00 };

Finally, we can define a weight calculator operator that effectively multiplies the edge weights along a path together. Here we represent the weight of each edge as 1/percentage and then at the end we flip the sum over again and this gives us the value you&#39;re looking for.

    CREATE WEIGHT CALCULATOR wcOwnership {
    	minimum: 	0,
    	default:	0, 
    	edges: {
    		(:Company)-[ow:Owns]-&gt;(:Company): 1/ow.percentage
    	}
    };

The &quot;edges&quot; section defines the edge patterns to match on and the computation to be performed to compute the edge weight for that edge. In InfiniteGraph, the edge weight does not have to be an attribute; it can be a simple attribute or the result of complex computation based on the contents of one or many objects.

On the given data, we can use the weight calculator to query from the target company (C) up the hierarchy and for each root discovered, we can display the target (C), the percentage of ownership, the length of the path, and the name of the root company. This particular query only goes 1 to 10 degrees ([*1..10]) but this number can be expanded as necessary.

      DO&gt; Match m = max weight 1000.0 wcOwnership 
                        ((cTarget:Company {name == &#39;C&#39;})-[*1..10]-&gt;(cRoot:Company)) 
                         return cTarget.name, 
                                1/Weight(m) as PercentageOwnership, 
                                Length(m), 
                                cRoot.name;
    
    {
      _Projection
      {
        cTarget.name:&#39;C&#39;,
        PercentageOwnership:50.0000,
        Length(m):1,
        cRoot.name:&#39;B&#39;
      },
      _Projection
      {
        cTarget.name:&#39;C&#39;,
        PercentageOwnership:50.0000,
        Length(m):1,
        cRoot.name:&#39;D&#39;
      },
      _Projection
      {
        cTarget.name:&#39;C&#39;,
        PercentageOwnership:25.0000,
        Length(m):2,
        cRoot.name:&#39;A&#39;
      }
    }  

This model will capture all of the root nodes per company in question.

#InfiniteGraph

",2,67405907
2594,https://stackoverflow.com/a/67362305,Parse neo4j JSON response,true,"You can use a `for ... of` loop to go through all objects in `records`!

&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;

&lt;!-- language: lang-js --&gt;

    const result = {
        &quot;records&quot;: [
            {
                &quot;keys&quot;: [
                    &quot;criteria.name&quot;
                ],
                &quot;length&quot;: 1,
                &quot;_fields&quot;: [
                    &quot;Perspective&quot;
                ],
                &quot;_fieldLookup&quot;: {
                    &quot;criteria.name&quot;: 0
                }
            },
            {
                &quot;keys&quot;: [
                    &quot;criteria.name&quot;
                ],
                &quot;length&quot;: 1,
                &quot;_fields&quot;: [
                    &quot;3D&quot;
                ],
                &quot;_fieldLookup&quot;: {
                    &quot;criteria.name&quot;: 0
                }
            },
            {
                &quot;keys&quot;: [
                    &quot;criteria.name&quot;
                ],
                &quot;length&quot;: 1,
                &quot;_fields&quot;: [
                    &quot;2D&quot;
                ],
                &quot;_fieldLookup&quot;: {
                    &quot;criteria.name&quot;: 0
                }
            }
        ],
        &quot;summary&quot;: {
            &quot;query&quot;: {
                &quot;text&quot;: &quot;MATCH (criteria:TEST_01)\nRETURN criteria.name\nLIMIT 3&quot;,
                &quot;parameters&quot;: {}
            },
            &quot;queryType&quot;: &quot;r&quot;,
            &quot;counters&quot;: {
                &quot;_stats&quot;: {
                    &quot;nodesCreated&quot;: 0,
                    &quot;nodesDeleted&quot;: 0,
                    &quot;relationshipsCreated&quot;: 0,
                    &quot;relationshipsDeleted&quot;: 0,
                    &quot;propertiesSet&quot;: 0,
                    &quot;labelsAdded&quot;: 0,
                    &quot;labelsRemoved&quot;: 0,
                    &quot;indexesAdded&quot;: 0,
                    &quot;indexesRemoved&quot;: 0,
                    &quot;constraintsAdded&quot;: 0,
                    &quot;constraintsRemoved&quot;: 0
                },
                &quot;_systemUpdates&quot;: 0
            },
            &quot;updateStatistics&quot;: {
                &quot;_stats&quot;: {
                    &quot;nodesCreated&quot;: 0,
                    &quot;nodesDeleted&quot;: 0,
                    &quot;relationshipsCreated&quot;: 0,
                    &quot;relationshipsDeleted&quot;: 0,
                    &quot;propertiesSet&quot;: 0,
                    &quot;labelsAdded&quot;: 0,
                    &quot;labelsRemoved&quot;: 0,
                    &quot;indexesAdded&quot;: 0,
                    &quot;indexesRemoved&quot;: 0,
                    &quot;constraintsAdded&quot;: 0,
                    &quot;constraintsRemoved&quot;: 0
                },
                &quot;_systemUpdates&quot;: 0
            },
            &quot;plan&quot;: false,
            &quot;profile&quot;: false,
            &quot;notifications&quot;: [],
            &quot;server&quot;: {
                &quot;address&quot;: &quot;localhost:7687&quot;,
                &quot;version&quot;: &quot;Neo4j/4.1.0&quot;,
                &quot;protocolVersion&quot;: 4.1
            },
            &quot;resultConsumedAfter&quot;: {
                &quot;low&quot;: 2,
                &quot;high&quot;: 0
            },
            &quot;resultAvailableAfter&quot;: {
                &quot;low&quot;: 80,
                &quot;high&quot;: 0
            },
            &quot;database&quot;: {
                &quot;name&quot;: &quot;neo4j&quot;
            }
        }
    }

    let option1 = [];
    let option2 = [];

    // For each object in result.records,
    for (let val of result.records) {
      // Put everything in val._fields into our result array.
      // ... spreads the array, so all elements are inserted
      // individually in case, in the future,
      // there are multiple items in _fields.
      option1.push(...val._fields);
      
      // For the object you provided, you could just do
      // val._fields[0]. However, option1 is more generalizable
      // in case there&#39;s ever more than one thing in _fields.
      option2.push(val._fields[0]);
    }

    console.log(option1);
    console.log(option2);

&lt;!-- end snippet --&gt;

",1,67362305
2595,https://stackoverflow.com/a/67335403,Cannot duplicate node due to constraint violation on an _id,true,"We can use a map instead of a node variable for the source of the properties to set.

Using [map projection](https://neo4j.com/docs/cypher-manual/current/syntax/maps/#cypher-map-projection), we can let that map take all the properties of the first node, and selectively overwrite the properties we would like to replace.

    MATCH (s:part{_id:&#39;aaaaa&#39;})
    CREATE (newNode:part)
    SET newNode = s {.*, _id:&#39;bbbbb&#39;}
    RETURN  newNode",1,67335403
2596,https://stackoverflow.com/a/67335573,Cannot duplicate node due to constraint violation on an _id,false,"You can clone nodes using apoc.refactor.cloneNodes like this:
```
MATCH (s:part{_id:&#39;aaaaa&#39;}) WITH s CALL apoc.refactor.cloneNodes([s]) yield input, output RETURN *
```
This query will clone your node without the unique properties, so you have to set that properties later:
```
MATCH (copy:part) WHERE not exists(copy._id) SET copy._id=&#39;bbbbb&#39; RETURN copy
```

This link explain how to clone nodes and relationships: https://neo4j-contrib.github.io/neo4j-apoc-procedures/3.5/graph-refactoring/clone-nodes/",1,67335573
2597,https://stackoverflow.com/a/67335344,Data isolation by limiting access to subtrees in neo4j,true,"With RBAC, labels would be how you would restrict what you could MATCH or TRAVERSE. At the moment we don&#39;t support access based on graph topology (access only on nodes connecting to your project&#39;s root node).

Alternately, with Enterprise, you could create a separate graph per project, and only grant access to each project graph to the project&#39;s users. That gets you full isolation with no ability for anything to get overlooked (forgetting to add a label).",0,67335344
2598,https://stackoverflow.com/a/67324155,Neo4j label wont work if the label is &quot;Tag&quot;,false,"To point out, the &quot;Tag&quot; label is right there, in gray in the lower left of your screenshot.

But if you&#39;re talking about the caption instead, there&#39;s nothing that enforces what property should be used as a default caption in the graph result view, and sometimes no property is chosen as a caption by default.

To choose it yourself, click on the &quot;Tag&quot; label (the labels are shown in the upper-left of the graph results view), and that should reveal some options at the bottom of the results view for the color and size of the nodes, and which property to use as a caption.

A node&#39;s label won&#39;t be an option for the caption, so if you want the caption to be the label, add a property whose value is the string of the label, and select that as the caption.",0,67324155
2599,https://stackoverflow.com/a/67320130,Adapt query to return correct results,true,"Below is not the exact query that you want because I am using skill name rather than entity_id BUT it can be similar to what you want.

Steps:  
&gt;1) Put required skills and years of experience in one list (rows)
&gt;2) Search each required skills in SkillNode to ensure it is valid
&gt;3) Filter out candidates based on years of experience per Skill
&gt;4) Pick out candidates that have ALL skills in required skills (rows)




    WITH  [
            {name: &quot;Java&quot;, years_of_experience: 5},
            {name: &quot;Spring Boot&quot;, years_of_experience: 1 } 
          ]  AS rows
    UNWIND rows AS row
    MATCH  (skill:SkillNode) WHERE skill.name = row.name
    WITH  rows, row
    // Validate the skills
    MATCH (c:CandidateNode)-[r:KNOWS]-&gt;(s:SkillNode) 
        WHERE s.name  = row.name 
    // Check if the years of experience is good
    WITH c, r, s, rows, row 
        WHERE r.years_of_experience &gt;= row.years_of_experience
    // Check that candidate has ALL skills required 
    WITH c, rows, collect(s) as candidateSkills 
        WHERE ALL(skill in rows WHERE skill.name in [c in candidateSkills|c.name]) 
    RETURN c

    Result:
    ╒════════════════╕
    │&quot;Candidate&quot;     │
    ╞════════════════╡
    │{&quot;name&quot;:&quot;Leo&quot;}  │
    ├────────────────┤
    │{&quot;name&quot;:&quot;Manos&quot;}│
    └────────────────┘

Sample graph:
[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/Gl2xR.png",1,67320130
2600,https://stackoverflow.com/a/67312394,Merge makes my computation very slow as compared to create in neo4j,true,"Since MERGE is like a MATCH (followed by a CREATE if nothing was matched), it benefits from an index, and will suffer if an index doesn&#39;t exist on the properties involved (similar to unindexed MATCHes).

Please create an index (or unique constraint, if it is applicable) on :MyNode(name), then retry your load.",1,67312394
2601,https://stackoverflow.com/a/67305745,"Neo4j, How can I compare dates that stored as strings?",false,"The better way, of course, is to store the date as a temporal property, index it, and then in your predicates on the property compare it to other temporal values.

If you&#39;re stuck with a String property, then it would be best to use strings that afford comparison in YYYY-MM-DD format, as the string comparisons in that format will match temporal comparisons.

Your current format, DD-MM-YYYY, does not afford comparisons to other strings in that format. If you are stuck with this current format for your properties, then as Tomaž said in the comments, you would need to parse this into a type that is comparable (such as by using [apoc.date.parse()](https://neo4j.com/labs/apoc/4.1/overview/apoc.date/apoc.date.parse/) ) which should give you a unix epoch timestamp (long value), and you would similarly need to parse the dates that you are comparing it to so they are all of the same type.

The problem with that approach is that you cannot use indexes here, so you won&#39;t be able to speed up the lookup. So you really should consider either using temporal properties, or at least using strings in a comparable YYYY-MM-DD format.",1,67305745
2602,https://stackoverflow.com/a/67299607,All simple (cyclic) paths query returns too much data -&gt; heap overflow,true,"It&#39;s difficult to give you an exact solution without knowing the data model of your graph, but it may help to use skip/limit to get data in smaller bulks.

This get the first 100 patterns:
```
MATCH p=(n)-[*2..4]-(n) RETURN nodes(p) SKIP 0 LIMIT 100
```
And this the next 100:
```
MATCH p=(n)-[*2..4]-(n) RETURN nodes(p) SKIP 100 LIMIT 100
```",1,67299607
2603,https://stackoverflow.com/a/67305525,Add description or comment to Labels/Relationships,false,"We don&#39;t currently have that kind of meta capability.

You could create your own :MetaRel and :MetaLabel nodes and add in the type/label name and a description property.",0,67305525
2604,https://stackoverflow.com/a/67289797,python asking me for installed modules,true,"If you&#39;re on Windows you can try running the following

    python -c &quot;from distutils.sysconfig import get_python_lib; print(get_python_lib())&quot;
   
then cd to the output of the last command

    dir

look for the neoj4 package and the corresponding version

    cd neo4j-1.x.x/

and finally run


    python3 setup.py install

If you&#39;re a unix based platform try running this.

    $ which python3
    ~/anaconda3/bin/python3
    $ ls
    Anaconda3-2018.12-Linux-x86_64.sh  anaconda3  neo4j-1.7.2  neo4j-1.7.2.tar.gz
    $ cd neo4j-1.7.2/
    $ python3 setup.py install

Also try pip installing `neobolt`",0,67289797
2605,https://stackoverflow.com/a/67288752,WHY DOES neo4j EXPLAIN show thousands of rows with a filter DISTINCT node that is unique?,false,"These are estimated rows calculated before query execution, it does not represent actual rows from the execution (you would use PROFILE to see that).

The estimated rows are exactly that, estimates by considering what is known from the graph via statistics and data from the counts store. 

Since these are calculated before execution, the planner has no idea about the specificity of the property being used for lookup. 

If you really have a unique ID, then you should be creating a unique constraint on it, that way the planner will be able to understand that and produce a more useful estimate. It will also be able to leverage the index (which comes with a unique constraint) to improve the lookup speed. 

Also with such a change, you would no longer need to use DISTINCT since the unique index lookup would guarantee it.",0,67288752
2606,https://stackoverflow.com/a/67288081,Neo4J - Get filtered results based on some property that does not exist,true,"You can&#39;t use equality on null, you need to use `IS NULL`. Please check out the documentation here:

https://neo4j.com/docs/cypher-manual/current/syntax/working-with-null/

As such, you need to add a WHERE clause to your pattern comprehension to get the results you want:

```
[(product)&lt;-[:BELONGSTO]-(image:ProductImage) WHERE image.isUseful IS NULL | image{.*}]
```",1,67288081
2607,https://stackoverflow.com/a/67282690,find maximum weight edge connected to any specific node in neo4j,true,"You should be able to do:


    return d1.name,d2.name,r.weight
    ORDER BY r.weight DESC LIMIT 1;",2,67282690
2608,https://stackoverflow.com/a/67294572,find maximum weight edge connected to any specific node in neo4j,false,"I suspect you may be able to simplify your query (especially if you have an index on the name property for your domain nodes). By the way, labels usually start with an uppercase letter and types for relationships are all uppercased.

    MATCH (google:domain {name: &#39;google&#39;})
    MATCH (google)-[r:domain_join]-(d2:domain)
    RETURN d2.name, r.weight
    ORDER BY r.weight DESC LIMIT 1",1,67294572
2609,https://stackoverflow.com/a/67355567,Neo4j &quot;Tried to execute Write query after executing Schema modification&quot; Error,true,"The error indicated that you can&#39;t combine a schema and a write query in a single transaction.

Split the two queries into two transactions.
In the first transaction define the index, and then in the second transaction create a node.",1,67355567
2610,https://stackoverflow.com/a/67270366,Is it possible to &#39;repeat&#39; a pattern of more than one hop in Cypher?,true,"Currently the APOC approach with relationship sequences is the only option.

```
MATCH (start:Node {id:123})
CALL apoc.path.expandConfig(start, {relationshipFilter:&#39;A,B&#39;}) YIELD path
```

We definitely want the ability to capture repeating sequences, both in this more simple example and in more complex use cases, and there are already design discussions around them. So this isn&#39;t here yet, but it&#39;s only a matter of time to design and implement a good solution.",2,67270366
2611,https://stackoverflow.com/a/67268722,cypher remove null s from result,true,"You used CASE/WHEN (which does not filter out rows) when you should have been using WHERE. 

Also, `size(collect(DISTINCT ))` is really just a `count(DISTINCT )` aggregation, so use that instead. 

Also to avoid confusion, maybe use a different variable name for the count result.

    MATCH (x:Node)-[*1..2]-&gt;(y:Node) 
    WITH x, count(DISTINCT y) AS yCount
    WHERE yCount = 10
    RETURN x.target AS target",1,67268722
2612,https://stackoverflow.com/a/67264888,How to replace values for a certain attribute in Neo4j with a csv file,true,"you first have to match the Person


    LOAD CSV WITH HEADERS FROM &quot;file:///file.csv&quot; AS test
    MATCH (Person:Person{id:test.ID})
    SET Person.Marjor = test.Marjor_text",1,67264888
2613,https://stackoverflow.com/a/67257573,Make all to all relationship among the element present in list in neo4j,false,"You could also achieve that after the import, rather than during by doing something like this

    match (s:Source)-[:TO]-(t:Target)
    with s, collect (t) as targets
    unwind targets as target
    foreach (n in targets | merge (n)-[:r]-(target))",1,67257573
2614,https://stackoverflow.com/a/67269852,Make all to all relationship among the element present in list in neo4j,true,"Unfortunately the Eager operations in the plan will complicate this, making you unable to use USING PERIODIC COMMIT LOAD CSV (which you would need for processing any large CSV).

(more info on [Eager behavior here](https://community.neo4j.com/t/cypher-sleuthing-the-eager-operator/10730))

In Neo4j 4.1 or 4.2 you could use subqueries to get around this, but that will not hold for 4.3 and above.

With subqueries:

    LOAD CSV with headers FROM &#39;file:///sample.csv&#39; AS row
    MERGE (n:MyNode{name:row.source})
    WITH row, n
    CALL {
        WITH row, n
        UNWIND (split(row.target,&#39;|&#39;))  as target
        MERGE (m:MyNode{name:target})
        MERGE (m) -[:TO{weight:row.weight}]-&gt;(n)
        
        WITH collect(m) as targets
        UNWIND targets as t1
        UNWIND targets as t2
    
        WITH t1, t2
        WHERE id(t1) &lt; id(t2)
        MERGE (t1)-[:r]-(t2)  
        
        RETURN true as result
    }
    
    RETURN result


For versions 4.0 and below, subqueries are not available, and with versions 4.3.x (not yet released) and above, subqueries no longer workaround Eager operators, so this won&#39;t work.

Instead, you could use `apoc.cypher.doIt()` in place of the subquery, which will work around the Eager (but you&#39;ll have to work with Cypher query string), or instead you can do 3 passes through your CSV:

First pass to MERGE the source node

Second pass to only split() and MERGE the target nodes.

Third pass to MATCH to both source and targets and MERGE the relationships between them.",1,67269852
2615,https://stackoverflow.com/a/67271133,Make all to all relationship among the element present in list in neo4j,false,"        LOAD CSV with headers FROM &#39;file:///sample.csv&#39; AS row
    MERGE (n:MyNode:domain{name:row.source})
    WITH row, n
    CALL {
        WITH row, n
        UNWIND (split(row.target,&#39;|&#39;))  as target
        MERGE (m:MyNode:token{name:target})
        MERGE (m) -[:TO{weight:row.weight}]-&gt;(n)
        
        WITH collect(m) as targets
        UNWIND targets as t1
        UNWIND targets as t2
    
        WITH t1, t2
        WHERE id(t1) &lt; id(t2)
        MERGE (t1)-[:token_join]-(t2)  
        
        RETURN true as result
    }
    
    WITH n
    CALL{
    WITH n
    match (d1:domain)
    match (d2:domain)
    
    WITH d1,d2
    WHERE id(d1) &lt; id(d2)
    MERGE (d1)-[:domain_join]-(d2)  
    return true as result
    }
    
    match (nodes) return nodes

did little modification in above code....

",0,67271133
2616,https://stackoverflow.com/a/67257606,How to divide the dependency of a node related with two different nodes in neo4j?,false,"You can do that my grouping the actors by movie and end up with a row of movie, [list of actors ]

    MATCH (m:Movie)-[r:require]-&gt;(a :actor)
    WITH m collect(a) as actors
    return m,actors",0,67257606
2617,https://stackoverflow.com/a/67262508,How to divide the dependency of a node related with two different nodes in neo4j?,false,"The visualization logic in Neo4j Browser displays each node only once, therefore you cannot get node 4 two times.
A workaround would be using the neo4j APOC library and return virtual nodes as copies of the blue nodes instead of the real node. If you create two virtual nodes out of node 4, the UI considers them being distinct and therefore show two nodes.",1,67262508
2618,https://stackoverflow.com/a/67911575,How to sync postgres database with neo4j in realtime while using Django-admin?,true,"There are a few routes you could go with this. I think you are going to want to leave Postgres as your main Django database and use Neo4j as an accessory DB, not managed by the Django framework. You can do this by using the Neo4j client library similar to [this post][1] for interfacing with the graph DB yourself. 

To keep Neo4j in sync with the Postgres managed by Django, I think [signals][2] are going to be your best friend, specifically the `post_save` signal. Essentially, anytime that you save a Django model, this signal will fire a function that you can write to use the Neo4j client API to reflect the changes in the graph database. 

However, depending on how complex your models are, this is where it can get tricky determining which fields were changed to only update those. I had a similar issue a while back and used this custom Mixin (I cant find the original author but kept this in my notes): 

```python
from django.forms import model_to_dict
import logging

logger = logging.getLogger(__name__)


class ModelDiffMixin(object):
    &quot;&quot;&quot;
    A model mixin that tracks model fields&#39; values and provide some useful api
    to know what fields have been changed.
    &quot;&quot;&quot;

    def __init__(self, *args, **kwargs):
        super(ModelDiffMixin, self).__init__(*args, **kwargs)
        self.__initial = self._dict

    @property
    def diff(self):
        d1 = self.__initial
        d2 = self._dict
        diffs = [(k, (v, d2[k])) for k, v in d1.items() if v != d2[k]]
        return dict(diffs)

    @property
    def has_changed(self):
        return bool(self.diff)

    @property
    def changed_fields(self):
        return self.diff.keys()

    def get_field_diff(self, field_name):
        &quot;&quot;&quot;
        Returns a diff for field if it&#39;s changed and None otherwise.
        &quot;&quot;&quot;
        return self.diff.get(field_name, None)

    def save(self, *args, **kwargs):
        &quot;&quot;&quot;
        Saves model and set initial state.
        &quot;&quot;&quot;
        super(ModelDiffMixin, self).save(*args, **kwargs)
        self.__initial = self._dict

    @property
    def _dict(self):
        return model_to_dict(self, fields=[field.name for field in
                             self._meta.fields])


```


If you implement this Mixin to your models you with to sync with Neo4j, then inside the `post_save` signal handler you can call `model.diff` or `model.changed_fields` to see which attributes need to be updated on the Neo4j node instead of deleting the entire Node and recreating it and all relationships.


  [1]: https://stackoverflow.com/a/14884691/13272762
  [2]: https://docs.djangoproject.com/en/3.2/topics/signals/",0,67911575
2619,https://stackoverflow.com/a/67213028,How to return the node ID in py2neo (Neo4J &amp; Python),true,"This solved the problem. I hope this will help someone in the future.

    #retreive the ingredient_id of the last added ingredient in the Neo4j db
      def last_ingredient_id():
         ingredient = graph.run(&quot;MATCH (a:Ingredient) RETURN a.ing_id ORDER BY a.ing_id DESC&quot;).to_series()
         result = int(ingredient[0])
         return result",0,67213028
2620,https://stackoverflow.com/a/67214423,neo4j query an array field that has at least one item in the list,false,"I see a couple of ways you could do this. I think the simplest way would be to search for each genre in the list, and then aggregate the results.

    MATCH (c:Customer { name : &quot;Andrei Balanuta&quot; })-[:CLIENT]-(o:Order)-[ol:ORDERLINE]-(b:Book)
    UNWIND b.genre as  g
    WITH DISTINCT g
    MATCH (b:Book)
    WHERE g in b.genre
    RETURN book.isbn, collect(g) AS genre

If you have the APOC library installed, you could also use the [apoc.coll.intersection][1] function. Something like this might meet your need.

    MATCH (c:Customer { name : &quot;Andrei Balanuta&quot; })-[:CLIENT]-(o:Order)-[ol:ORDERLINE]-(b:Book)
    UNWIND b.genre as  g
    WITH collect(distinct g) as customerGenres
    MATCH (b2:Book)
    WHERE size(apoc.coll.intersection(customerGenres, b2.genre)) &gt; 0
    RETURN b2.isbn, b2.genre, customerGenres

Both of the queries above are going to include books that the customer has already bought. If you want to avoid that, you could do something like this.

    MATCH (c:Customer { name : &quot;Andrei Balanuta&quot; })-[:CLIENT]-(o:Order)-[ol:ORDERLINE]-(b:Book)
    WITH COLLECT (b) as customerBooks
    WITH customerBooks, 
    apoc.coll.toSet([book in customerBooks | book.genre]) as customerGenres
    MATCH (b2:Book)
    WHERE size(apoc.coll.intersection(customerGenres, b2.genre)) &gt; 0
    AND NOT b2 in customerBooks
    RETURN b2.isbn, b2.genre, customerGenres

As a final thought, all of these queries are going to have to search every single book in your database to check the genre properties. If query performance starts to bog down, you might consider making genre into a node instead of a property.

  [1]: https://neo4j.com/labs/apoc/4.1/overview/apoc.coll/apoc.coll.intersection/",0,67214423
2621,https://stackoverflow.com/a/67215028,neo4j query an array field that has at least one item in the list,true,"In your actual example, if you have an index on :Book(genre), we can make this an index lookup.

Also we don&#39;t need to use variables that are never going to be reused later.

    MATCH (:Customer { name : &quot;Andrei Balanuta&quot; })-[:CLIENT]-(:Order)-[:ORDERLINE]-(b:Book)
    WITH collect(DISTINCT b.genre) as genres
    MATCH (b:Book)
    WHERE b.genre IN genres
    WITH DISTINCT b as book
    RETURN book.isbn, book.genre

That said, getting all books in all genres matching those of prior ordered books seems a little overkill, maybe a LIMIT or additional filtering would be a good idea.

For your more general example, you can use the any() list predicate

https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-any

    WITH [&#39;Author-1&#39;, &#39;Author-2&#39;, &#39;Author-2&#39;] as p,
     [&#39;Author-1&#39;, &#39;Author-2&#39;] as a,
     [&#39;Author-1&#39;, &#39;Author-2&#39;, &#39;Author-3&#39;, &#39;Author-4&#39;] as b,
     [&#39;Author-4&#39;, &#39;Author-5&#39;, &#39;Author-6&#39;, &#39;Author-7&#39;] as c,
     [&#39;Author-5&#39;, &#39;Author-6&#39;, &#39;Author-7&#39;, &#39;Author-8&#39;] as d,
     [&#39;Author-1&#39;, &#39;Author-2&#39;] as desired
    UNWIND [p, a, b, c, d] as list
    WITH desired, list
    WHERE any(item IN desired WHERE item IN list)
    RETURN list",0,67215028
2622,https://stackoverflow.com/a/67201269,How to find a node quick in Neo4J 3.3.9 - cypher query optimization,false,"adding indexes to the neo4j database would be helpful ( i didnt see any there )  then start your match with the indexed node and traverse from there.    i think that having a 

    MATCH (c:Concept{name:&#39;idea&#39;})-[:AT]-&gt;(ctx)&lt;-[:AT]-(cn:Concept)
    WHERE (ctx)-[:BY]-&gt;(u:User{name:&#39;infranodus&#39;})

....
would also avoid querying twice.
",0,67201269
2623,https://stackoverflow.com/a/67294852,How to find a node quick in Neo4J 3.3.9 - cypher query optimization,false,"Create an index on the name property of nodes with the User label - a unique index would be great for this.
An index for the name property on concept would be good, too (probably without uniqueness constraint - even though you&#39;re looking for distinct nodes explicitly).

Start your query from there.

    MATCH (u:User {name:&#39;infranodus&#39;})
    MATCH (c:Concept {name: &#39;idea&#39;})
    MATCH (u)&lt;-[:BY]-(ctx:Context)&lt;-[:AT]-(c)
    MATCH (c:Concept{name:&#39;idea&#39;})-[:AT]-&gt;(ctx)&lt;-[:AT]-(cn:Concept) 
    RETURN c, ctx, size((c)-[:AT]-&gt;(ctx)&lt;-[:AT]-(:Concept))

Doesn&#39;t look as nice, but you&#39;re asking for query tuning. Make sure to `PROFILE` your existing query and this. Plus, you had a typo in your query after your return keyword.",0,67294852
2624,https://stackoverflow.com/a/67199851,neo4j sum rows with identical fields,true,"You can use [aggregation functions](https://neo4j.com/docs/cypher-manual/current/functions/aggregating/) to get the result you need:

    MATCH (b:Book)&lt;-[ol:ORDERLINE]-()
    UNWIND b.genre as genre
    RETURN genre, sum(ol.amount) as `ol.amount`",2,67199851
2625,https://stackoverflow.com/a/67200771,Get the shortest path from certain node to ANY node of a given label in Neo4J,false,"The [collect][1] function will let you return a single row containing a list of values. 

    MATCH p=shortestPath((selectedNode {name:&#39;X&#39;})-[*]-(y:GivenLabel))
    RETURN length(p) AS l, collect(y.name) as targets
    ORDER BY l
    LIMIT 1

If you want to return the values as individual records, instead of a list, you can use [UWIND][2]. 

    MATCH p=shortestPath((selectedNode {name:&#39;X&#39;})-[*]-(y:GivenLabel))
    WITH length(p) AS l, collect(y.name) as targets
    ORDER BY l
    LIMIT 1
    UNWIND targets as target
    RETURN l, target


  [1]: https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-collect
  [2]: https://neo4j.com/docs/cypher-manual/current/clauses/unwind/",0,67200771
2626,https://stackoverflow.com/a/67215236,Get the shortest path from certain node to ANY node of a given label in Neo4J,false,"If you have APOC Procedures, you can use one of the path expander procs to find a shortest path to a given label and limit it. Unfortunately you&#39;ll need a second call to get multiple nodes of the label at the same distance away.

    // assume we&#39;ve already MATCHed to selectedNode
    ...
    CALL apoc.path.expandConfig(selectedNode, {labelFilter:&#39;/GivenLabel&#39;, limit:1}) YIELD path
    WITH selectedNode, length(path) as pathLength
    CALL apoc.path.subgraphNodes(selectedNode, {labelFilter:&#39;/GivenLabel&#39;, maxLevel:pathLength}) YIELD node
    RETURN node

In the label filter, the prefix of `/` indicates that the label will be used in a termination filter, once it finds the first occurrence it will stop expanding, and use the node as a result. 

The path expander procs use breadth-first expansion by default, so it will be the shortest path from your starting node to a node of the given label. 

`limit:1` ensures that we return after finding the first result (this can be very expensive if there is no such node of the given label, or if it&#39;s far away, so you might consider providing a `maxLevel` as an upper bound).

We make a similar path expander call (subgraphNodes(), since we no longer need the path, just the node at the end) using the length of the path found previously as our maxLevel, that will return all nodes with the given label at that distance.",0,67215236
2627,https://stackoverflow.com/a/67291187,Understanding apoc.refactor.mergeNodes,false,"Can you provide example of structure of your database, and explain a bit better your end goal? Are you actually trying to create a node from many, or are you just trying to collect information from 886 nodes (something like this:)
```
MATCH (node)
RETURN DISTINCT node.pat_id as ids, collect(node.date) as dates
```
It would be better to keep your patient nodes and date nodes separate, then it&#39;s easy to get a list of all the date nodes per patient (including duplicates).

",0,67291187
2628,https://stackoverflow.com/a/68048723,Neosemantics: Linking ontology and label property graph,false,"The GraphConfig is only needed when you are going to store RDF data into Neo4j but if you&#39;re working with a &quot;native&quot; property graph you don&#39;t need it.

You can get rid of it running `call n10s.graphconfig.drop();`

Once you&#39;ve done that your POST request to the cypher/RDF endpoint should return the expected results serialised as RDF/XML",0,68048723
2629,https://stackoverflow.com/a/68891528,Neo4j - Unable to run multiple cypher files with Neo4J Docker 4.2.5,true,"This has been resolved. It seems the issue was the wrong documentation on how to run multiple cypher queries. Please check [this][1] link for more details 


  [1]: https://github.com/neo4j-contrib/neo4j-apoc-procedures/issues/2120",0,68891528
2630,https://stackoverflow.com/a/67176002,How to write user defined functions and stored procedure query of cipher of neo4j in .net core?,true,"The fluent api contains everything you need here, so:

```
await client.Cypher.Call(&quot;apoc.load.json(&#39;url&#39;)&quot;).Yield(&quot;value&quot;)
        .Unwind(&quot;value.learningPaths&quot;, &quot;val&quot;)
		.Merge(&quot;(n:learningPaths {id:val.uid})&quot;)
		.Set(@&quot;n.modified = val.last_modofied,
	                 n.type     = val.type,
	                 n.locale   = val.locale,
	                 n.childrens= val.number_of_children,
	                 n.summary  = val.summary,
	                 n.minutes  = val.duration_in_minutes,
	                 n.title    = val.title,
	                 n.levels = val.levels,
	                 n.roles = val.roles,
	                 n.modules = val.modules,
	                 n.products = val.products&quot;)
					 .ExecuteWithoutResultsAsync();
```

What I might look at if I were you is whether you can just shorten the `SET` to just use `=` to set all the properties:

```
await client.Cypher.Call(&quot;apoc.load.json(&#39;url&#39;)&quot;).Yield(&quot;value&quot;)
		.Merge(&quot;(n:learningPaths {id:val.uid})&quot;)
		.Set(@&quot;n = val&quot;)
    	.ExecuteWithoutResultsAsync();
```

Or maybe a `+=` if you need it to be additive:

```
await client.Cypher.Call(&quot;apoc.load.json(&#39;url&#39;)&quot;).Yield(&quot;value&quot;)
		.Merge(&quot;(n:learningPaths {id:val.uid})&quot;)
		.Set(@&quot;n += val&quot;)
    	.ExecuteWithoutResultsAsync();
```

It&#39;s going to depend on what exactly `val` has though, have a read through of the [SET](https://neo4j.com/docs/cypher-manual/current/clauses/set/) documentation (maybe [Replacing Properties](https://neo4j.com/docs/cypher-manual/current/clauses/set/#set-replace-properties-using-map) or [Mutating properties](https://neo4j.com/docs/cypher-manual/current/clauses/set/#set-setting-properties-using-map)).

",0,67176002
2631,https://stackoverflow.com/a/67148552,"CREATE works in this statement, but MERGE does&#39;t. What&#39;s going on here?",false,"At this time in Neo4j 4.2.x, MERGE does not support comma-separated patterns, though there is a feature request in the backlog to add that capability.",1,67148552
2632,https://stackoverflow.com/a/67148576,"CREATE works in this statement, but MERGE does&#39;t. What&#39;s going on here?",false,"MERGE does not support comma separation. A workaround is to add the `MERGE` keyword in front of every node/relation etc.

The below query works:

```
CREATE (n:TestEntity), (m1:RelatedEntity)
WITH n,m1
MERGE (m2:RelatedEntity {b:&quot;c&quot;})
WITH n,m1,m2
MERGE (n)-[:REL]-&gt;(m1) MERGE (n)-[:REL]-&gt;(m2)
SET n+={a:1}, m1+={b:&quot;d&quot;}, m2+={d:2}
return n, m1,m2;
```",0,67148576
2633,https://stackoverflow.com/a/67141938,How to make a &#39;blueprint&#39; of all possible relationships and nodes in Neo4J with Cypher?,true,"It seems the Neo4j built-in procedure `db.schema.visualization()` is what you&#39;re looking for : https://neo4j.com/docs/operations-manual/current/reference/procedures/#procedure_db_schema_visualization

Example : 

[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/ew3BQ.png",0,67141938
2634,https://stackoverflow.com/a/67133738,Neo4j-graphql-js -- Is there a way to check if an optional parameter exists or is not null?,false,"If you use a parameter in the query, then the parameter is required.

The best way to mimic optional parameters is to pass a map parameter, and use the entries in the map.

For example, if you pass in:

$myParams = {externalUrls:null, someOtherEntry:1, etc:true}

Then you can reference: `$myParams.externalUrls`, or use a WHERE clause on it, or a CASE, to take some action on it for whether it&#39;s null or not.",0,67133738
2635,https://stackoverflow.com/a/67130648,After upgrading py2neo version code is giving errors,false,"There is a mismatch between the py2neo version and the Neo4j version here. Upgrading to py2neo version 4.anything will still give you a version that is several years old, built for the Neo4j of that time. Since then, the parameter syntax has changed, so you cannot use a driver that old with a more recent version of Neo4j.

Upgrade to a far more recent version of py2neo instead.",0,67130648
2636,https://stackoverflow.com/a/67132043,How can i get duplicate node CYPHER Neo4j,false,"In Cypher, when you aggregate (for the straight-forward cases) the grouping key is formed from the non-aggregation terms.

If nodes have already been created from the input (let&#39;s say they&#39;re using the label :Entry), then we can get the output you want with this:

    MATCH (e:Entry)
    RETURN e.name as name, count(e) as count

The grouping key here is `name`, which becomes distinct as the result of the aggregation. The result is a row for each distinct `name` value and the count of nodes with that name.",0,67132043
2637,https://stackoverflow.com/a/67117884,Cypher query problem when trying to find max of a returned column under certain relation id,false,The problem was returned result was string type and `max()` was calculating maximum between `strings` instead of `int`. ,0,67117884
2638,https://stackoverflow.com/a/67113085,How to SET dynamic property within a foreach?,false,"You can use UNWIND to get a row per element in the list, filter for if the key doesn&#39;t exist, then use APOC to set it.

    MATCH (n:Label {id: {id}})
    MERGE (n)-[rel:HAS_RELATIONSHIP]-&gt;(UniqueNode:UniqueLabel)
    WITH rel
    UNWIND [&quot;DynamicProp1&quot;, &quot;DynamicProp2&quot;, &quot;DynamicProp3&quot;, &quot;LongListWouldRatherNotDoOneAtATime&quot;] as propKey
    WITH rel, propKey
    WHERE NOT EXISTS(rel[propKey])
    CALL apoc.create.setRelProperty(rel, propKey, false)
    RETURN count(*)",1,67113085
2639,https://stackoverflow.com/a/69031780,Unable to resolve connection to Neo4j database from AWS Lambda,false,"I encountered this problem with a nodejs version of AWS Lambda.

The problem is public Lambdas will not be able to route to the EC2 instance running neo4j. The lambda must be deployed in a VPC that has a route back to the EC2 instance running neo4j.

The second benefit is the security group for the EC2 instance can be set to allow only CIDR ranges from the VPC that the lambda is deployed in.",1,69031780
2640,https://stackoverflow.com/a/67142468,How to optimise neo4j cypher query for high size graph?,true,"First, your query plan shows you aren&#39;t using indexes, so it&#39;s using a NodeByLabelScan for :T059 nodes and running a filter on all of them to find those with the property in question. The `src` node also isn&#39;t using an index lookup, instead the results of the variable-length expand are filtered for the label and property.

You will need indexes on these to help improve performance. Indexes on `:T047(CUI)` and `:T059(CUI)` are the ones you need here. Make sure you have this first.

Also, to force index lookup (as opposed to a var-length-expand and filter, which would be more expensive) you can provide index hints to the planner.

We can also adjust the list predicate for labels on nodes in the path such that they will be filtered during expansion instead of afterward.

    WITH [&quot;T004&quot;, &quot;T005&quot;, &quot;T007&quot;, &quot;T016&quot;, &quot;T017&quot;, &quot;T018&quot;, &quot;T019&quot;, &quot;T020&quot;, &quot;T021&quot;, &quot;T022&quot;, &quot;T023&quot;, &quot;T024&quot;, &quot;T025&quot;, &quot;T026&quot;, &quot;T028&quot;, &quot;T029&quot;, &quot;T030&quot;, &quot;T031&quot;, &quot;T032&quot;, &quot;T033&quot;, &quot;T034&quot;, &quot;T037&quot;, &quot;T038&quot;, &quot;T039&quot;, &quot;T040&quot;, &quot;T041&quot;, &quot;T042&quot;, &quot;T043&quot;, &quot;T045&quot;, &quot;T046&quot;, &quot;T047&quot;, &quot;T048&quot;, &quot;T049&quot;, &quot;T053&quot;, &quot;T054&quot;, &quot;T055&quot;, &quot;T056&quot;, &quot;T057&quot;, &quot;T059&quot;, &quot;T060&quot;, &quot;T061&quot;, &quot;T074&quot;, &quot;T080&quot;, &quot;T081&quot;, &quot;T098&quot;, &quot;T099&quot;, &quot;T100&quot;, &quot;T101&quot;, &quot;T103&quot;, &quot;T109&quot;, &quot;T114&quot;, &quot;T116&quot;, &quot;T121&quot;, &quot;T123&quot;, &quot;T125&quot;, &quot;T126&quot;, &quot;T127&quot;, &quot;T129&quot;, &quot;T131&quot;, &quot;T168&quot;, &quot;T184&quot;, &quot;T190&quot;, &quot;T191&quot;, &quot;T195&quot;, &quot;T196&quot;, &quot;T197&quot;, &quot;T200&quot;, &quot;T201&quot;] as allowedLabels
    MATCH (src:T047 {CUI:&quot;C0030920&quot;}), 
          (trg:T059 {CUI:&quot;C1294944&quot;})
    USING INDEX src:T047(CUI)
    USING INDEX trg:T059(CUI)
    MATCH p = (src)-[*..3]-(trg)
    WHERE 
          all(relI in relationships(p) WHERE type(relI) in [&quot;RO&quot;,&quot;CHD&quot;,&quot;PAR&quot;,&quot;RB&quot;,&quot;RL&quot;,&quot;RO&quot;,&quot;SIB&quot;,&quot;RU&quot;,&quot;SY&quot;])
        AND all(node IN nodes(p) WHERE labels(node)[0] IN allowedLabels)
    RETURN p

This also assumes that all the nodes here only have one possible label, and not multiple. If they can have multiple labels, then we may need to restructure the query.",0,67142468
2641,https://stackoverflow.com/a/67126247,ModuleNotFoundError while updating py2neo 3.1.2 to py2neo 4.0.0,true,"The new version 4 of py2neo is NOT requiring http but instead using bolt. I replaced all your missing modules with a working version in py2neo. See my example below;

    #from py2neo.database.status import ConstraintError
    from py2neo  import ClientError, GraphError
    #from py2neo.packages.neo4j.v1.exceptions import ProtocolError
    from py2neo  import DatabaseError, TransientError, TransactionError
    #from py2neo.packages.httpstream import http  &lt;-- http is replaced by bolt connection
    from py2neo import Graph

    print(&quot;py2neo version: &quot;, py2neo.__version__)
    graph = Graph(&quot;bolt://localhost:7687&quot;, auth=(&quot;neo4j&quot;, &quot;****&quot;))
    query = &quot;&quot;&quot;&lt;Invalid&gt; RETURN $x as number, $x*$x as squared; &quot;&quot;&quot;
    try:
        cursor = graph.run(query, x=12)
        for record in cursor:
            print(&#39;The square of&#39;, record[&quot;number&quot;], &#39;is&#39;, record[&quot;squared&quot;])
    except (ClientError, GraphError) as ex:
        print(&#39;Client Graph error: \n&#39;, ex)
    except (DatabaseError, TransientError, TransactionError) as ex:
        print(&#39;DatabaseError error: \n&#39;, ex)
        
    #references: https://py2neo.org/v4/index.html
    #https://dzone.com/articles/introducing-bolt-neo4js-upcoming-binary-protocol-p

     RESULT:
     py2neo version:  4.2.0
     The square of 12 is 144",1,67126247
2642,https://stackoverflow.com/a/67177792,Retreiveing Relationship in Neoj4Client gives Deserialization exception,false,"With the relationships, to get the properties, you just need to supply a standard POCO, so instead of your `Hop` class, you should go for:

```
public class Hop
{
    [JsonProperty(&quot;cost&quot;)]
    public long? Cost {get;set;}
}
```

which changes your query to:

```
var createQueryTask = client
    .Cypher
    .Match(&quot;matched=(a:Technology{name:{to},title:{level}})&lt;-[rel:HOP]-(b:Technology{name:{from},title:{level}})&quot;)
    .WithParams(new { to = &quot;ArangoDB&quot;, level = &quot;Junior&quot;, from = &quot;Big Table&quot;})
    .Return(rel =&gt; rel.As&lt;Hop&gt;()).ResultsAsync;
```
",1,67177792
2643,https://stackoverflow.com/a/67121722,"How to resolve &quot;Neo4j returned a valid response, however Neo4jClient was unable to deserialize into the object structure you supplied.&quot; error?",true,"The query you&#39;re writing will not return anything, what you&#39;re actually executing is:

```
MATCH (show databases)
RETURN n
```

You can see this if you change your code to look like this:

```
var query = _graphClient.Cypher.Match(@&quot;show databases&quot;)
		   .Return((n) =&gt; n.As&lt;string&gt;());
		   
var text = query.Query.DebugQueryText;
var result = await query.ResultsAsync;
```

If you put a breakpoint in so you can see what the `text` variable will be you&#39;ll be able to see it.

Now! I can&#39;t think how to get what you want when you&#39;re using the `GraphClient` - it might be possible with the `BoltGraphClient` - but the error you&#39;re getting implies you&#39;re using the former.

IF you were on the `BoltGraphClient`, you _could_ access the `Driver` and execute:

```
var session = ((BoltGraphClient)_graphClient).Driver.AsyncSession(d =&gt; d.WithDatabase(&quot;system&quot;));
var cursor = await session.RunAsync(&quot;SHOW DATABASES&quot;);
while (await cursor.FetchAsync())
{
	var name = cursor.Current.Values[&quot;name&quot;].As&lt;string&gt;();
	var status = cursor.Current.Values[&quot;currentStatus&quot;].As&lt;string&gt;();
	Console.WriteLine($&quot;{name} is {status.ToUpperInvariant()}&quot;);
}
```

I don&#39;t know any other work around with the http `GraphClient` - it would need to be added to the client. In theory - it&#39;s not a complex PR to do if you wanted to. ",0,67121722
2644,https://stackoverflow.com/a/67084740,Neo4J Cypher: Match ()-[]-() Return count(*) return double of the number of the relationships when node labels are not assigned,false,"Cypher is about returning paths that match patterns.

Paths are **ordered** sequences of nodes and relationships, and when no direction is specified, and no labels are specified, then a pattern like that will produce two paths using the same relationship and the same two nodes, just the order of the nodes in the path is different, and you traverse the relationship in the other direction.

If you add a direction to the pattern, then only one path is possible:

    MATCH ()-[:awithb]-&gt;() 
    RETURN count(*)",1,67084740
2645,https://stackoverflow.com/a/67092944,Neo4J Cypher: Match ()-[]-() Return count(*) return double of the number of the relationships when node labels are not assigned,false,"When you put no labels on your query, it means that you want ANY nodes that have that relationship. 

     () - [: awithb] - ()  where () is any nodes 

When you put non-directional path with corresponding labels; it means the relationship can be from A to B or B to A. 

     (:A) - [: awithb] - (:B) equals  A-&gt;B  OR  A&lt;-B

Thus, in your first query, you are getting 2x the counts because you are getting the path  from A to B and B to A.",0,67092944
2646,https://stackoverflow.com/a/67079552,Use optional cypher query results in subsequent query and combine results,true,"As InverseFalcon said in the comment section, UNWIND is like a &#39;for loop&#39; for of a list.  You can re-write your query as below.

    MATCH (n:KnowledgeEntry {id: &#39;d0634a24-91d0-4fd7-8868-2caa3ab0dc7a&#39; })
    WITH n
    OPTIONAL MATCH (n)-[r:IS_PART]-&gt;(p:KnowledgeEntry)
    WITH n, p, r
    OPTIONAL MATCH (n)&lt;-[ch:IS_PART*1..2]-(d:HierarchicalKnowledgeEntry)
    WITH n, p, d, r, ch
    WITH (collect(DISTINCT n) + collect(DISTINCT p) + collect(DISTINCT d)) as  nodes, collect(DISTINCT r)  as parentRelation, collect(DISTINCT ch) as childRelation
    UNWIND nodes AS n
    OPTIONAL MATCH (n)-[r:CONTEXTUAL_KNOWLEDGE]-(c:ContextualKnowledgeEntry)
    WITH n as node, parentRelation, childRelation, c AS contextualNode, r as contextualRelation
    WITH collect(DISTINCT node) + collect(DISTINCT contextualNode) as knowledgeEntries, parentRelation + childRelation + collect(distinct contextualRelation) as edges
    return knowledgeEntries, edges",1,67079552
2647,https://stackoverflow.com/a/67074173,Neo4j high db hits,true,"Create an index for the property `id` on `User`,

    CREATE INDEX user_id FOR (n:User) ON (n.id)

This should certainly speed your queries",1,67074173
2648,https://stackoverflow.com/a/67065443,Neo4j cypher query doesn&#39;t return the results as expected into pandas DataFrame,false,"Although I don&#39;t like that this seems to be the best solution it should solve the issue you are having:

    def get_objects(x):
        query = &#39;&#39;&#39; MATCH (p)-[r]-&gt;(a) where r.id = {} RETURN p.id; &#39;&#39;&#39;.format(int(x))
        resultNodes = session.run(query)
        df = DataFrame(resultNodes)
        print(df)
        return df
    
    def find_max_1():
        authors,terms,venues,papers=0,0,0,0
        authors=get_objects(1).max()
        terms=get_objects(2).max()
        venues=get_objects(3).max()
        papers=get_objects(4).max()
        return authors,terms,venues,papers
    
    def main():
        
        m = m=find_max_1()
        
    
    if __name__ == &quot;__main__&quot;:
        
        main()

I&#39;ve added the casting of x to an int to try and provide some added injection security. I believe there is a function for the sanitisation of queries in the library somewhere.",0,67065443
2649,https://stackoverflow.com/a/67080222,Neo4j cypher query doesn&#39;t return the results as expected into pandas DataFrame,false,"Below code works for me.  When you pass integer to the parameter, it will be passed as integer, if string then string.  Moreover, to convert the result into a dataframe, you need to get the values per record and keys as column names.  See below.

    from neo4j import GraphDatabase
    from pandas import DataFrame
    
    x = 88888
    query = &#39;&#39;&#39; MATCH (p)-[r]-&gt;(a) where r.id = $x RETURN p.id; &#39;&#39;&#39;
    
    driver = GraphDatabase.driver(uri, auth=(&quot;neo4j&quot;, &quot;*****&quot;))
    session = driver.session()
    result = session.run(query, x=x)

    #below is important !!!
    rows  = [r.values() for r in result]
    cols = result.keys()

    df = DataFrame(data=rows, columns=cols)
    print(df)
    session.close()
    driver.close()

    Result:
             m.ID
    0   987654321",0,67080222
2650,https://stackoverflow.com/a/67052497,Database creation takes to long in neo4j,false,"You are starting with a CSV file, right? You could use LOAD CSV to bring it into Neo4j. Use your python code to put the csv in the Neo4j Import directory. Then run this query ...

    LOAD CSV With HEADERS FROM &#39;file:///ratings_small.csv&#39; AS line FIELDTERMINATOR &#39;,&#39; MERGE(m:Movie{MovieId: toInteger(line.mID)})
        &#39;&#39;&#39;, parameters = {&#39;mID&#39;: toInteger(line.movieID),rating:toFloat(line.rating)})

You can add this at the start if you want to iterate 5000 rows at a time

    Using periodic commit 5000 ....

This should run much faster!
",0,67052497
2651,https://stackoverflow.com/a/67063748,Database creation takes to long in neo4j,true,"Every `graph run` call represents not only a full round trip to the server, but a completely separate transaction. Working like this, with one such call inside every cycle of the loop, is therefore incredibly inefficient.

I suggest instead taking a look at the bulk data operations API:
https://py2neo.readthedocs.io/en/stable/bulk/index.html",1,67063748
2652,https://stackoverflow.com/a/67045476,How to Create a Chain of Nodes Depending on a Property in Cypher,false,"The following code does the trick:
```
MATCH(cs:channel)
UNWIND cs AS Channel
    MATCH(msgs)&lt;-[:contains]-(Channel)
    WITH Channel, msgs ORDER BY msgs.ts 
    WITH collect(msgs.ts) as msgtimeline, count(msgs) as nom, Channel
    FOREACH(i IN RANGE(1,nom-1)|
        MERGE(prvsmsg{ts:msgtimeline[i-1], channel:Channel.name})
        MERGE(nxtmsg{ts:msgtimeline[i], channel: Channel.name})
        MERGE(prvsmsg)&lt;-[rel:follows]-(nxtmsg)
        set rel.delta_t = toFloat(nxtmsg.ts)-toFloat(prvsmsg.ts)
        )
```

The difference is that I used the ORDER BY clause on a property of a bunch of nodes and created the list for the FOREACH statement afterwards.
Why this makes such a big difference remains a mystery for me though.",0,67045476
2653,https://stackoverflow.com/a/67038975,Neo4j: Create a list of items when contain another item,true,"If you really want 0&#39;s for when the values aren&#39;t equal, and 1&#39;s for when they are, you can use a list extraction using CASE to handle the output:

    WITH [&#39;Item 12&#39;, &quot;Item 23&quot;, &quot;Item 7&quot;, &quot;Item 562&quot;, &quot;Item 346&quot;, &quot;Item 85&quot;] as buy1, &quot;Item 346&quot; as item
    RETURN [i in buy1 | CASE WHEN i = item THEN 1 ELSE 0 END] as output 

EDIT: If your input is a list of items, and not just a single item, then we can use a list membership check (using `IN`) to decide when to output 1 or 0:

    WITH [&#39;Item 12&#39;, &quot;Item 23&quot;, &quot;Item 7&quot;, &quot;Item 562&quot;, &quot;Item 346&quot;, &quot;Item 85&quot;] as buy1, [&quot;Item 346&quot;, &quot;Item 7&quot;] as items
    RETURN [i in buy1 | CASE WHEN i IN items THEN 1 ELSE 0 END] as output ",1,67038975
2654,https://stackoverflow.com/a/67070556,Neo4j shortestPath does not work in reverse,true,"When you `create` the gds graph you should configure it using the appropriate `orientation` property, in your case `UNDIRECTED`.

    CALL gds.graph.create(
        &#39;myGraph&#39;,
        &#39;Location&#39;,
        {
            UNDIRECTED_ROAD: {
                type: &#39;ROAD&#39;,
                orientation: &#39;UNDIRECTED&#39;
            }
        },
        {
        	relationshipProperties: &#39;cost&#39;
        }
    )",1,67070556
2655,https://stackoverflow.com/a/67035933,Neo4j max function,true,"The sandbox you refer to only contains a single Ubuntu `OS`, so naturally the result only returns a single record with that node. It is a bit tricky because the value of the node property `versions` is in itself a list.

`max` is an aggregation function which is applied to result (not the value of a SINGLE property).

Imagine having 3 nodes matching `WHERE os.name = &quot;Ubuntu&quot;` with individual versions. It can be simulated like the following:

```
UNWIND [[&quot;14.04&quot;, &quot;16.04&quot;, &quot;16.10&quot;, &quot;17.04&quot;],
        [&quot;18.04&quot;, &quot;18.10&quot;, &quot;19.04&quot;, &quot;19.10&quot;],
        [&quot;20.04&quot;, &quot;20.10&quot;, &quot;21.04&quot;, &quot;21.10&quot;]] AS versions
RETURN max(versions)
```
which will return: `[&quot;20.04&quot;, &quot;20.10&quot;, &quot;21.04&quot;, &quot;21.10&quot;]`.

If you are indeed interested in the individual versions on a specific node it can be achived with unwind:

```
MATCH (os:OS) WHERE os.name = &quot;Ubuntu&quot;
UNWIND os.versions as version
RETURN max(version)
```
which will return `&quot;17.04&quot;`.",3,67035933
2656,https://stackoverflow.com/a/67032037,Difficulty using UNWIND in Neo4j,true,"The problem is with this line:

    WITH collect(n) AS nodes

You&#39;ve matched to all :OUTPT nodes with a sequence number within 1-31, but then you aggregate them into a single large collection, then merge them into a single node.

If you want to collect the nodes according to the sequence number, then the sequence number (in your case, `cnt`) needs to be the grouping key of the aggregation:


    WITH cnt, collect(n) AS nodes

That will get you a row per distinct `cnt` value, with the list of nodes with the same count on the associated row.

Because Cypher operations execute per row, your APOC refactor call will execute per row. Because each row is associated with a different cnt value, and each has a different list, you will be performing the refactoring for each list separately.

The output will be one row per cnt value, with a single node per row (as a result of merging all the nodes in that row&#39;s list into a single node).",0,67032037
2657,https://stackoverflow.com/a/67049128,Multi-level full-text search in Neo4j,true,"You best use [subqueries][1] if using Neo4j 4.1+ : 

```
CALL {
    CALL db.index.fulltext.queryNodes(&quot;first_name&quot;, &quot;manas~&quot;) 
    YIELD node, score
    RETURN node, score

    UNION ALL
    CALL db.index.fulltext.queryNodes(&quot;aliases&quot;, &quot;boncha~&quot;) 
    YIELD node, score
    RETURN node, score
}
RETURN node, sum(score) AS totalScore
ORDER BY totalScore DESC
```

For the intersection, you can count per node how many matches they have, so if they have been matched in the two queries, it will be a count of two : 

```
CALL {
    CALL db.index.fulltext.queryNodes(&quot;first_name&quot;, &quot;manas~&quot;) 
    YIELD node, score
    RETURN node, score

    UNION ALL
    CALL db.index.fulltext.queryNodes(&quot;aliases&quot;, &quot;boncha~&quot;) 
    YIELD node, score
    RETURN node, score
}
WITH node, count(*) AS matches, sum(score) AS totalScore
WITH node, matches, totalScore
WHERE matches = 2
ORDER BY totalScore DESC
RETURN node, totalScore
```



  [1]: https://neo4j.com/docs/cypher-manual/current/clauses/call-subquery/",1,67049128
2658,https://stackoverflow.com/a/67025160,Spring does not find the symbol @QueryResult,false,"I assume you are using (the latest release of) Spring Boot.
In that case, you are using Spring Data Neo4j 6 and `@QueryResult` is not defined anymore. You can achieve projections as described [there][1].


  [1]: https://docs.spring.io/spring-data/neo4j/docs/current/reference/html/#projections",0,67025160
2659,https://stackoverflow.com/a/67021676,Py2neo updateing existing node,false,"Apparently the solution was to just remove the &#39;t&#39; from the function call

```graph_db.update_node(node_name=&#39;Andrei&#39;, node_group=&#39;Person&#39;, property_update={&#39;name&#39;: t[&#39;Updated&#39;]}```

so now it&#39;s:
```
graph_db.update_node(node_name=&#39;Andrei&#39;, node_group=&#39;Person&#39;, property_update={&#39;name&#39;: [&#39;Updated&#39;]}
```

Honestly IDK why it didn&#39;t work with the other function call
",0,67021676
2660,https://stackoverflow.com/a/67021225,Match on relationship py2neo ogm,true,"The relationship can be added in the Model object.
```python
from py2neo.ogm import Model, Property, RelatedFrom
class Feed(Model):
    name = Property(&quot;name&quot;)
    url = Property(&quot;url&quot;)

    subscribers = RelatedFrom(&quot;User&quot;, &quot;SUBSCRIBED&quot;)
    items = RelatedFrom(&quot;FeedItem&quot;, &quot;SOURCE&quot;)
```
Then the query can be simplified from:

    FeedItem.match(graph).where(&quot;(_)-[:SOURCE]-&gt;(:Feed {url:\&quot;%s\&quot;})&quot;%feed.url)
to

    feed.items



",0,67021225
2661,https://stackoverflow.com/a/67015916,Neo4j randomly high CPU,false,"Run a CPU profiler such as [`perf`](http://www.brendangregg.com/perf.html) to record where CPU time is spent. You can then visualize it as a [FlameGraph](http://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html) or, since your bursts only occur at random intervals, visualize it over time with Netflix&#39; [FlameScope](https://github.com/Netflix/flamescope)

Since Neo4j is a Java application, it might also be worthwhile to have a look at [`async-profiler`](https://github.com/jvm-profiling-tools/async-profiler/) which is priceless when it comes to profiling Java applications (and it generates similar FlameGraphs and can output log files compatible with FlameScope or JMC)",1,67015916
2662,https://stackoverflow.com/a/68474250,neo4j : Unable to get a routing table for database &#39;fabric.xxx&#39; because this database does not exist,false,try &quot;newfabric.january2020&quot; in the query.,0,68474250
2663,https://stackoverflow.com/a/67019350,CREATE RELATIONSHIP in cypher based on a conditions,false,"My comments is that not all tools are suitable for all problems. Use the right tool for the job. 

I would take your pseudo code and write the solution in another language (Java, Python, even BASH), and have this write to the DB. That way you can easily test it before hand to make sure the code is doing what you expect. 

",0,67019350
2664,https://stackoverflow.com/a/67007135,Create nodes conditionally when loading nodes from csv in Neo4j,false,"I highly recommend to pre-parse the csv file into separate files for each label. It will make the cypher for import so much easier. In the following I use a little trick by wrapping the CASE command inside a FOREACH:

    load csv from &quot;file:///test.csv&quot; as line
    foreach (i in case when line[0] = &#39;0&#39; then [1] else [] end | 
      merge (p:Person {id: line[1]}) set p.name = line[2] )
    foreach (i in case when line[0] = &#39;1&#39; then [1] else [] end | 
      merge (c:Car {id: line[1]}) set c.name = line[2], c.color = line[4] )
    foreach (i in case when line[0] = &#39;2&#39; then [1] else [] end | 
      merge (b:Boat {id: line[1]}) set b.name = line[2] )

Also, don&#39;t forget to add indexes on the properties you are merging on.",0,67007135
2665,https://stackoverflow.com/a/67000782,How can i fail Neo4j transaction if validation query fails,true,"You could use [apoc.util.validate](https://neo4j.com/labs/apoc/4.1/overview/apoc.util/apoc.util.validate/) to throw an error from inside cypher. 

Example: 

```cypher
CALL apoc.util.validate(true, &quot;MY ERROR MESSAGE&quot;)
```",2,67000782
2666,https://stackoverflow.com/a/66990420,Unwinding two lists and matching row indices together?,false,"You can iterate thru each item in meta1 and meta2 and combine them into one collection.  I don&#39;t have a copy of your own query so ensure that both m1 and m2 are collections.

&gt;1. Define m1 and m2 as collections
&gt;2. Iterate from each items in the list m1 and m2 then concatenate each items
&gt;3. Return the data per row

    WITH [&#39;SPAT&#39;, &#39;TNAVPS&#39;, &#39;UPBT&#39;] AS m1, [273.3, 192.1, 2.97] AS m2
    WITH [i in range(0, size(m1)-1) | &#39;value of &#39; + toString(m1[i]) + &#39; is &#39; + toString(m2[i])] as allMeta
    UNWIND allMeta as meta
    RETURN meta

    Result:
    ╒══════════════════════════╕
    │&quot;meta&quot;                    │
    ╞══════════════════════════╡
    │&quot;value of SPAT is 273.3&quot;  │
    ├──────────────────────────┤
    │&quot;value of TNAVPS is 192.1&quot;│
    ├──────────────────────────┤
    │&quot;value of UPBT is 2.97&quot;   │
    └──────────────────────────┘
",0,66990420
2667,https://stackoverflow.com/a/66980649,Can&#39;t use the added function in Repository,false,"As your exception states, no record is returned from Neo4j and thus it cannot be mapped to a Boolean.

Best would be to use `Optional&lt;User&gt;` and check with `isPresent()`

```
@Query(&quot;MATCH (n:User {username: $username}) RETURN n&quot;)
Optional&lt;User&gt; existsForUsername(String username);
```

That said, it is already handled by Spring Data without using a custom query : 

```
boolean existsByUsername(String username);
```

Reference : https://docs.spring.io/spring-data/neo4j/docs/current/reference/html/#appendix.query.method.subject

",1,66980649
2668,https://stackoverflow.com/a/66990419,Can&#39;t use the added function in Repository,false,"There is a rather obscure set of references on github site for the NEO4J Spring Data: [here][1]


  [1]: https://jira.spring.io/projects/DATAGRAPH/issues/DATAGRAPH-1472?filter=allopenissues

It seems that the existsBy property was omitted. It is being fixed, but whether that has made it to the Spring Data repository is another matter. You don;t say which version of the Spring-boot-starter-neo4j you are using, but you may care to use this one and see if it works; 

    &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-neo4j --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-data-neo4j&lt;/artifactId&gt;
        &lt;version&gt;2.4.4&lt;/version&gt;
    &lt;/dependency&gt;

",0,66990419
2669,https://stackoverflow.com/a/67027111,Can&#39;t use the added function in Repository,false,"In general, the other answers here are right. But, if you&#39;re using Spring Boot 2.4.4, OGM is no longer supported. It now uses a model called SDN (or at least it was when it was under development). You may just have a dependency issue.  Here&#39;s part of my Gradle build file, these should be all the dependencies you need:

```
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
	application
	id(&quot;org.springframework.boot&quot;) version &quot;2.4.4&quot;
	id(&quot;io.spring.dependency-management&quot;) version &quot;1.0.10.RELEASE&quot;
}

java.sourceCompatibility = JavaVersion.VERSION_11

configurations {
	compileOnly {
		extendsFrom(configurations.annotationProcessor.get())
	}
}

repositories {
	mavenCentral()
}

dependencies {
	implementation(&quot;org.springframework.boot:spring-boot-starter-actuator&quot;)
	implementation(&quot;org.springframework.boot:spring-boot-starter-data-neo4j&quot;)
	implementation(&quot;org.springframework.boot:spring-boot-starter-security&quot;)
	implementation(&quot;org.springframework.boot:spring-boot-starter-web&quot;)
}

```",0,67027111
2670,https://stackoverflow.com/a/66954491,How to load yelp dump file in neo4j desktop?,false,"The feature that you are looking for is not yet available for Neo4j desktop Windows version. See below community thread discussion then scroll at the bottom.

&gt; https://community.neo4j.com/t/missing-create-new-dbms-from-dump-yelp-dataset/29393",0,66954491
2671,https://stackoverflow.com/a/66951367,Errors during configuration of the neo4j django-neomodel,true,"Well, after some research I&#39;ve found this post https://stackoverflow.com/questions/64308828/docker-compose-db-connection-from-web-container-to-neo4j-container-using-bolt and the problem has been solved. ",0,66951367
2672,https://stackoverflow.com/a/67719526,graph regression detection in neo4j,false,"Not really an answer: I didn&#39;t find/create a tool to detect large clusters of nodes. The problem was solved by adding more RAM to fit all 64GB of data.

Also, spent couple of days trying to boost performance even more, but failed.
Different JVM settings almost do nothing (large heap, large pagecache).
Community edition seems to be hard-limited to 10 cores, but effective limit is even lower, because difference between 4 and 10-20 core mode is just several percent.
",0,67719526
2673,https://stackoverflow.com/a/66945382,Set property with value based on maxium value of this property in all nodes in Neo4j,false,"This should do the trick : 

```
MATCH (s:Sc)
WHERE EXISTS(s.id)
WITH max(s.id) AS maxValue
MATCH (s:Sc)
WHERE NOT EXISTS(s.id)
SET s.id = maxValue + 1
```",0,66945382
2674,https://stackoverflow.com/a/66947647,Set property with value based on maxium value of this property in all nodes in Neo4j,true,"&gt; 1. Collect all sc without id
&gt; 2. For each sc, create a sequence of numbers from 1..n
&gt; 3. Then set the value of each node sc.id equals maxValue + row number


    MATCH (sc:Sc) WHERE EXISTS(sc.id)
    WITH max(sc.id) AS maxValue
    MATCH (s:Sc) WHERE NOT EXISTS(s.id)
    WITH maxValue, collect(s) as scs
    UNWIND range(1, size(scs)) as row
    SET (scs[row-1]).id = maxValue+row

    Sample result:
    ╒═══════════════════╕
    │&quot;Sc&quot;               │
    ╞═══════════════════╡
    │{&quot;id&quot;:1}           │
    ├───────────────────┤
    │{&quot;id&quot;:2}           │
    ├───────────────────┤
    │{&quot;name&quot;:&quot;a&quot;,&quot;id&quot;:3}│
    ├───────────────────┤
    │{&quot;name&quot;:&quot;b&quot;,&quot;id&quot;:4}│
    ├───────────────────┤
    │{&quot;name&quot;:&quot;c&quot;,&quot;id&quot;:5}│
    └───────────────────┘",1,66947647
2675,https://stackoverflow.com/a/66944326,Failed to invoke procedure `netscan.find_communities`: Caused by: java.lang.NoSuchMethodError: &#39;org.neo4j.graphdb.Result org.neo4j.graphdb.GraphDataba,false,"The pom of that plugin shows it was built for Neo4j 3.1.1 https://github.com/vitorhorta/netscan-neo4j/blob/master/pom.xml#L15 , you have to run a Neo4j instance of the same version.

If you want to do community detection, the GDS (Graph Datascience Library) is covering such algorithm : https://neo4j.com/docs/graph-data-science/current/algorithms/community/",0,66944326
2676,https://stackoverflow.com/a/66927261,"In cypher, return only the nodes with most recent relationship",true,"To find what you want, you have to make sure that you filter to people who don&#39;t have a :livesAt relationship with a larger since property (indicating that they now live elsewhere) to a different location. That&#39;s important because it&#39;s possible that they lived at that location, moved elsewhere, then moved back later.

We can use existential subqueries from Neo4j 4.x to give us finer control for describing the pattern that we don&#39;t want to exist.

    MATCH (loc:Place {name: &#39;apartmentA&#39;})&lt;-[r:livesAt]-(p:Person)
    WITH loc, max(r.since) as most_recent, p
    WHERE NOT EXISTS {
        MATCH (p) -[r:livesAt]-&gt;(other)
        WHERE r.since &gt; most_recent AND other &lt;&gt; loc
    }
    RETURN p.name

You might also consider remodeling this, keeping a :currentResidence relationship to their current residence, updating that (deleting the old, creating the new) when they move. That&#39;s in addition to the :livesAt relationships you already have (I assume you use those for other queries). That lets you very quickly perform checks and matches based on current residence without needing to do any additional filtering at all.

EDIT:

If you don&#39;t want to use an existential subquery, we can use an OPTIONAL MATCH of the pattern instead, and only filter to the results where the other node is null, meaning that no such pattern exists:

    MATCH (loc:Place {name: &#39;apartmentA&#39;})&lt;-[r:livesAt]-(p:Person)
    WITH loc, max(r.since) as most_recent, p
    OPTIONAL MATCH (p) -[r:livesAt]-&gt;(other)
    WHERE r.since &gt; most_recent AND other &lt;&gt; loc
    WITH p, other
    WHERE other IS NULL
    RETURN p.name",1,66927261
2677,https://stackoverflow.com/a/66923490,"Problem for Neo4j loading .dump file correctly, but failed to show the database",false,"So `neo4j-admin load` and `neo4j-admin restore` take care of setting up the db in the filesystem. Back in the 3.5.x days this was enough, provided the name of the graph directory matched the name of the active graph configured in the neo4j.conf.

In Neo4j 4.x we support multidatabase, and the system database is where we can do things such as creating new databases, and if you CREATE DATABASE in the system db with the name of the new database, it will use just use the files it finds and create the entry in the system db, allowing you to use it and switch to it in Neo4j.

Since you&#39;re on community edition, you won&#39;t be able to create a new database, you&#39;re restricted to only the `neo4j` database, so your import would have to force it using `neo4j` as the db name, and it would overwrite your current neo4j db.

If you need to create multiple databases besides neo4j and system, then you need to be using enterprise edition.",0,66923490
2678,https://stackoverflow.com/a/66918165,Label Propagation Algorithm Implementation in Neo4j,false,"# Use the GDS Library if you can.

### 1. Create the named graph. 

If you *really* only have `:Node` labels, you might want to work on that. (:Device?, :Gateway?, etc.)

```
CALL gds.graph.create(&#39;projection&#39;, &#39;*&#39;, &#39;*&#39;)
// CALL gds.graph.create(&#39;projection&#39;, [&#39;Device&#39;,&#39;Gateway&#39;,&#39;Node&#39;], &#39;connected_to&#39;)
YIELD graphName, nodeCount, relationshipCount;
```

### 2. Run the projection
```
CALL gds.labelPropagation.stream(&#39;projection&#39;)
YIELD nodeId, communityId AS Community
RETURN gds.util.asNode(nodeId).ip AS IP, Community
ORDER BY Community, IP
```

### 3. Mutate your graph if you want. 
```
CALL gds.labelPropagation.stream(&#39;projection&#39;)
YIELD nodeId, communityId AS Community
WITH gds.util.asNode(nodeId).ip AS IP, Community
MATCH (x:Node {ip: IP})
SET x.community = Community
RETURN Community, count(DISTINCT x)
```

***Sources:***

 - https://neo4j.com/docs/graph-data-science/current/algorithms/label-propagation/
 - https://neo4j.com/docs/graph-data-science/current/management-ops/graph-catalog-ops/
 - https://neo4j.com/docs/graph-data-science/current/management-ops/native-projection/#native-projection",0,66918165
2679,https://stackoverflow.com/a/66935302,Cypher query for graph,true,"For a node you can use `size(&lt;pattern&gt;)` to find the degree of the pattern (provided no label is given for the other node, and no properties are present in the pattern, as those require actually expanding the path to find and filter on those things).

So to get all in and out degrees for all nodes in the graph, you can use:

    MATCH (n)
    RETURN id(n) as id, size((n)--&gt;()) as outDegree, size((n)&lt;--()) as inDegree

The diameter of the graph is the longest of all shortest paths between each node, so that requires every combination of two nodes first to get the shortest path, then only taking the longest:

    MATCH (n)
    WITH collect(n) as allNodes
    UNWIND allNodes as a
    UNWIND allNodes as b
    WITH a, b
    WHERE id(a) &lt; id(b)
    MATCH path = shortestPath((a)-[*]-(b))
    RETURN max(length(path)) as diameter

The `id(a) &lt; id(b)` restriction is to ensure we filter out rows where a and b are the same node, and to filter out mirrored results, since we only want a single combination of a and b (and not calculating a second time when a and b are swapped).

For counts of each relationship, and the counts of nodes by label, these are stored in the counts store, and the easiest way to access these statistics is via APOC Procedures. This can come pre-bundled, check this install page (changing the minor version you&#39;re using in the url for more specific instructions):

https://neo4j.com/labs/apoc/4.1/installation/

Once installed you can use `CALL apoc.meta.stats()` to access all graph counts. The `nodeCount` column will give you the total nodes in the graph, and the `labels` column will give you the counts per label. The `relTypesCount` column will give you the counts per relationship type.

I believe for graph density, for directed graphs, it&#39;s `E / (V (V - 1))`, where E is total edges, and V is total vertices. We can get those from the counts store and use that formula:

    CALL apoc.meta.stats() YIELD nodeCount, relCount
    RETURN toFloat(relCount) / (nodeCount * (nodeCount - 1)) as density",1,66935302
2680,https://stackoverflow.com/a/67026709,Spring boot 2.4 Neo4j 6.0 Null value map to boolean primitive changed,false,"Why can&#39;t you do a database update to set the value. Have you looked at Liquibase?

https://www.liquibase.org/

With that, a changeset like this:
```
&lt;query&gt;
   MATCH (n:WhateverNode) WHERE NOT exists(n.flag) SET n.flag=false RETURN n
&lt;/query&gt;
```
Would cleanly update your database so that you don&#39;t need any tricky converters.",0,67026709
2681,https://stackoverflow.com/a/66906139,Neo4j/Cypher Import a CSV file,false,"From your code it seems like you have not created any relationship just a single node for each row in your csv. 
My suggesion is try to create a model first. you can use arrows.app to try and describe your model.

Relationships are created by joining two nodes lets say

    CREATE (:PERSON {name:&quot;CHARLIE&quot;)-[:FOLLOWS]-&gt;(:PERSON {name:&quot;JOHN&quot;})

And from your code id probably try something like

    LOAD CSV WITH HEADERS FROM &#39;file:///vgsales.csv&#39; AS line CREATE(v:Vgsales {rank: toInteger(line.Rank), name: line.Name, platform: line.Platform, year: toInteger(line.Year)}) WITH v MERGE (g:GENRE {genre: line.Genre}) MERGE (p:PUBLISHER {publisher: line.Publisher, NA_sales: toInteger(line.NA_Sales), EU_sales: toInteger(line.EU_Sales)], JP_sales: toInteger(line.JP_Sales), Other_sales: toInteger(line.Other_Sales), Global_sales: toInteger(line.Global_Sales)}) MERGE (v)-[:IN_GENRE]-&gt;(g) MERGE (p)-[:PUBLISHED]-&gt;(v)



----------
I&#39;m not sure that fits your model though you could try and draw your model and perhaps i will write a better code.

----------
",0,66906139
2682,https://stackoverflow.com/a/66906889,Neo4j/Cypher Import a CSV file,false,"Thanks for your answer.
I&#39;m posting back the query because there was an &#39;]&#39; that i forgot to remove : 

    LOAD CSV WITH HEADERS FROM &#39;file:///vgsales.csv&#39; AS line CREATE(v:Vgsales {rank: toInteger(line.Rank), name: line.Name, platform: line.Platform, year:toInteger(line.Year)}) WITH v MERGE (g:GENRE {genre: line.Genre}) MERGE (p:PUBLISHER {publisher: line.Publisher, NA_sales: toInteger(line.NA_Sales), EU_sales: toInteger(line.EU_Sales), JP_sales: toInteger(line.JP_Sales), Other_sales: toInteger(line.Other_Sales), Global_sales: toInteger(line.Global_Sales)}) MERGE (v)-[:IN_GENRE]-&gt;(g) MERGE (p)-[:PUBLISHED]-&gt;(v) 

However the query still doesn&#39;t work. I have this error : [enter image description here][1]


This is how my dataset looks like : [enter image description here][2]

The exercise that I must do for tomorrow is to find a dataset, to find a problematic and to answer it with a plugin algorithm and then get the graph model and load the csv file in neo4j but i don&#39;t know how should add the relationships between the nodes.


  [1]: https://i.stack.imgur.com/xKWRa.png
  [2]: https://i.stack.imgur.com/NoeBh.png",1,66906889
2683,https://stackoverflow.com/a/66909943,Neo4j/Cypher Import a CSV file,true,"There is a syntax error on your script. You can remove this line below:

    WITH v 

I tried it on my neo4j browser and it works well:

 

    LOAD CSV WITH HEADERS FROM &#39;file:///vgsales.csv&#39; AS line 
    CREATE(v:Vgsales {rank: toInteger(line.Rank), name: line.Name, platform: line.Platform, year:toInteger(line.Year)}) 
    //WITH v  &lt;- remove this!
    MERGE (g:GENRE {genre: line.Genre}) 
    MERGE (p:PUBLISHER {publisher: line.Publisher, NA_sales: toInteger(line.NA_Sales), 
    EU_sales: toInteger(line.EU_Sales), JP_sales: toInteger(line.JP_Sales), Other_sales: toInteger(line.Other_Sales), Global_sales: toInteger(line.Global_Sales)}) 
    MERGE (v)-[:IN_GENRE]-&gt;(g) 
    MERGE (p)-[:PUBLISHED]-&gt;(v) 

    Result: Added 3 labels, created 3 nodes, set 11 properties, created 2 relationships, completed after 235 ms.",1,66909943
2684,https://stackoverflow.com/a/66963263,How can I check if a Neo4j fulltext index exists?,false,"# Viewable list, (but not operable)
```
SHOW [ALL|BTREE] INDEX[ES] [BRIEF|VERBOSE [OUTPUT]]

SHOW ALL INDEX VERBOSE
```

## Errors when recreating an index?
Use ***IF NOT EXISTS***

```
CREATE INDEX usernames IF NOT EXISTS FOR (u:User) ON (u.username) 
```

## Deprecation
Unfortunately, there is no *un-deprecated* way to get a list of indices which you can operate on as per your example. However, deprecation *does not* mean you shouldn&#39;t use it. Deprecation *usually* (in semantic versioning) means that the method will not be available, or will be significantly changed, in the next major release. Don&#39;t worry, Neo4j 5 is a ways off. 

### References
* https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/",0,66963263
2685,https://stackoverflow.com/a/66908909,How can I create a Neo4j fulltext index idempotently?,false,"You cannot run a cypher query to drop/create an index. But you can drop / create it in two steps like

    CALL db.index.fulltext.drop(&quot;usernames&quot;)  ;
    CALL db.index.fulltext.createNodeIndex(&quot;usernames&quot;, [&quot;User&quot;], [&quot;username&quot;]) ;",0,66908909
2686,https://stackoverflow.com/a/66936194,neo4j spark connector doesn&#39;t work correctly,false,"Use:

    $SPARK_HOME\bin\spark-shell --conf spark.neo4j.password=&lt;password&gt; --packages neo4j-contrib:neo4j-spark-connector:2.4.5-M2

instead of: 

    $SPARK_HOME\bin\spark-shell --conf spark.neo4j.bolt.password=&lt;password&gt; --packages neo4j-contrib:neo4j-spark-connector:2.4.5-M2

Just remove the **bolt** word. 

**Update**&#39;
Now I want to use the following package: 

    $SPARK_HOME/bin/spark-shell --packages neo4j-contrib:neo4j-connector-apache-spark_2.12:4.0.1_for_spark_3

As mentioned in [1]

The only one that works is the following (the old version):

    $SPARK_HOME/bin/spark-shell --packages neo4j-contrib:neo4j-spark-connector:2.4.5-M2

But using it, the Neo4jGraph.saveGraph is not working. The error is : Writing in read access mode not allowed.

Thanks for your help.


  [1]: https://github.com/neo4j-contrib/neo4j-spark-connector/releases
",0,66936194
2687,https://stackoverflow.com/a/66908553,How can I Download to CSV in Neo4j,false,"The syntax for the function: apoc.export.csv.data is  

    apoc.export.csv.data(nodes,rels,file,config) 
- exports given nodes and relationships as csv to the provided file

The nodes is a collection of nodes rather than a node.

    OLD: MATCH (c:Contrib) WHERE c.nationality CONTAINS &quot;|&quot; 
         CALL apoc.export.csv.data(c,[], &quot;contrib.csv&quot;,{})

    NEW: MATCH (c:Contrib) WHERE c.nationality CONTAINS &quot;|&quot; 
         WITH collect(c) as contribs
         CALL apoc.export.csv.data(contribs, [], &quot;contrib.csv&quot;, {})
     ",0,66908553
2688,https://stackoverflow.com/a/66897312,Using docker container inside npm package,true,"You can make a network connection to a database or other process running in a container, in the same way you could as if it were running directly on the host or if it were a different host.  For Neo4j it looks like there are [several required connection options](https://neo4j.com/docs/javascript-manual/current/client-applications/#js-driver-connection-uris) such as the URL of some server and authentication information, but as far as a client application is concerned it doesn&#39;t matter at all if the database is running in Docker or somewhere else.

If the database was running in a container on the same system, and the TypeScript compiler isn&#39;t running in a container too, and you&#39;re not using Docker Toolbox or another VM-based Docker implementation, then you can _probably_ connect to `neo4j://localhost:7687`; that would require the database to have been started with a `docker run -p 7687:7687` or similar option to publish the port.  That could be a reasonable default value for something that could be configured with an environment variable or a config-file setting.

Your extension library couldn&#39;t start the database itself.  If you can start a Docker container then you can use bind-mounts and other container options to root the entire host, and in many environments this reasonably requires `sudo` permissions.",2,66897312
2689,https://stackoverflow.com/a/66901042,subprocess.check_output failing within Docker,false,"Thanks to @DavidMaze&#39;s comment, the `ip` tool needs to be installed via Docker, for example:

    RUN apt-get install iproute2",0,66901042
2690,https://stackoverflow.com/a/66894092,Is it possible to create bi-directional relationships between nodes with the same label?,false,"You&#39;re using SDN here?

From the Spring Data Neo4j docs:

&gt; If you don’t care about the direction then you can specify direction=Relationship.UNDIRECTED which will guarantee that the path between two node entities is navigable from either side.",1,66894092
2691,https://stackoverflow.com/a/67121861,Is it possible to create bi-directional relationships between nodes with the same label?,false,"As far as I know (i&#39;m just beginning to learn Neo4j too) you can&#39;t have bi-directional relationships, it&#39;s always suggested to have two directional ones.

If you do decide to add another relationship in the other direction, you could limit the number of hops to just one:

https://stackoverflow.com/questions/39693976/how-can-cypher-impose-a-maximum-number-of-hops-only-counting-a-specific-type-of

Or if you want to see longer chains of relationships, perhaps put a condition on the results to not return the originating node in the results?",0,67121861
2692,https://stackoverflow.com/a/66889647,Neo4j embedded DROP INDEX throws odd error,true,"It is not possible to get the index using cypher.  The name returned by db.indexes() is the value string (or name) of the index rather than the index itself. You can delete it in below steps.

    1. List the index (or indices) that you want to remove

       call db.indexes() yield name, labelsOrTypes 
       WITH name, labelsOrTypes where ANY (lbl in [&#39;Movie&#39;,  &#39;Person&#39;] WHERE lbl in labelsOrTypes)
       RETURN name, labelsOrTypes

    2. Pick the index (or indices) that you want to delete and copy/paste in neo4j browser

       DROP INDEX index_2384723 IF EXISTS;
       DROP INDEX index_Person IF EXISTS;

     3. Execute and verify
   
       Removed 1 index, completed after 4 ms.",1,66889647
2693,https://stackoverflow.com/a/66881708,"Required identifier property not found for class Person, when using Neo4j ogm?",true,"It is possible that you are mixing the earlier neo4j-ogm with the latest [Spring Data Neo4j](https://docs.spring.io/spring-data/neo4j/docs/6.0.6/reference/html/#what-is-sdn) 

Check your dependencies and make sure your annotations are from the correct packages (for instance, org.springframework.data.neo4j.*)

If you follow the instructions in the link above, you should be able to resolve your errors.
",2,66881708
2694,https://stackoverflow.com/a/66888959,Neo4j query takes an eternity to execute,true,"The first two lines syntax of your query is not correct. You should run it like this:

    OLD: 
    MATCH (i:Item)-[:HAS]-&gt;(p2:Properties)&lt;-[:HAS]-(i1:Item)
    WITH {item:id(i), categories: collect(id(i1))} as userData
    
    NEW: 
    MATCH (i:Item)-[:HAS]-&gt;(p2:Properties)
    WITH {item:id(i), categories: collect(id(p2))} as userData

This is what the algorithm (jaccard ) is doing. An item (say Item1) is similar (number from 0 to 1 inclusive) to another item (like Item2) if both shares the same properties.  For example; Item1 has 3 properties1,2,3 and Item2 has 3 properties2,3,4. So the jaccard similarity index is 2/4 or 0.5 because property2,3 are common and there are 4 unique properties in both items.  

&gt; So in your query, you only need to specify that an item (like item1) has some properties and you don&#39;t need to specify another item (like item2) has some properties. The function will iterate all items and will give you the jaccard index, that is, item1 vs item2, item1 vs item3..., item2 vs item3, so on...This is the syntax for algo.similarity.jaccard.stream.

See reference here: https://neo4j.com/docs/graph-algorithms/current/labs-algorithms/jaccard/



",1,66888959
2695,https://stackoverflow.com/a/66905476,Unable to match and create nodes using MATCH and MERGE,false,"MATCH clause just looks if a node or a pattern exists if it finds one it returns the node or the pattern, it does not create nodes or patterns, on the other hand,
MERGE clause looks for a node or a pattern and if it does not exist it creates one.",2,66905476
2696,https://stackoverflow.com/a/66867642,SQL - Query Year by Year,false,"You can use:

``` sql
WITH years ( year ) AS (
  SELECT DATE &#39;2010-01-01&#39; FROM DUAL
UNION ALL
  SELECT ADD_MONTHS( year, 12 )
  FROM   years
  WHERE  year &lt; DATE &#39;2020-01-01&#39;
)
SELECT y.year, e.employee_name
FROM   employees e
       INNER JOIN years y
       ON (   e.employment_start_date &lt;= y.year
          AND e.employment_end_date   &gt;=  ADD_MONTHS( y.year, 12 ) )
```",2,66867642
2697,https://stackoverflow.com/a/66897939,SQL - Query Year by Year,false,"An alternative to MT0&#39;s suggestion:

```
WITH years (year) AS(
SELECT EXTRACT (YEAR FROM DATE &#39;2010-01-01&#39;) + ROWNUM -1 AS &quot;YEAR&quot;
FROM dual
CONNECT BY ROWNUM &lt;=10
)

SELECT y.year, e.employee_name
FROM employee e
INNER JOIN years y
ON (
EXTRACT(YEAR FROM employment_start_date) &lt; y.year
AND EXTRACT(YEAR FROM employment_end_date) &gt; y.year
)
```",0,66897939
2698,https://stackoverflow.com/a/66864166,How to limit overall union in cypher,true,"You need subqueries for this, you should be using Neo4j 4.0.x or later, this allows you to perform [post-UNION processing](https://neo4j.com/developer/kb/post-union-processing/)

Usage of UNION ALL in the subquery, with the LIMIT 10 outside of it, should allow you to get what you want.",0,66864166
2699,https://stackoverflow.com/a/66894765,Neo4J dump database,true,"I was able to successfully dump the file. In the terminal for my database I had to use the above command with the database name.

```
.\bin\neo4j-admin.bat dump --database=MyDatabase --to=c:\dump\myDb.dump
```

Also the target folder must exist.",0,66894765
2700,https://stackoverflow.com/a/66859240,Cypher query to add WHERE clause for nodes that were created within the last 24 hours,true,"You&#39;ll need to have the property indexed, and you&#39;ll need to leverage [index-backed ordering](https://neo4j.com/docs/cypher-manual/current/query-tuning/advanced-example/#advanced-query-tuning-example-index-backed-order-by), which will grab the ordered entries from the index instead of having to look at and filter all :User nodes.

So, for the index you first need:

```
CREATE INDEX ON :User(createdAt)
```

You should be using temporal types, so for this I&#39;ll assume a dateTime type is used.

Next for the WHERE clause, for it to leverage the index, you can&#39;t apply a function or use any accessors from the `createdAt` property, that needs to be left alone. We can calculate 24 hours or one day ago through using `dateTime()` to get the current dateTime instant, and subtraction of a duration, then we&#39;ll use an inequality to finish up.

Also, we recommend using singular instead of plural when you&#39;re not working with list types, so `user` instead of `users`, since it represents a single user per row. 

    MATCH (user:User {role: &quot;USER&quot;, hasCompletedRegistration: true})
    WHERE user.createdAt &gt; dateTime() - duration({days:1})
    RETURN user

If you view the EXPLAIN plan of the query, you want to see a NodeIndexSeekByRange being used. If you see any other index being used (say on the role or hasCompletedRegistration) then you can provide a planner hint to force it to use the index on createdAt:

    MATCH (user:User {role: &quot;USER&quot;, hasCompletedRegistration: true})
    USING INDEX user:User(createdAt)
    WHERE user.createdAt &gt; dateTime() - duration({days:1})
    RETURN user",1,66859240
2701,https://stackoverflow.com/a/66859335,Cypher query to add WHERE clause for nodes that were created within the last 24 hours,false,"You can use the function duration.inSeconds and get the hour part. Datetime() function gets the system datetime now.
 
    MATCH (n:User )
    WHERE duration.inSeconds(n.createdAt, datetime()).hours &lt;= 24
    RETURN n",0,66859335
2702,https://stackoverflow.com/a/66858951,get all graph data including nodes and relationships from neo4j using java into a hashmap,false,"You can use below example to parse the result from neo4j query. If you get into any issue(s), pls let me know. Thanks.

    Iterator&lt;Node&gt; javaNodes = execResult.columnAs(&quot;m&quot;);
    for (Node node : IteratorUtil.asIterable(javaNodes))
    {
        //parse the node in here
    }

Reference: https://neo4j.com/docs/java-reference/current/java-embedded/cypher-java/",1,66858951
2703,https://stackoverflow.com/a/66855567,How to &quot;overlay&quot; relationships using Neo4j?,false,"Yes, you are correct to say that when you create the data, you need to check if there is an existing relationship at the market level before you create another relationship at Region level that is, between New York Region to SMI-Folded Egg.  

&gt; perhaps another way of modeling my objects to better achieve the above
&gt; functionality

Below is the query to do so.  1. Find the SMI (folded egg) 2. Create a loop where you will check if the US Market has an offer to this SMI  3. If not found then create a relationship between this region (New York) to this SMI

    MATCH (Folded_Egg:SMI {value: &quot;Folded Egg&quot;})
    MATCH (New_York_Region:Geo {value: &quot;New York Region&quot;})
    WITH Folded_Egg, New_York_Region
    FOREACH (_ in CASE NOT EXISTS((:Geo {value: &quot;US Market&quot;})-[:offers]-&gt;(Folded_Egg)) when true then [1] else [] end | 
    CREATE (New_York_Region)-[:offers]-&gt;(Folded_Egg) )
    RETURN Folded_Egg, New_York_Region",0,66855567
2704,https://stackoverflow.com/a/67009125,How to &quot;overlay&quot; relationships using Neo4j?,false,"I was able to create a query that traversed the geography hierarchy and only added new nodes using UNION and WITH statements.  Below is the statement...

```
OPTIONAL MATCH (geo)-[o:offers]-&gt;(storeSMIs)-[:contains]-&gt;(storeBMIs)-[:defined_as]-&gt;(storeVers)
WHERE storeVers.version = o.version AND geo.value = &quot;Store 3456&quot;
RETURN storeSMIs as totalSMIs, storeBMIs as totalBMIs, storeVers as totalVers
UNION
OPTIONAL MATCH (geo)-[o:offers]-&gt;(storeSMIs) WHERE geo.value = &quot;Store 3456&quot;
WITH collect(storeSMIs) as storeSMIs
OPTIONAL MATCH (geo)-[:inherits_from*1..1]-&gt;()-[o2:offers]-&gt;(regionSMIs)-[:contains]-&gt;(regionBMIs)-[:defined_as]-&gt;(regionVers)   
WHERE regionVers.version = o2.version AND NOT regionSMIs in storeSMIs
    AND geo.value = &quot;Store 3456&quot;
RETURN regionSMIs as totalSMIs, regionBMIs as totalBMIs, regionVers as totalVers
UNION
OPTIONAL MATCH (geo)-[o:offers]-&gt;(storeSMIs) WHERE geo.value = &quot;Store 3456&quot;
WITH collect(storeSMIs) as storeSMIs
OPTIONAL MATCH (geo)-[:inherits_from*1..1]-&gt;()-[o2:offers]-&gt;(regionSMIs) WHERE geo.value = &quot;Store 3456&quot;
WITH storeSMIs, collect(regionSMIs) AS regionSMIs
OPTIONAL MATCH (geo)-[:inherits_from*2..2]-&gt;()-[o3:offers]-&gt;(mktSMIs)-[:contains]-&gt;(mktBMIs)-[:defined_as]-&gt;(mktVers)   
WHERE mktVers.version = o3.version AND NOT mktSMIs IN storeSMIs
    AND NOT mktSMIs IN regionSMIs AND geo.value = &quot;Store 3456&quot;
RETURN mktSMIs as totalSMIs, mktBMIs as totalBMIs, mktVers as totalVers
```",0,67009125
2705,https://stackoverflow.com/a/66847087,"In cypher, return node with latest date in relationship property",true,"The problem (maybe) is located on the last match clause. I tested a simpler version on Neo4j SandBox and seemed OK: 

```
MATCH (n:person {name: &#39;bill&#39;})-[r:livesAt]-&gt;(m:place)
WITH n, m
ORDER BY r.since DESC
LIMIT 1
RETURN m.name as place, n.name as person
```",1,66847087
2706,https://stackoverflow.com/a/66847279,"In cypher, return node with latest date in relationship property",false,"Alternately, you can use max clause to get the max value of the relationship then find that node that corresponds to the most recent residence.

 
    MATCH (n:person {name: &#39;bill&#39;})-[r:livesAt]-&gt;(:place)   
    WITH max(r.since) as most_recent, n
    MATCH (n)-[:livesAt {since: most_recent}]-&gt;(m:place)
    RETURN m",1,66847279
2707,https://stackoverflow.com/a/66845006,Can&#39;t get APOC to work on Neo4j Community Edition google cloud instance,false,"&gt; An important thing to note about cloud version of neo4j is that you
&gt; should not modify the /etc/neo4j/neo4j.conf file directly, but rather
&gt; modify /etc/neo4j/neo4j.template. The system service that restarts
&gt; neo4j calls a shell script called pre-neo4j.sh.

https://neo4j.com/developer/neo4j-cloud-vms/

I modified the neo4j.conf file directly. Oops... Leaving this here in case someone else does this.

(edit)
This was not the problem. https://stackoverflow.com/a/56227465/15118442 this helped fix the problem. Btw, apoc still does not come preinstalled with CGP instance from the marketplace. You have to install apoc yourself. And for initialization I recommend the above stackoverflow link.",1,66845006
2708,https://stackoverflow.com/a/66844828,Why does the query to find intermediate nodes take so long?,false,"That might be an unbounded path search? Do you really want all paths of any length between the two nodes (e.g. paths spanning the entire graph?)

Does this do what you want? 

MATCH (origin:App)
WHERE origin.commit=&#39;10cb31b0a72525923c01dc34f8690f311a361d42&#39;
MATCH (destination:App)
WHERE destination.commit=&#39;51fde433973463f057ffcbcbab0bc8944ab3ec9c&#39;
MATCH (origin:App)-[:CHANGED_TO *0..1]-&gt;(intermediate_commit:App)-[:CHANGED_TO *0..1]-&gt;(destination:App)
RETURN distinct intermediate_commit

I bounded the path length to one hop, changing from 0.. to 0..1 
(which means minimum 0 hop, up to 1 relationship hop)",0,66844828
2709,https://stackoverflow.com/a/66850021,Why does the query to find intermediate nodes take so long?,false,"The pattern and conditions allow for the possibility of paths that extend past the start or end nodes yet reach them again further down, this is why it doesn&#39;t stop when it finds one matching path but keeps expanding beyond it. Remember Cypher is concerned with finding all possible paths that meet the pattern that exist in the graph. And because of your pattern, the check-beyond-the-start-and-end-nodes-without-limit doesn&#39;t just happen once, but per potential `(intermediate_commit:App)` found while expanding, this is why your query isn&#39;t returning.

One way you can get what you want, all possible paths but stopping when the node is reached, is to use the APOC path expanders, you can supply the node as a terminator node, which will halt further expansion past it.

    MATCH (origin:App)
    WHERE origin.commit=&#39;10cb31b0a72525923c01dc34f8690f311a361d42&#39;
    MATCH (destination:App)
    WHERE destination.commit=&#39;51fde433973463f057ffcbcbab0bc8944ab3ec9c&#39;
    CALL apoc.path.expandConfig(destination, {relationshipFilter:&#39;&lt;CHANGED_TO&#39;, terminatorNodes:[origin]}) YIELD path
    UNWIND nodes[path] as node
    WITH DISTINCT node
    WHERE node:App
    RETURN node as intermediate_commit

This is expanding backwards from destination to origin, seems like that could be more efficient. Once we have the paths, we can UNWIND the nodes from all paths, keep the distinct ones, and make sure we only take the :App nodes.",0,66850021
2710,https://stackoverflow.com/a/66955397,Why does the query to find intermediate nodes take so long?,true,"The solution was quite simple. Instead of specifying a pattern in MATCH clause, we move the pattern to WHERE clause. Also, I split the pattern into 2 parts. I can&#39;t explain why exactly it is faster but my understanding is that when we move pattern to WHERE clause and MATCH only nodes, we let neo4j know that we are interested only in nodes and not in all possible paths that match the pattern.

The full query:

    MATCH (origin:App)
      WHERE origin.commit=&#39;10cb31b0a72525923c01dc34f8690f311a361d42&#39;
    MATCH (destination:App)
      WHERE destination.commit=&#39;51fde433973463f057ffcbcbab0bc8944ab3ec9c&#39;
    MATCH (intermediate_commit:App)
      WHERE (origin)-[:CHANGED_TO*0..]-&gt;(intermediate_commit)
        AND (intermediate_commit)-[:CHANGED_TO*0..]-&gt;(destination)
    RETURN distinct intermediate_commit

Also, if you have a lot of nodes, I believe specifying LIMIT 1 to match origin and destination can also improve the query, like this:

    MATCH (origin:App)
      WHERE origin.commit=&#39;10cb31b0a72525923c01dc34f8690f311a361d42&#39;
    WITH origin
    LIMIT 1
    MATCH (destination:App)
      WHERE destination.commit=&#39;51fde433973463f057ffcbcbab0bc8944ab3ec9c&#39;
    WITH origin, destination
    LIMIT 1
    MATCH (intermediate_commit:App)
      WHERE (origin)-[:CHANGED_TO*0..]-&gt;(intermediate_commit)
        AND (intermediate_commit)-[:CHANGED_TO*0..]-&gt;(destination)
    RETURN distinct intermediate_commit
",0,66955397
2711,https://stackoverflow.com/a/66837900,Collect sub tree nodes as separate lists with Neo4j,true,"Something like this should work:

```
MATCH (f:Family)
CALL {
 WITH f
 MATCH (f)&lt;-[*]-(s:Story)
 RETURN f, collect(DISTINCT s) as Stories
}
RETURN f.name as family, Stories
```

Though that gets you a family per row (I don&#39;t know what your properties are so I&#39;m guessing), and the stories per family.

If you want a map structure back with the family name as a key, then you need APOC Procedures:

```
MATCH (f:Family)
CALL {
 WITH f
 MATCH (f)&lt;-[*]-(s:Story)
 WITH f, collect(DISTINCT s) as Stories
 RETURN [f.name, f {Stories}] as familyInfo
}
WITH collect(familyInfo) as familyData
RETURN apoc.map.fromPairs(familyData) as results
```

Another approach is to try APOC path expanders to get the stories:


```
MATCH (f:Family)
CALL {
 WITH f
 CALL apoc.path.subgraphNodes(f, {labelFilter:&#39;/Story&#39;, relationshipFilter:&#39;&lt;&#39;}) YIELD node as s
 WITH f, collect(s) as Stories
 RETURN [f.name, f {Stories}] as familyInfo
}
WITH collect(familyInfo) as familyData
RETURN apoc.map.fromPairs(familyData) as results
```",1,66837900
2712,https://stackoverflow.com/a/66825813,passing parameters in neo4j using python,true,"You can use the f-strings in Python. See example below. Note that
&gt;1. You need to use {{ as escape character for {

&gt;2  You need to use \\ as escape character for &quot;

    n = &quot;abc&quot;
    a = 1234
    
    cqlCreate = f&quot;CREATE (cornell:university {{name: \&quot;{n}\&quot;, yob: {a}}})&quot;
    print (cqlCreate)
    
    Result:
    CREATE (cornell:university {name: &quot;abc&quot;, yob: 1234})

reference: https://www.python.org/dev/peps/pep-0498/",0,66825813
2713,https://stackoverflow.com/a/66842365,passing parameters in neo4j using python,false,"It actually depends on the Python driver that you are using to connect to Neo4j (check https://neo4j.com/developer/python/ to see the list of available drivers). If you are using the official neo4j-driver, the code you wrote is correct. In order execute the Cypher query, you could do something like this:

    from neo4j import GraphDatabase
    
    uri = # insert neo4j uri
    user = # insert neo4j username
    password = # insert neo4j password

    n = &quot;abc&quot;
    a = 1234
    query = &quot;CREATE (cornell:university { name: $n,yob:$a})&quot;

    driver = GraphDatabase.driver(uri, auth=(user, password))
    session = driver.session()
    result = session.run(query, n=n, a=a)
    session.close()
    driver.close()

Although &#226;ńōŋŷXmoůŜ&#39;s answer will probably work, it is not recommended way to it.

**See also**:
- https://neo4j.com/docs/api/python-driver/current/api.html


",1,66842365
2714,https://stackoverflow.com/a/66822576,"In the neo4j sandbox, how to display nodes with the same label close to each other?",false,"I believe you are asking for a custom layout.

The neo4j browser uses automated layout based on relationships (part of d3.js).  The only way you can get what you want in the sandbox (to my knowledge) is to manually click on the nodes and drag them around.  Note, this arrangement is only for your current session, it isn&#39;t saved.

To do what you want programmatically you&#39;d need to implement a custom viewer, or see if one of the available tools has a layout that would meet your needs.

Cytoscape, and Gephi are two that I use with Neo4j.  I wouldn&#39;t call them easy to use, and I don&#39;t recall any layout that does exactly what you want (though a few do something similar, in that they can layout by properties/labels)",0,66822576
2715,https://stackoverflow.com/a/66818531,where to find apoc.conf in neo4j sandbox,false,"No worries Robin, we are here to help. Read this website if you want the full details: https://neo4j.com/labs/apoc/4.1/import/load-json/

&gt; 1. Go find your neo4j home directory and under &#39;conf&#39; folder you will find a file:  neo4j.conf.  
&gt; Yes! it is the same apoc.conf mentioned in the
&gt; error message.  
&gt; Confusion is solved :D
&gt; 2. Copy and paste this configuration setting in neo4j.conf (or apoc.conf)
&gt; apoc.import.file.enabled=true
&gt; 3. Lastly go to &#39;import&#39; folder then save your json file: apoc.json and stop/start your neo4j server. Scripts are found at /bin directory

    CALL apoc.load.json(&quot;file:///apoc.json&quot;)
    YIELD value
    RETURN value;

",0,66818531
2716,https://stackoverflow.com/a/66821226,"Neo4j export whole database to JSON_LINES, ARRAY_JSON, JSON or JSON_ID_AS_KEYS",true,"This is working now in neo4j versions 4.2.x with APOC version 4.2.0.2: https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases/download/4.2.0.2/apoc-4.2.0.2-all.jar

The syntax is simpler. Notice the config is a dictionary rather than a nested dictionary. See my sample below.

    OLD: CALL apoc.export.json.all(&quot;all.json&quot;,{config:{jsonFormat:&#39;ARRAY_JSON&#39;}})
    
    NEW: CALL apoc.export.json.all(&quot;all.json&quot;, {jsonFormat: &#39;ARRAY_JSON&#39;})
    Result:
    (type is array of dictionaries)

[![enter image description here][1]][1]
 
 


  [1]: https://i.stack.imgur.com/3lIxG.png",0,66821226
2717,https://stackoverflow.com/a/66863500,"Neo4j export whole database to JSON_LINES, ARRAY_JSON, JSON or JSON_ID_AS_KEYS",false,"The solution for my question was changing the APOC.jar file with the latest release from [here][1]. I have had to update the syntax as well.

    CALL apoc.export.json.all(&quot;all.json&quot;, {jsonFormat: &#39;ARRAY_JSON&#39;})

You can open the plugin folder using the tree dots by the blue open button and chose Open Folder -&gt; Plugins. Copy and paste the path showed into your file manager if it doesn&#39;t open.

In the plugin folder, you can see your APOC version on the apoc file name.


  [1]: https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases",0,66863500
2718,https://stackoverflow.com/a/66809891,Neo4j: Difference between rand() and rand() in with clause when matching random nodes,true,"It&#39;s important to understand that using rand() in the ORDER BY like this isn&#39;t doing what you think it&#39;s doing. It&#39;s not picking a random number per row, it&#39;s ordering by a single number.

It&#39;s similar to a query like:

    MATCH (p:Person)
    RETURN p
    ORDER BY 5

Feel free to switch up the number. In any case, it doesn&#39;t change the ordering because ordering every row, when the same number is used, doesn&#39;t change the ordering.

But when you project out a random number in a WITH clause per row, then you&#39;re no longer ordering by a single number for all rows, but by a variable which is different per row.",0,66809891
2719,https://stackoverflow.com/a/66818116,Neo4j: Difference between rand() and rand() in with clause when matching random nodes,false,"Your assumption is not correct. I always get a randomized order by using below query when running it in Neoj Desktop.  

    MATCH (p:Person{name: &#39;Jessica Thompson&#39;})-[r:REVIEWED]-&gt;(m:Movie)
    return m order by rand() limit 10

If your data has only 5 records in it, then adding a limit 10 will ALWAYS return 5 records. Put a limit of 2 then you will see it is &quot;randomized&quot;

 
    MATCH (p:Person{name: &#39;Jessica Thompson&#39;})-[r:REVIEWED]-&gt;(m:Movie)
    return m order by rand() limit 2",0,66818116
2720,https://stackoverflow.com/a/66806138,TypeError: Cannot read property &#39;identity&#39; of null Javascript Neo4J data,true,"Check if the value exists before accessing props.



&lt;!-- begin snippet: js hide: false console: true babel: null --&gt;

&lt;!-- language: lang-js --&gt;

    app.get(&#39;/page/:id&#39;, function(req, res) {
      var id = req.params.id;
      
          session
          .run(&quot;OPTIONAL MATCH(a:Person)-[r]-(b) WHERE id(a)=toInteger($idParam) RETURN b&quot;, {
          idParam:id
          })
          .then(function(result2){
              var RelationArr = [];
              result2.records.forEach(function(record){
                if(record._fields[0]) {
                  RelationArr.push({
                    id: record._fields[0].identity.low,
                    name: record._fields[0].properties.name,
                    title: record._fields[0].properties.title,
                  });
               }
          });

          res.render(&#39;person&#39;, {
              relation: RelationArr,
          });
          })

          .catch(function(err){
            console.log(err);
          });
          })

&lt;!-- end snippet --&gt;

",0,66806138
2721,https://stackoverflow.com/a/66814068,TypeError: Cannot read property &#39;identity&#39; of null Javascript Neo4J data,false,"Instead of changing the javascript code to handle the null, I changed the Neo4J query to avoid a &quot;null&quot; value:

    MATCH(a)-[r]-(b) WHERE id(a)=toInteger($idParam) OPTIONAL MATCH (a) WHERE id(a)=toInteger($idParam) RETURN b

Thank you @CaptEmulation your contribution gave me the hint to look to the outcome of the query.",0,66814068
2722,https://stackoverflow.com/a/66817694,Increase Transaction timeout in Neo4j Sandbox (Neo4j Browser version: 4.2.1),false,"Use a periodic commit and it will release the transaction every 5000 records processed.  See here: https://neo4j.com/docs/cypher-manual/current/clauses/load-csv/#load-csv-importing-large-amounts-of-data

    USING PERIODIC COMMIT 5000 LOAD CSV FROM &#39;file:///artists.csv&#39; AS line
    CREATE (:Artist {name: line[1], year: toInteger(line[2])})",2,66817694
2723,https://stackoverflow.com/a/66802705,why wrong to store a dictionary/map in neo4j as a property,false,"The presence of a map in your properties implies that the data structure is not fully converted to a graph. The node `(:N {p: map})` implies the structure: `(:N)--&gt;(:P {map})`. With the former structure you&#39;d need to query items in the map using something like `match (n:N) where n.p.k = v` which I imagine would be a nightmare for indexing, etc. With the latter you can simply `match (:N)--&gt;(p:P) where p.k = v`.",0,66802705
2724,https://stackoverflow.com/a/66797477,Cypher return multiple hops through pattern of relationships and nodes,false,"You can specify the path as follows:

```
MATCH path = (:User {userId: $id})-[:can]-&gt;(:Permission)
    &lt;-[:allows]-(:Business))
RETURN path
```

This should return the results you&#39;re after.",1,66797477
2725,https://stackoverflow.com/a/66802558,Cypher return multiple hops through pattern of relationships and nodes,true,"Currently the syntax of variable-length expansions doesn&#39;t allow fine control for separate directions for certain types. There are improvements in the pipeline around this, but for the moment Cypher alone won&#39;t get you what you want.

We can use APOC Procedures for this, as fine control of the direction of types in the expansion, and sequences of relationships, are supported in the [path expander procs](https://neo4j.com/labs/apoc/4.1/graph-querying/expand-paths-config/).

First, though, you&#39;ll need to figure out how to address your user-or-business match, either by adding a common label to these nodes by which you can MATCH either type by property, or you can use a subquery with two UNIONed queries, one for :Business nodes, the other for :User nodes, that way you can still take advantage of an index on either, and get possible results in a single variable.

Once you&#39;ve got that, you can use `apoc.path.expandConfig()`, passing some options to get what you want:

```
// assume you&#39;ve matched to your `start` node already
CALL apoc.path.expandConfig(start, {relationshipFilter:&#39;can&gt;|&lt;allows&#39;, labelFilter:&#39;&gt;Business&#39;}) YIELD path
RETURN path
```

This one doesn&#39;t use sequences, but it does restrict the direction of expansion per relationship type. We are also setting the labelFilter such that :Business nodes are the end node of the path and not nodes of any other label. ",2,66802558
2726,https://stackoverflow.com/a/67021022,Cypher return multiple hops through pattern of relationships and nodes,false,"I see a good solution has been provided via path expanding APOC procedures.  
But I&#39;ll focus on your point #2: &quot;*Should I model this entirely differently?*&quot;
Well, not entirely but I think yes.

The really liberating part of working with Neo4j is that you can change the road you are driving over as easily as you can change your driving strategy: model vs query.  And since you are at an early stage in your project, you can experiment with different models.  There&#39;s a good opportunity to make *just* a semantic change to make an &#39;end run&#39; around the problem.  

The semantics of a relationship in Neo4j are expressed through
 1. the mandatory TYPE you assign to the relationship, combined with 
 2. the direction you choose to point the mandatory arrow

The trick you solved with APOC was how to traverse a path of relationships that alternate between pointing forward and backward along the query&#39;s path.  But before reaching for a power tool, why not just reverse the direction of either of your relationship types.  You can change the model for allows from 

    &lt;-[:allows]-

to

    -[:is_allowed_by]-&gt;

and that buys you a lot.  Now the directions of both relationships are the same and you can combine both relationships into a single relationship in the match pattern.  And the path traversal can be expressed like this, short &amp; sweet:

    (u:User)-[:can|is_allowed_by*]-&gt;(c:Company)

That will literally go to all lengths to find every user-to-company path, branching included.",1,67021022
2727,https://stackoverflow.com/a/66796230,neo4j cannot start on Mac m1: Exception in thread &quot;main&quot; java.lang.UnsatisfiedLinkError,false,I run Neo4j on M1 via Docker and I know when I was looking into that that the JNA dependency needed to be updated (https://github.com/neo4j/neo4j/issues/12676). Given the first line of the exception it would point at that.,0,66796230
2728,https://stackoverflow.com/a/66781914,Cypher query to get node by property not working,false,Most likely cause is that `id` is a string. `MATCH (u:User {id: &quot;1&quot;}) RETURN u` should work. ,1,66781914
2729,https://stackoverflow.com/a/66783249,Cypher query to get node by property not working,true,"Try this query below.  You need to put the value in quotes (string datatype) and remove duplicates when you return the id.

    MATCH (:User {id: &quot;2&quot;})&lt;-[:FOLLOWING]-(followers) 
    RETURN distinct followers.id",0,66783249
2730,https://stackoverflow.com/a/66783555,Should I remove labels for which no node is in the database?,false,"I don&#39;t think you can create a label with an empty node. A label is a name you use to group nodes into a set. For example below, a node and 2 labels are created.

    CREATE (n:Book:Fiction {name: &#39;Harry Potter&#39;, fiction: True})

    Result: Added 2 labels, created 1 node, set 2 properties, completed after 26 ms.",0,66783555
2731,https://stackoverflow.com/a/66767861,SpringData Neo4j @Query does not populate @Relationship Nodes,true,"When writing a custom query with @Query you need to specify exactly what you&#39;re bringing back:

```
@Relationship(type = &quot;ASSIGNED_TO&quot;)
@JsonProperty(&quot;asset&quot;)
private Asset asset;

@NotNull
@Relationship(type = &quot;ISSUED_BY&quot;)
@JsonProperty(&quot;organization&quot;)
private Organization organization;

```

Alternatively (I&#39;m assuming this is SDN 6 with Spring Data as opposed to SDN 5 and OGM?) you can just drop the custom query and use the out-of-the-box SPEL of `findByTrackerId` and the repository methods will create a automagical Cypher query that gets seamlessly serialized by the @Repository methods.

In general custom @Query is useful when needing to write more efficient queries then those offered by the SDN sugars. 

But to answer your question more directly this should work:

```
@Query(&quot;MATCH (tracker:Tracker {trackerId: $trackerId})
WITH tracker
OPTIONAL MATCH (tracker)-[r_issued_by:ISSUED_BY]-&gt;(organization:Organization)
WITH tracker, COLLECT(r_issued_by) AS organization_rels, COLLECT(DISTINCT organization) AS organizations 
OPTIONAL MATCH (tracker)-[r_assigned_to:ASSIGNED_TO]-&gt;(asset:Asset)
RETURN tracker, organization_rels, organizations, COLLECT(r_assigned_to) AS asset_rels, COLLECT(DISTINCT asset) AS assets;&quot;)
```

Looking at your annotations it looks like both `ISSUED_BY` and `ASSIGNED_TO` are outgoing relationships from `:Tracker`?

the collects are because of this:

https://community.neo4j.com/t/sdn-rx-dynamic-relationships-not-being-populated-with-custom-query/24456
",3,66767861
2732,https://stackoverflow.com/a/67027000,SpringData Neo4j @Query does not populate @Relationship Nodes,false,"@false_memories has it right, but the `WITH` clause isn&#39;t necessary in this case. If you&#39;re just using variables from the match clause, you don&#39;t need a `WITH`. You need a `WITH` only if you&#39;re manipulating the variables in some way:

https://neo4j.com/docs/cypher-manual/current/clauses/with/#with-filter-on-aggregate-function-results

In addition, looks like your relationships are required from your `@NotNull` annotations, so you should drop the `OPTIONAL`

So a slightly better query is:
```
@Query(&quot;MATCH (tracker:Tracker {trackerId: $trackerId})
MATCH (tracker)-[r_issued_by:ISSUED_BY]-&gt;(organization:Organization)
MATCH (tracker)-[r_assigned_to:ASSIGNED_TO]-&gt;(asset:Asset)
RETURN tracker,
  COLLECT(r_issued_by), COLLECT(organization) AS organization,
  COLLECT(r_assigned_to), COLLECT(asset) AS asset&quot;)
```

I like to match the `as` clause to my actual relationship names because it makes it appear a little cleaner when looking at raw results.",0,67027000
2733,https://stackoverflow.com/a/67229762,apoc.load.jsonParams as POST request with Body input parameters,true,"From the apoc.load.jsonParams documentation:

&gt; apoc.load.jsonParams(urlOrKey :: STRING?, headers :: MAP?, payload ::
&gt; STRING?, path =  :: STRING?, config = {} :: MAP?) :: (value :: MAP?)

Transport the body as payload parameter and convert it with `apoc.convert.toJson` to Json string list. Also it&#39;s needed to define the `Content-Type` as `application/json` in the header. (do not overlook the backticks)

    CALL apoc.load.jsonParams(&quot;http://192.168.1.128:4040/api/getJson?id=17&quot;, 
    {`Content-Type`:&quot;application/json&quot;}, apoc.convert.toJson([&quot;DATA1&quot;, &quot;DATA2&quot;]), &quot;$.BusinessData[*]&quot;) YIELD value as item

",0,67229762
2734,https://stackoverflow.com/a/66746106,Delete the previous node and relationship and point it to the current node with same relationship,true,"Two problems with your query:

1. You&#39;re deleting the parent, the child, and the relationship. You can&#39;t create a new relationship to a new child if you just deleted the parent. Also you&#39;re deleting the child you just created, not the current child of the parent, so that needs fixing too.

2. If a MATCH fails, then there are no rows to execute upon, and nothing else will happen in the query. You may want an OPTIONAL MATCH instead, or maybe a pattern comprehension.

You could give this a try instead:

    MERGE (p:Parent {name:&#39;Parent&#39;})
    WITH p, [(p)-[:parent_of]-&gt;(existing) | existing] as existingChildren
    FOREACH (child IN existingChildren | DETACH DELETE child)
    MERGE (c:Child {name:&#39;CA&#39;})
    CREATE (p)-[:parent_of]-&gt;(c)",0,66746106
2735,https://stackoverflow.com/a/66746210,Delete the previous node and relationship and point it to the current node with same relationship,false,"Try this, it works on my neo4j desktop;
&gt;1. Find that relationship between CA and parent (OPTIONAL because it will continue the query if there is no match found)
&gt;2. Delete the relationship
&gt;3. Find that parent and create if not found (MERGE)
&gt;4. Using the child and parent nodes, create a new relationship

    OPTIONAL MATCH (c:Child)-[r:parent_of]-(:Parent{name:&#39;Parent&#39;})
    DELETE r
    MERGE (p2:Parent{name:&#39;Parent&#39;})
    MERGE (p2)-[r2:parent_of]-&gt;(c2:Child{name:&#39;CA&#39;})
    RETURN c2, r2, p2

You cannot delete c and p since it is still part of the query during create.",0,66746210
2736,https://stackoverflow.com/a/66749228,Passing parameters to gds.create.graph in Neo4j,true,"

&gt;1) We need to return both nodes Criminal and Crime. Im getting an error if Crime nodes are missing
&gt;2) The syntax for parameters should include {}. For example: {parameters: { node_ids: ext_param }}.  Please also note to use a different name like ext_param.
&gt;3) Then in Python, replace the word ext_param using the replace function but convert the list as a string


    query = &quot;&quot;&quot;
    CALL gds.graph.create.cypher(
        &#39;betweenness&#39;,
        &#39;MATCH (n) WHERE n:Criminal OR n:Crime RETURN id(n) AS id, labels(n) AS labels&#39;,
        &#39;MATCH (a:Criminal)-[r:INVOLVED_IN]-&gt;(c:Crime) WHERE id(a) in $node_ids RETURN id(a) AS source, id(c) AS target, type(r) AS type&#39;,
        {parameters: { node_ids: ext_param }}
    )
    YIELD graphName, nodeCount, relationshipCount, createMillis;
    &quot;&quot;&quot;
    
    ext_param = [5, 6, 7, 8, 31]
    graph.run(query.replace(&#39;ext_param&#39;, str(ext_param))).data()

    Result:
     [{&#39;graphName&#39;: &#39;betweenness&#39;,
      &#39;nodeCount&#39;: 10,
      &#39;relationshipCount&#39;: 12,
      &#39;createMillis&#39;: 22}]

Reference:
Look for section 4: Node labels in [here][1]


  [1]: https://neo4j.com/docs/graph-data-science/current/management-ops/cypher-projection/",1,66749228
2737,https://stackoverflow.com/a/66744281,How to avoid duplicate while creating node using apoc.periodic.iterate for csv load neo4j?,false,"With parallel execution, you need a unique constraint on :PERSON(name), as unique constraints have schema locks that prevent duplicate creation in this situation. 

If names aren&#39;t unique, then either disable parallel import or clean your data so there are no duplicates.

You could also lock on a singular node before the MERGE to guarantee mutual exclusion, but that has the same affect as disabling parallel execution, so toggling parallel to false is the better option.

**EDIT**

So the problem you&#39;re running into here is that your MERGE isn&#39;t backed by a unique constraint. In order to get this, both the property and the label for the constraint *must be present in the pattern*, it won&#39;t work if you only have them in the ON CREATE or ON MATCH sections.

So if your constraint is on `:PERSON(pid)`, then your pattern should be:

    MERGE (l:PERSON {pid:payload.id})

and then you can set the name in the ON CREATE section.

If names are supposed to be unique, then you can get the same effect by creating a unique constraint on `:PERSON(name)`

While you can use EXPLAIN on the query to get the query plan, since this is a query string, you will need to do some cut and pasting to see the plan for the query in question, as well as make a small addition at the top so the query can compile. You can try this:

    EXPLAIN
    WITH $payload as payload
    MERGE (l:PERSON {name :payload.name})
     ON CREATE SET 
                  l.pid = payload.id,             
                  l.createdDate= timestamp(),
                  l.lastModifiedDate= timestamp()             
     ON MATCH SET 
                  l.lastModifiedDate= timestamp()

You want to see a `NodeUniqueIndexSeek(Locking)` operator in the plan in order for the MERGE to work correctly and use correct locking to prevent duplicates.

If you see `NodeIndexSeek` then only an index is being used, it won&#39;t prevent duplicates as there&#39;s nothing to lock on to guarantee mutual exclusion. You need that unique constraint.

And if `NodeByLabelScan` is there instead, that&#39;s even worse, as you don&#39;t have a unique constraint or an index backing your MERGE. If execution time was a problem for you earlier, it&#39;s probably because it was doing a label scan, which won&#39;t perform well at all for loading.",1,66744281
2738,https://stackoverflow.com/a/66744093,Bipartite graph projection via Cypher query Neo4j,true,"Good description, thanks for specifying the desired output.

What you are looking for are paths where two people give the same rating to the same movie, and then count those occurrences between the two people to get the weight so you can create the relationship between them.

We can use a simpler query to get the results you need.

    MATCH (u1:User)-[r:RATED_MOVIE]-&gt;(m:Movie)&lt;-[r2:RATED_MOVIE]-(u2)
    WHERE id(u1) &lt; id(u2) AND r.rating = r2.rating
    WITH u1, u2, count(m) as weight
    CREATE (u1)-[:CONNECTED {common_movies_rated:weight}]-&gt;(u2)
    RETURN u1, u2",0,66744093
2739,https://stackoverflow.com/a/66749382,py2neo: using cypher inline gives 404 error,false,"I am using py2neo most of the time. Here is how I connect to my local neo4j db.

    from py2neo import Graph
    graph = Graph(&quot;bolt://localhost:7687&quot;, auth=(&quot;neo4j&quot;, &quot;xxxxx&quot;))
    try:
        graph.run(&quot;Match () Return 1 Limit 1&quot;)
        print(&#39;ok&#39;)
    except Exception:
        print(&#39;not ok&#39;)",0,66749382
2740,https://stackoverflow.com/a/66773143,code: &#39;Neo.ClientError.Security.Unauthorized&#39;,false,I have finally managed to delete the neo4j and installed a new one and solved the issue,0,66773143
2741,https://stackoverflow.com/a/66752800,neo4j server side javascript,false,"A simple architecture that does what you want, plus mitigates the risk of opening up your database to everyone uses a HTTP server + API that are accessible via your noip provider.

Your public facing frontend (HTML + JavaScript (for making API calls etc)) makes the HTTP(s) calls to your publicly accessible API (for example a nodejs server) to make the database calls. Cypher/a direct database connection to neo has no place in your users&#39; browsers.

You can also use a starter like the [GRANDstack][1].


  [1]: https://grandstack.io/",0,66752800
2742,https://stackoverflow.com/a/66750173,How to optimise recursive query - Neo4j?,false,"For this one, unfortunately, there are some limitations on our syntax for filtering these more complex conditions during expansion. We can cover post-expansion filtering, but you&#39;d want an upper bound otherwise this won&#39;t perform well on a more complex graph. 

To get what you need today (filtering during-expansion instead of after), you would need to implement a custom procedure in Java leveraging our traversal API, and then call the procedure in your Cypher query.

Advanced syntax that can cover these cases has already been proposed for [GQL](https://www.gqlstandards.org/), and we definitely want that in Cypher. It&#39;s on our backlog.",1,66750173
2743,https://stackoverflow.com/a/66730316,neo4j delete nodey with children and without,true,"Add a 0 as the lower bound for the variable-length pattern. By default it&#39;s 1, but when it&#39;s 0 (provided the label used for the end node is also on the start node) this will allow it to match even when there are no relationships from the start node.


    MATCH path = (c:Category)-[*0..]-&gt;(cc:Category)
    WHERE c.id = &quot;95bec604-5da2-4297-b792-5a866e292df4&quot;
    DETACH DELETE path",1,66730316
2744,https://stackoverflow.com/a/66730648,neo4j delete nodey with children and without,false,"In general, this approach would work if you want to delete the entire path:

    MATCH path = ( some path )
    FOREACH (node IN nodes(path)  | 
         DETACH DELETE node
    )",0,66730648
2745,https://stackoverflow.com/a/66708840,How to unify results of multiple NEO4J queries,false,"Below is the query to get the name, countries and friends in one query. Please remove OPTIONAL in countries or friend if a country or friend is required.

    MATCH (p:people)
    WITH p
    OPTIONAL MATCH (p)-[:live_in]-&gt;(c:countries)  
    WITH p, c.name AS countries
    OPTIONAL MATCH (p)-[:has_friend]-&gt;(n:people) 
    RETURN p.name AS name, countries, n.name AS friends",0,66708840
2746,https://stackoverflow.com/a/66719491,How to unify results of multiple NEO4J queries,false,"The output format you probably want here is one row per person, with a list of their countries, and a list of their friends. 

This is easiest to do with pattern comprehensions to capture the results of a pattern expansion into a list. This has the advantage of coping with cases where the pattern doesn&#39;t exist, as you get an empty list without wiping out the row.

Also it makes more sense to use singular tense for node labels. `:Person` instead of `:people`, since a result from a MATCH pattern will be a person, not a group of persons.

Using singular tense, capital case for labels, and all caps for relationship types:


    MATCH (p:PERSON)
    WITH p, [(p)-[:LIVES_IN]-&gt;(c:Country) | c.name] as countries,
     [(p)-[:HAS_FRIEND]-&gt;(f:Person) | f.name] as friends
    RETURN p.name AS name, countries, friends",0,66719491
2747,https://stackoverflow.com/a/66720160,Cypher Query - Collect two separate types of nodes connected to a third type of node,true,"One thing that will help is that aggregations are not the only way to get the result from matched patterns into a list. You can use [pattern comprehensions](https://neo4j.com/docs/cypher-manual/current/syntax/lists/#cypher-pattern-comprehension) instead, which may simplify your query.

Also I&#39;m going to assume that there is a :HAS_END_AIRPORTS relationship to end airports of a trip, and that we should use that to get end airports.

    MATCH (t:Trip {uid: $tripId})
    OPTIONAL MATCH (t)-[:HAS_WAYPOINTS]-(w {active: true})
    WITH t, w, 
     [(w)-[wa:HAS_AIRPORT]-(a:NeoAirport) | a {.*, active:wa.active}] as airports, 
     [(w)-[wp:HAS_POI {active: true}]-(p:PointOfInterest) | p {source:wp.source, .uid, .placeId}] as pointsOfInterest
    WITH t, collect(w {.*, airports, pointsOfInterest}) as waypoints
    WITH t, waypoints, 
     [(t)-[:HAS_START_AIRPORTS]-(sa) | sa] as startAirports,
     [(t)-[:HAS_END_AIRPORTS]-(ea) | ea] as endAirports
    RETURN t {.*, waypoints, startAirports, endAirports} as trips",1,66720160
2748,https://stackoverflow.com/a/66708196,Is it possible to get Lucene scoring as a number between 0 and 1?,false,"I believe that the default scoring out of box for Lucene does score between 0 to 1, however once boosting or other custom scoring is involved then the score value can be any positive value that fits in a float.  

However, you can easily normalize the scores into the range of 0 to 1 by dividing each hit&#39;s score by the max score of any hit in the query as stated by this [StackOverflow answer](https://stackoverflow.com/questions/5158138/what-does-lucenes-scoredoc-score-mean#answer-5159227).
",1,66708196
2749,https://stackoverflow.com/a/66699474,Connection Unavailable : Trying to connect locally hosted Neo4j from docker app,false,"This seems to be a problem of `docker` and how it&#39;s built.

Basically, if you try to access `localhost` from a container, you&#39;ll access the container&#39;s localhost, not the one of your computer!

The idea is to get the ip address of the docker container of your network and use that one instead.

Here are some links that show how to do it, based on the platform you&#39;re on (I&#39;m considering also other users may find this answer and rely on it)

[https://stackoverflow.com/questions/44649438/localhost-refuses-connection-with-docker][1]

[https://stackoverflow.com/questions/41154794/how-to-access-http-localhost-from-a-docker-container-in-windows][2]


  [1]: https://stackoverflow.com/questions/44649438/localhost-refuses-connection-with-docker
  [2]: https://stackoverflow.com/questions/41154794/how-to-access-http-localhost-from-a-docker-container-in-windows",0,66699474
2750,https://stackoverflow.com/a/66694285,Unexpected result with apoc.text.sorensenDiceSimilarity?,true,"This is definitely a bug and a good catch!

As alternative you can do below query which uses apoc functions as toSet and intersection and text function, split.  There is hack on the query that uses ROUND(10^4/10^4) to use 4-decimal places. If you like my answer, please vote and accept it. Thanks.

    WITH apoc.coll.toSet(split(&quot;+46xxxxx2260&quot;,&quot;&quot;)) as set1, apoc.coll.toSet(split(&quot;+46xxxxx2226&quot;,&quot;&quot;)) as set2
    WITH set1, set2, apoc.coll.intersection(set1, set2) as common 
    RETURN ROUND(2*size(common)*10^4/(size(set1)+size(set2)))/10^4 as sorensenDiceSimilarity
   
    Result:
    0.9091",1,66694285
2751,https://stackoverflow.com/a/66692560,How to find Node with the most similarities Neo4j,false,"&gt; 1. Your node Store must have a property name, like name: &quot;Store 1&quot;, etc.
&gt; 2. Ensure that you installed the data science plugin. If not, follow the installation [here][1] 
&gt; 3. Below query is based on &#39;jaccard&#39; similarity algorithm. If you want more about other similarity algorithms, see [here][2]


a. Get all store(s) with stocks of these car brands 
b. Collect the data as store items and car brands as categories 
c. Compute the jaccard similarity index and return only for a store named: &#39;Store 1&#39;

    MATCH (s:Store)-[r:INSTOCK]-&gt;(b:Brand)
    WITH {item:id(s), categories: collect(id(b))} AS userData
    WITH collect(userData) AS data
    CALL gds.alpha.ml.ann.stream({
       data: data,
       algorithm: &#39;jaccard&#39;
     })
     YIELD item1, item2, similarity
     WITH  gds.util.asNode(item1).name AS Store1, gds.util.asNode(item2).name AS StoreX, similarity WHERE Store1 = &#39;Store 1&#39;
     RETURN  Store1, StoreX, similarity
     ORDER BY StoreX

If you want to compute it manually, then the jaccard similarity index of Store 1 to Store X (where X is any store # &gt; 1) is the number of common car brands between Store 1 and Store X and divided by the number of total unique car brands of Store 1 plus Store X.  For example; Store1 to Store2 is 2/11 or 0.1818 since there are 2 common brands (Porsche and Toyota) and Store1 plus Store2 is 11 unique brands.

  [1]: https://neo4j.com/docs/graph-data-science/current/installation/
  [2]: https://neo4j.com/docs/graph-data-science/current/algorithms/node-similarity/#algorithms-node-similarity",0,66692560
2752,https://stackoverflow.com/a/66693434,How to specify maximum cost when running BFS Neo4j?,false,"[Here][1] is the list of procedures and functions for your reference.  As you can see, Breadth First Search is still in Alpha stage and no estimate function is available yet. You can also see that functions in Beta and Production stages have this function *.estimate. These functions will give you an idea of how much memory will be used when you run those data science related functions. An example of  gds.nodeSimilarity.write.estimate can be found below

      CALL gds.nodeSimilarity.write.estimate(&#39;myGraph&#39;, {
      writeRelationshipType: &#39;SIMILAR&#39;,
      writeProperty: &#39;score&#39;})
      YIELD nodeCount, relationshipCount, bytesMin, bytesMax, requiredMemory
  

     nodeCount	relationshipCount	bytesMin	bytesMax	requiredMemory
     9          9                   2592        2808        &quot;[2592 Bytes ... 2808 Bytes]&quot;


  [1]: https://neo4j.com/docs/graph-data-science/current/appendix-a/#appendix-a-graph-ops",0,66693434
2753,https://stackoverflow.com/a/66693017,Database failed to create: Error: Could not change password - Neo4j Desktop 1.4.3,false,"I have the same problem when upgrading to a newer version of Neo4j Desktop.  This what I did to fix it.  The problem is there are some settings on the older version that is causing the issue.

1. Neo4j Desktop folder for example: C:\Users\&lt;mylogin&gt;\.Neo4jDesktop\
2. Delete the ENTIRE folder
3. Install the newer version",0,66693017
2754,https://stackoverflow.com/a/66684376,NEO4J - Optional query very slow,false,"It&#39;s a little strange that you&#39;re getting all this optional info (app, ranking, note, reviewer) but you&#39;re not doing anything with it. You&#39;re not returning any of that, you&#39;re only returning information from the vintage. 

If you&#39;re not going to use it, don&#39;t match to it. 

But if your intent is to make sure at least one of such paths exist per pattern, use a WHERE clause for these, that will also avoid cross product issues if multiple paths exist for some of the OPTIONAL MATCHes. 

But since you&#39;re using OPTIONAL MATCHes, it seems like you don&#39;t want their presence in the graph or absence to control whether or not the vintage is returned. As such, they aren&#39;t serving any purpose, and are only making your query slower. The only hard requirement you seem to have is that the :Vintage is made from :Wine (though if all :Vintages are made from :Wine, you can remove that part too). We&#39;ll keep that and remove the others.

Also your calculation for the total vintages isn&#39;t correct. Since you are using OPTIONAL MATCHes, you don&#39;t care about a vintage meeting the patterns there, so we can just total the vintages before MATCHING to the individual nodes.

Lastly it wasn&#39;t clear that you&#39;re only looking for a subset of nodes, so we can do away with the list slice approach and use SKIP and LIMIT instead. This is also probably why your query is taking so long...it&#39;s calculating all vintage information, but you&#39;re only taking a slice of it at the end, so you&#39;re doing a lot of work that is only thrown away at the end.

Try this instead:

    MATCH (vintage:Vintage)
    WHERE (vintage)-[:MADE_FROM]-&gt;(:Wine)
    WITH count(vintage) as total
    
    MATCH (vintage:Vintage)
    WHERE (vintage)-[:MADE_FROM]-&gt;(:Wine)
    WITH total, vintage
    ORDER BY vintage.code ASC, vintage.year DESC
    SKIP 0
    LIMIT 10
    WITH total, collect({ uid: vintage.uid, year: vintage.year, cv: vintage.referencePrice}) as vintages
    RETURN { vintages:vintages, total:total} as vintage

If there was a purpose to those OPTIONAL MATCHes, please explain in comments, and I&#39;ll see how the query can be modified to handle them.",0,66684376
2755,https://stackoverflow.com/a/66677130,How to llst nodes by relating multiple other nodes,true,"Your query will not be true because c.name cannot be both blue and purple at the same time. This is how you will get phones that are available in both blue and purple

&gt; 1. Get all phones that has colour blue or purple
&gt; 2. Collect all distinct colours as a set
&gt; 3. Check that the each item on this set(colours) have blue or purple colour

    WITH [&quot;blue&quot;, &quot;purple&quot;] as blue_purple 
    MATCH (p:Phone)-[r:AVAILABLE]-(c:Colour) 
        WHERE c.name in blue_purple
    WITH blue_purple, p as phone, collect(distinct c.name) as colours
        WHERE size([co in colours WHERE co in blue_purple]) = 2
    RETURN phone",0,66677130
2756,https://stackoverflow.com/a/66676398,How does cypher ignore the space in CSV format?,false,"There is string function that removes space(s) before and after the original string.

https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-trim

&gt;trim(&#39;str&#39;) 

    For example: RETURN trim(&#39;   hello   &#39;)  will return &quot;hello&quot;",1,66676398
2757,https://stackoverflow.com/a/66675735,org.neo4j.driver.exceptions.ClientException: The server does not support any of the protocol versions supported by this driver,true,"Neo4j OGM 3.2 requires at least Neo4j 3.5.x (as you can see [here][1]), but you&#39;re using Neo4j 3.0.x.
Note: the latest OGM version is 3.2.21.


  [1]: https://github.com/neo4j/neo4j-ogm/wiki/Versions#recommended-versions",1,66675735
2758,https://stackoverflow.com/a/66667496,Cannot merge the following node because of null property value for &#39;src&#39;: (:Node {src: null}),false,"When creating properties in Neo4j you cannot have null properties.

There are a number of ways to work around this, but a quick option to just get some data in could be to use [coalesce()][1] function, which will use the first non-null value it hits, e.g.

    CALL apoc.load.json(&quot;file:/graph-phase1-labelled.json&quot;) YIELD value
    UNWIND value.nodes as nodes
    UNWIND nodes.properties as prop
    MERGE(n1:Node{src:coalesce(prop.sourceIP,&quot;No IP&quot;)})
    MERGE(n2:Node{dst:coalesce(prop.destIP, &quot;No IP&quot;})
    WITH n1,n2,prop
    MERGE (n1)-[:CONNECTED_TO]-&gt;(n2)
    RETURN n1,n2,prop


  [1]: https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-coalesce",0,66667496
2759,https://stackoverflow.com/a/66675517,Cannot merge the following node because of null property value for &#39;src&#39;: (:Node {src: null}),false,"Thanks for your answer, the issue was that the dump that I was trying to build the graph upon had some null properties and I had to ignore them to go ahead with the rest of the nodes. the &quot;No IP&quot; did not work but I managed to solve it     
by below:

        call apoc.load.json(&quot;file:/graph-phase1-labelled1.json&quot;) yield value
        unwind value.nodes as nodes
        unwind nodes.properties as prop 
        with prop where prop.sourceIP is not null
        with prop where prop.destIP is not null
        merge(n1:Node{src:prop.sourceIP}) 
        merge(n2:Node{dest:prop.destIP}) 
        with prop,n1,n2
        merge (n1)-[ :connected_to]-&gt;(n2)
        return n1,n2,prop
",0,66675517
2760,https://stackoverflow.com/a/66656598,Cypher creating n number of nodes,true,"You can do like this:

    UNWIND range(0, 100) AS id
    CREATE (n:GridCell {name: id})


Documentation:
- [range()][1]
- [UNWIND][2]


  [1]: https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-range
  [2]: https://neo4j.com/docs/cypher-manual/current/clauses/unwind/",3,66656598
2761,https://stackoverflow.com/a/66673042,Neo4J on AWS t2.micro,true,"You can subcribe to your free AWS t2.micro and install it by yourself. This is what I did before;

&gt;1. Subcribe to a free t2.micro tier up to 12-months. 
&gt;2. Download the neo4j community edition [here][1]:  


  [1]: https://go.neo4j.com/download-thanks.html?edition=community&amp;release=3.5.26&amp;flavour=unix&amp;_gl=1*17hurkn*_ga*OTg5MjU4NTI4LjE2MTU5ODM2NjY.*_ga_DL38Q8KGQC*MTYxNTk4MzY2NS4xLjAuMTYxNTk4MzY2NS4w&amp;_ga=2.236338241.1770078764.1615983666-989258528.1615983666
&gt; 3. Upload the installation file to your AWS server
&gt; 4. Install your neo4j and manage it yourself.",1,66673042
2762,https://stackoverflow.com/a/66673236,Export CSV from Neo4j to AWS S3 failed,false,"You forgot to download and copy the apoc jar file to plugins folder.

&gt; Here is apoc [ver 4.1.0.6][1] 


  [1]: https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases/download/4.1.0.6/apoc-4.1.0.6-all.jar
&gt; Copy it to your $HOME_NEO4J/plugins/ directory.
&gt; Also, please ensure that you set this in neo4j.conf config file:  **apoc.export.file.enabled=true** then do a restart

APOC is not included when you install neo4j, so you need to copy it.",0,66673236
2763,https://stackoverflow.com/a/66656192,Refactor cypher query for batchquery using apoc,false,"After a good nights sleep I realized I had overcomplicated things a bit and have come up with this solution: 

```
    UNWIND $attribs as row
    CALL apoc.merge.node.eager([&quot;Entity&quot;, row.type_], {ent_id: row.ent_match_crit}, {literal_forms: []}, {}) yield node as n1
    with n1, row.literal_form as lf, n1.literal_forms as node_literals
    SET n1.literal_forms = apoc.coll.toSet(node_literals + lf)
    RETURN n1
```
This query works as expected.

Let me know if anyone sees a better way to do this :)
",0,66656192
2764,https://stackoverflow.com/a/66648687,Cypher query for the .json format with Null proper,false,"Since you cannot merge on null properties, you have to filter out the rows which have nulls in them. Example:

    CALL apoc.load.json(&quot;file:/graph-phase1-labelled.json&quot;) YIELD value
    
    UNWIND value.nodes as nodes
    
    UNWIND nodes.properties as prop

    WHERE prop.sourceIP IS NOT NULL prop.destIP IS NOT NULL
    WITH prop
    
    MERGE(n1:Node{src:prop.sourceIP})
    
    MERGE(n2:Node{dst:prop.destIP})
    
    WITH n1,n2,prop
    
    MERGE (n1)-[:CONNECTED_TO]-&gt;(n2)
    
    RETURN n1,n2,prop",1,66648687
2765,https://stackoverflow.com/a/66665483,Cypher query for the .json format with Null proper,false,"I have managed to solve the issue by below query:

    call apoc.load.json(&quot;file:/graph-phase1-labelled1.json&quot;) yield value
    
    unwind value.nodes as nodes
    
    unwind nodes.properties as prop 
    
    with prop where prop.sourceIP is not null
    
    with prop where prop.destIP is not null
    
    merge(n1:Node{src:prop.sourceIP}) 
    
    merge(n2:Node{dest:prop.destIP}) 
    
    with prop,n1,n2
    
    merge (n1)-[ :connected_to]-&gt;(n2)
    
    return n1,n2,prop",0,66665483
2766,https://stackoverflow.com/a/66648245,Neo4j Cypher: How to optimize a NOT EXISTS Query when cardinality is high,true,"Yes, this can be improved.

First, let&#39;s understand what this is doing.

First, it starts with a NodeByLabelScan. That makes sense, there&#39;s no avoiding that. 

But then, for every node of the label (the following executes PER ROW!), it matches to user 2, and expands all :VIEWED relationships from user 2 to see if any of them is the post for that particular row.

Can you see why this is inefficient? There are 8630 post nodes according to the PROFILE plan, so user 2 is looked up by index 8630 times, and their :VIEWED relationships are expanded 8630 times. Why 8630 times? Because this is happening per :Post node.

Instead, try this:

    MATCH (:User{ID: 2})-[:VIEWED]-&gt;(viewedPost)
    WITH collect(viewedPost) as viewedPosts
    MATCH (:User)-[:CREATED]-&gt;(p:Post) 
    WHERE NOT p IN viewedPosts 
    RETURN p.ID

This changes things up a bit.

First it matches to user 2&#39;s viewed posts (the lookup and expansion is performed only once), then those viewed posts are collected.

Then it will do a label scan, and filter such that the post isn&#39;t in the collection of viewed posts.",1,66648245
2767,https://stackoverflow.com/a/66684668,Neo4j: How to return a single path for each pair of nodes that have multiple relationships,true,"This is easier if you are using subqueries (Neo4j 4.1.x or higher). That&#39;s because the subquery can help scope the operations you need to perform (collect(), in this case) to expansions and work from a single country, per country, instead of having to perform it across all rows for the entirety of the query, which could stress the heap.

In reality, since the number of countries are low, it won&#39;t be a problem, but it&#39;s a good approach to use when dealing with larger sets of nodes.

    MATCH (country:Country)
    CALL {
     WITH country
     MATCH path = (country)&lt;-[:FROM_AREA]-(:Artist)-[:RECORDING_CONTRACT]-&gt;(:Label)-[:FROM_AREA]-&gt;(other:Country)
     WHERE id(country) &lt; id(other)
     RETURN other, collect(path)[0] as path
     LIMIT 20
    }
    RETURN country, path
    LIMIT 20

Let&#39;s look at what this is doing.
We MATCH to :Country nodes.

Per country we will MATCH to the pattern you&#39;re looking for. If these are the only such paths and labels in the graph, then you can omit the labels in the pattern, as the relationship types should be enough to find the correct nodes.

The `WHERE id(country) &lt; id(other)` is here to prevent mirrored results. For example, in the course of the query if we find a path from `(United Kingdom)-[*]-(United States)`, and we also find a path the other direction, for `(United States)-[*]-(United Kingdom)`, you probably don&#39;t want to return both. So we place a restriction on the graph ids so that only one of these will meet the restriction, and the mirrored result gets filtered out.

We use `RETURN other, collect(path)[0] as path` to get a single path per the country and other nodes. Remember that this is happening inside a subquery being called per country node, so even though `country` is not present here, this operation is being performed for a specific country node. 

When we aggregate (such as with this `collect(path)`, the grouping key (usually the non-aggregation variables) become distinct, so for the country and the other country, this will collect all the paths between them and then take the first of that list of paths, so we get our single path between two distinct countries.

We LIMIT the subquery results to 20, since we know in total we don&#39;t want more than 20 paths, so per country we don&#39;t want more than 20 paths either. This might be a bit redundant for this case, but when the query is more complex it is the right approach to make sure you&#39;re not doing more work than is needed.

We also have another LIMIT outside the subquery, so that if there are only a few countries processed, with a few paths per country, the total paths won&#39;t exceed 20.",1,66684668
2768,https://stackoverflow.com/a/66639252,How to connect to neo4j database from android app (with java code)?,true,"If you want to talk directly to Neo4j, you can use either:
- [The HTTP API](https://neo4j.com/docs/http-api/current/introduction/#http-api-introduction)
- [The Binary Bolt Protocol](https://github.com/neo4j-drivers/boltkit)

If you would rather use middleware, there are many many different options:
- [Java](https://neo4j.com/developer/java/)
- [.NET](https://neo4j.com/developer/dotnet/)
- [JavaScript](https://neo4j.com/developer/javascript/)
- [Python](https://neo4j.com/developer/python/)
- [Go](https://neo4j.com/developer/go/)
- [Ruby](https://neo4j.com/developer/ruby/)
- [PHP](https://neo4j.com/developer/php/)
- [...](https://neo4j.com/developer/language-guides/)

When building mobile apps my *personal* preference is to build a standard API in a middleware server then use HTTPS calls from the app ([neo4j-graphql-js](https://grandstack.io/docs/neo4j-graphql-js-quickstart/) has also been awesome for a couple projects), but there are enough stacks that you have the freedom to do it your way.
",0,66639252
2769,https://stackoverflow.com/a/66644058,Is there a way to store dynamic Cypher query into python variable?,true,"I used dictionary to get this resolved. I used dictionary over the cypher query to get it resolved:

    for index,row in df_data.iterrows():
            t_dict = {}
            for k in p_dict.keys():
                try: 
                    t_dict[k] = int(row[k])
                except TypeError:
                    t_dict[k] = row[k]
            tx.evaluate(cq,t_dict)",1,66644058
2770,https://stackoverflow.com/a/66629921,Can I load in nodes and relationships from a csv file using 1 cypher command?,true,"You should review the documentation for indexes here:
https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/

Basically, indexes, once created, allow quick lookups of nodes of a given label, for the given property or properties. If you DON&#39;T have an index and you do a MATCH or MERGE of a node, then for every row of that MATCH or MERGE, it has to do a label scan of all nodes of the given label and check all of their properties to find the nodes, and that becomes very expensive, especially when loading CSVs because those operations are likely happening *for each row in the CSV*.

For your :lapTimes nodes (though we would recommend you use singular labels in most cases), if there are none of them in your graph to start with, then a CREATE instead of a MERGE is fine. You may want a composite index on `:lapTimes(raceId, driverId, lap)`, since that should uniquely identify the node, if you need to look it up later. Using CREATE instead of MERGE here should process much much faster.

Your second query should be MATCHing on :lapTimes nodes (label scan), and from each doing an index lookup on the :race and :driver nodes, so indexes are key here for performance.

You need indexes on: `:race(raceId)` and `:Driver(driverId)`.

    MATCH (lt:lapTimes)
    WITH lt, lt.raceId as raceId, lt.driverId as driverId
    MATCH (d:Driver), (r:race)
    WHERE r.raceId = raceId AND d.driverId = driverId
    MERGE (d)-[:LAPPING_AT]-&gt;(lt)
    MERGE (r)-[:TIMED_LAP]-&gt;(lt)

You might consider CREATE instead of MERGE for the relationships, if you know there are no duplicate entries.

I removed your RETURN because returning the types isn&#39;t useful information.

Also, consider using consistent cases for your node labels, and that you are using the same case between the labels in your graph and the indexes you create.

Also, you would probably want to batch these changes instead of trying to process them all at once.

If you install APOC Procedures you can make use of `apoc.periodic.iterate()`, which can be used to batch changes, which will be faster and easier on your heap. You will still need indexes first.

    CALL apoc.periodic.iterate(&quot;
     MATCH (lt:lapTimes)
     WITH lt, lt.raceId as raceId, lt.driverId as driverId
     MATCH (d:Driver), (r:race)
     WHERE r.raceId = raceId AND d.driverId = driverId
     RETURN lt, d, ir&quot;,
     &quot;MERGE (d)-[:LAPPING_AT]-&gt;(lt)
     MERGE (r)-[:TIMED_LAP]-&gt;(lt)&quot;, {}) YIELD batches, total, errorMessages
    RETURN batches, total, errorMessages


**Single CSV load**

If you want to handle everything all at once in a single CSV load, you can do that, but again you will need indexes first. Here&#39;s what you&#39;ll need at a minimum:

    CREATE INDEX ON :Driver(driverId);
    CREATE INDEX ON :Race(raceId);

After those are created, you can use this, assuming you are starting from scratch (I fixed the case of your labels and made them singular:

    USING PERIODIC COMMIT 25000
    LOAD CSV WITH HEADERS from &#39;file:///lap_times.csv&#39; AS row
    MERGE (d:Driver {driverId:row.driverId})
    MERGE (r:Race {raceId:row.raceId})
    CREATE (lt:LapTime {raceId: row.raceId, driverId: row.driverId, lap: row.lap, position: row.position, time: row.time, milliseconds: row.milliseconds})
    CREATE (d)-[:LAPPING_AT]-&gt;(lt)
    CREATE (r)-[:TIMED_LAP]-&gt;(lt)",0,66629921
2771,https://stackoverflow.com/a/66625216,How to display relation ship property on the arrow itself in Neo4J?,true,"Same way as you do so for nodes.
Select the relationship type (in my example attached, it is CITY), then select the property to be displayed as a caption (in my example, it is since)
[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/orYnD.png",1,66625216
2772,https://stackoverflow.com/a/66676622,I get inconsistent outcomes in Spring Data Neo4j when mapping both ends of a relationship and saving it,false,"I am a little bit unsure about the right query, but your custom Cypher statement does not return all friends and relationships for deeper links.
Changing it to:
```
MATCH (user:User{email: \$email})
OPTIONAL MATCH path=(user)-[:FRIEND_REQUEST*]-(friend:User)
WITH user, friend, relationships(path) as friend_requests
RETURN user, collect(friend_requests), collect(distinct(friend))
```
solved this for me (or the ten test runs were just randomly green).
Another solution would be, to avoid the custom query, define `findByEmail(email: String): User` and let Spring Data Neo4j create the query.

The problem that occurs is that
```
First operation:
frodo -&gt; sam
sam -&gt; frodo

Second operation:
frodo -&gt; bilbo
bilbo -&gt; frodo
```
results for _Sam_ in something like `sam-frodo-bilbo`.
When you load _Frodo_ or _Bilbo_ the relationships are not completely hydrated to _Sam_.
The moment you save _Bilbo_ (or _Frodo_), SDN will through all relationship and eventually not find the _Sam_ relation. Because it is empty, SDN will remove the relationship on save.

Another problem I have seen in your code:
You should definitely annotate the manual defined constructor with `@PersistenceConstructor` because Kotlin creates an invisible copy constructor and Spring Data in general does not know which to choose. So you might randomly run into the copy constructor.",0,66676622
2773,https://stackoverflow.com/a/66605944,Having errors writing a Cypher query that gets the destination of a bus,false,"The arrow `-&gt;` is always going from the outside of a relationship pattern `[]`.

This is valid : 

* `&lt;-[:DESTINATION]-`
* `-[:DESTINATION]-&gt;` 

This is not valid ( taken from your query) : 

* `-&gt;[:DESTINATION]`

Your query should be : 

```
MATCH (a:station{name:&quot;modakeke&quot;})&lt;-[:ORIGIN]-(b:bus)-[:DESTINATION]-&gt;(a)
RETURN a.name
```
",0,66605944
2774,https://stackoverflow.com/a/66599023,Im not create Neo4j with multiple port,false,"On Neo4j side, 

 - 7474 is the default port for HTTP
 - 7473 is the default port for HTTPS
 - 7687 is the default port for Bolt

There are a few more and can be changed as explained [here][1].


  [1]: https://neo4j.com/docs/operations-manual/current/configuration/ports/",0,66599023
2775,https://stackoverflow.com/a/66599894,Neo4j how to get (DISTINCT) all nodes and relationships with at least one node in common?,true,"After struggling with it for a couple hours, I found a solution. I am not sure it is efficient though. In a way, the answer was already in the question - DISTINCT. This query does the job:

    MATCH (a0:Employee {name:0})-[:WORKS]-&gt;(b0:Project) 
    MATCH (b0)&lt;-[:WORKS]-(a:Employee)
    WITH DISTINCT(a)
    MATCH (a)-[:WORKS]-&gt;(b:Project) 
    RETURN a.name AS employee, b.name AS project 
    ORDER BY employee, project",0,66599894
2776,https://stackoverflow.com/a/66672212,Neo4j how to get (DISTINCT) all nodes and relationships with at least one node in common?,false,"You seem to want the answer to the question: given the projects a certain employee works at, find all employees working on those projects.

You can answer this with a simple query:

    MATCH (:Employee {name:1})-[:WORKS]-&gt;(b:Project) 
    MATCH (a:Employee)-[:WORKS]-&gt;(b)
    RETURN a.name AS employee, b.name AS project 
    ORDER BY employee, project

",0,66672212
2777,https://stackoverflow.com/a/66598046,Neo4j Java Driver - Cannot access records on this result,true,"(If you only plan to use the driver, you do not need Neo4j OGM)

Once the session is closed, you cannot access the driver&#39;s `Result` instance.
You should instead iterate over the records while the session is open and return the result you want, something like:

```java
    public &lt;T&gt; List&lt;T&gt; readCyphers(String cypher, Function&lt;Record, T&gt; mapper) {
        try (Driver driver = GraphDatabase.driver(uri, AuthTokens.basic(username, password));
             Session session = driver.session()) {

            Result result = session.run(cypher);
            return result.list(mapper);
        }
    }
```

Note, however, that you should not create a `Driver` instance every time you want to run a query, so the driver should be created before, like this for instance:

```java
class CypherExecutor implements AutoCloseable {

    private final Driver driver;

    public CypherExecutor(String uri, String username, String password) {
        this.driver = GraphDatabase.driver(uri, AuthTokens.basic(username, password))
    }

    public &lt;T&gt; List&lt;T&gt; readCyphers(String cypher, Function&lt;Record, T&gt; mapper) {
        try (Session session = driver.session()) {
            Result result = session.run(cypher);
            return result.list(mapper);
        }
    }

    @Override
    public void close() throws Exception {
        driver.close();
    }
}
```

`CypherExecutor` should ideally be closed (via a [try-with-resources][1] block) only when the application stops.

Also, [transaction functions][2] are more robust (in face of cluster machine failures, leader re-elections etc) and should be used instead, so `readCyphers` should rather be (assuming read-only queries):

```java
    public &lt;T&gt; List&lt;T&gt; readCyphers(String cypher, Function&lt;Record, T&gt; mapper) {
        try (Session session = driver.session()) {
            return session.readTransaction(tx -&gt; tx.run(cypher).list(mapper));
        }
    }
```

On a final note, this abstraction does not bring much to the table, so you could directly use the Driver API in your codebase instead of using this indirection.

The full code, with imports:

```java
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
import org.neo4j.driver.Record;
import org.neo4j.driver.Session;

import java.util.List;
import java.util.function.Function;

class CypherExecutor implements AutoCloseable {

    private final Driver driver;

    public CypherExecutor(String username, String password, String uri) {
        this.driver = GraphDatabase.driver(uri, AuthTokens.basic(username, password))
    }

    public &lt;T&gt; List&lt;T&gt; readCyphers(String cypher, Function&lt;Record, T&gt; mapper) {
        try (Session session = driver.session()) {
            return session.readTransaction(tx -&gt; tx.run(cypher).list(mapper));
        }
    }

    @Override
    public void close() throws Exception {
        driver.close();
    }
}
```


  [1]: https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html
  [2]: https://neo4j.com/docs/driver-manual/current/session-api/configuration/#driver-simple-transaction-fn",0,66598046
2778,https://stackoverflow.com/a/66586879,How to send CSV data from Neo4j query results through Node.js/AdonisJs,true,"You can write data directly into the response like this:
```javascript
const session = driver.session();
const query = &#39;&lt;my query&gt;&#39;;
response.response.writeHead(200, {
  &#39;Content-Type&#39;: &#39;application/csv&#39;,
  &#39;Content-Disposition&#39;: &#39;attachment; filename=&quot;export.csv&quot;&#39;
});
response.response.write(&#39;&lt;some CSV header here&#39;);
await new Promise((resolve, reject) =&gt; {
  const results = session.run(query).subscribe({
    onNext: i =&gt; {
      response.response.write(&#39;&lt;data of record i&gt;&#39;);
    },
    onCompleted: () =&gt; {
      session.close()
      response.response.end()
      resolve()
    },
    onError: error =&gt; {
      console.log(error)
      reject()
    }
  })
})
```",4,66586879
2779,https://stackoverflow.com/a/66607285,How to design a graph without cycles? neo4j,false,"I&#39;d be tempted to treat this as a versioned graph! Here&#39;s a [blog post on versioning][1].

And here&#39;s an example modelled out in [Arrows.App][2]. Of course, there could be other ways to do it too


  [1]: https://medium.com/neo4j/keeping-track-of-graph-changes-using-temporal-versioning-3b0f854536fa
  [2]: https://arrows.app/#/import/json=eyJncmFwaCI6eyJzdHlsZSI6eyJub2RlLWNvbG9yIjoiI2ZmZmZmZiIsImJvcmRlci13aWR0aCI6NCwiYm9yZGVyLWNvbG9yIjoiIzAwMDAwMCIsInJhZGl1cyI6NTAsIm5vZGUtcGFkZGluZyI6NSwib3V0c2lkZS1wb3NpdGlvbiI6ImF1dG8iLCJjYXB0aW9uLXBvc2l0aW9uIjoiaW5zaWRlIiwiY2FwdGlvbi1tYXgtd2lkdGgiOjIwMCwiY2FwdGlvbi1jb2xvciI6IiMwMDAwMDAiLCJjYXB0aW9uLWZvbnQtc2l6ZSI6NTAsImNhcHRpb24tZm9udC13ZWlnaHQiOiJub3JtYWwiLCJsYWJlbC1wb3NpdGlvbiI6Imluc2lkZSIsImxhYmVsLWNvbG9yIjoiIzAwMDAwMCIsImxhYmVsLWJhY2tncm91bmQtY29sb3IiOiIjZmZmZmZmIiwibGFiZWwtYm9yZGVyLWNvbG9yIjoiIzAwMDAwMCIsImxhYmVsLWJvcmRlci13aWR0aCI6NCwibGFiZWwtZm9udC1zaXplIjo0MCwibGFiZWwtcGFkZGluZyI6NSwibGFiZWwtbWFyZ2luIjo0LCJkaXJlY3Rpb25hbGl0eSI6ImRpcmVjdGVkIiwiZGV0YWlsLXBvc2l0aW9uIjoiaW5saW5lIiwiZGV0YWlsLW9yaWVudGF0aW9uIjoicGFyYWxsZWwiLCJhcnJvdy13aWR0aCI6NSwiYXJyb3ctY29sb3IiOiIjMDAwMDAwIiwibWFyZ2luLXN0YXJ0Ijo1LCJtYXJnaW4tZW5kIjo1LCJtYXJnaW4tcGVlciI6MjAsImF0dGFjaG1lbnQtc3RhcnQiOiJub3JtYWwiLCJhdHRhY2htZW50LWVuZCI6Im5vcm1hbCIsInR5cGUtY29sb3IiOiIjMDAwMDAwIiwidHlwZS1iYWNrZ3JvdW5kLWNvbG9yIjoiI2ZmZmZmZiIsInR5cGUtYm9yZGVyLWNvbG9yIjoiIzAwMDAwMCIsInR5cGUtYm9yZGVyLXdpZHRoIjowLCJ0eXBlLWZvbnQtc2l6ZSI6NDAsInR5cGUtcGFkZGluZyI6NSwicHJvcGVydHktcG9zaXRpb24iOiJvdXRzaWRlIiwicHJvcGVydHktY29sb3IiOiIjMDAwMDAwIiwicHJvcGVydHktZm9udC1zaXplIjo0MCwicHJvcGVydHktZm9udC13ZWlnaHQiOiJub3JtYWwifSwibm9kZXMiOlt7ImlkIjoibjAiLCJwb3NpdGlvbiI6eyJ4IjotNDc3LjQ4NDYzNzYwNTg5NiwieSI6MjMuMzgxMTUxNTUxMDkzNzU1fSwiY2FwdGlvbiI6IiIsInN0eWxlIjp7fSwibGFiZWxzIjpbIlBlcnNvbk9iamVjdCJdLCJwcm9wZXJ0aWVzIjp7Im5hbWUiOiJQZXJzb25BIn19LHsiaWQiOiJuMSIsInBvc2l0aW9uIjp7IngiOjExNiwieSI6MH0sImNhcHRpb24iOiIiLCJzdHlsZSI6e30sImxhYmVscyI6WyJQZXJzb25TdGF0ZSJdLCJwcm9wZXJ0aWVzIjp7ImJvb2siOiIxIn19LHsiaWQiOiJuMiIsInBvc2l0aW9uIjp7IngiOi0zNDMuNDkxNTM3MzMyMTEzMjQsInkiOjUwNC42OTI1NjkyNTE0MTM2fSwiY2FwdGlvbiI6IiIsInN0eWxlIjp7fSwibGFiZWxzIjpbIlBlcnNvbk9iamVjdCJdLCJwcm9wZXJ0aWVzIjp7Im5hbWUiOiJQZXJzb25CIn19LHsiaWQiOiJuMyIsInBvc2l0aW9uIjp7IngiOjExNiwieSI6NDYxLjUxNTY3MzgxNzQxOTZ9LCJjYXB0aW9uIjoiIiwic3R5bGUiOnt9LCJsYWJlbHMiOlsiUGVyc29uU3RhdGUiXSwicHJvcGVydGllcyI6eyJib29rIjoiMSJ9fSx7ImlkIjoibjQiLCJwb3NpdGlvbiI6eyJ4IjoxMTYsInkiOi0xOTguODQ2NjgwOTEwOTE0OTh9LCJjYXB0aW9uIjoiIiwic3R5bGUiOnt9LCJsYWJlbHMiOlsiUGVyc29uU3RhdGUiXSwicHJvcGVydGllcyI6eyJib29rIjoiMiJ9fSx7ImlkIjoibjUiLCJwb3NpdGlvbiI6eyJ4Ijo0Ni42OTU4MjI4NDU3NzM5MjUsInkiOi0zNDMuODA1MjYwNTQzMzAzNzV9LCJjYXB0aW9uIjoiIiwic3R5bGUiOnt9LCJsYWJlbHMiOlsiUGVyc29uU3RhdGUiXSwicHJvcGVydGllcyI6eyJib29rIjoiMyJ9fSx7ImlkIjoibjYiLCJwb3NpdGlvbiI6eyJ4IjoxMTYsInkiOjY4MS40NDcyMzkwMzg1MDAyfSwiY2FwdGlvbiI6IiIsInN0eWxlIjp7fSwibGFiZWxzIjpbIlBlcnNvblN0YXRlIl0sInByb3BlcnRpZXMiOnsiYm9vayI6IjMifX0seyJpZCI6Im43IiwicG9zaXRpb24iOnsieCI6NDYuNjk1ODIyODQ1NzczOTI1LCJ5Ijo5MzEuODMwMjQwMjIxNzE3Mn0sImNhcHRpb24iOiIiLCJzdHlsZSI6e30sImxhYmVscyI6WyJQZXJzb25TdGF0ZSJdLCJwcm9wZXJ0aWVzIjp7ImJvb2siOiI2In19XSwicmVsYXRpb25zaGlwcyI6W3siaWQiOiJuMCIsInR5cGUiOiJIQVNfU1RBVEUiLCJzdHlsZSI6e30sInByb3BlcnRpZXMiOnt9LCJmcm9tSWQiOiJuMCIsInRvSWQiOiJuMSJ9LHsiaWQiOiJuMiIsInR5cGUiOiJIQVNfU1RBVEUiLCJzdHlsZSI6e30sInByb3BlcnRpZXMiOnt9LCJmcm9tSWQiOiJuMiIsInRvSWQiOiJuMyJ9LHsiaWQiOiJuMyIsInR5cGUiOiJIQVNfQUNUSU9OIiwic3R5bGUiOnt9LCJwcm9wZXJ0aWVzIjp7InR5cGUiOiJoaXRzIn0sImZyb21JZCI6Im4xIiwidG9JZCI6Im4zIn0seyJpZCI6Im40IiwidHlwZSI6IkhBU19TVEFURSIsInN0eWxlIjp7fSwicHJvcGVydGllcyI6e30sImZyb21JZCI6Im4wIiwidG9JZCI6Im40In0seyJpZCI6Im41IiwidHlwZSI6IkhBU19TVEFURSIsInN0eWxlIjp7fSwicHJvcGVydGllcyI6e30sImZyb21JZCI6Im4wIiwidG9JZCI6Im41In0seyJpZCI6Im42IiwidHlwZSI6IkhBU19TVEFURSIsInN0eWxlIjp7fSwicHJvcGVydGllcyI6e30sImZyb21JZCI6Im4yIiwidG9JZCI6Im42In0seyJpZCI6Im43IiwidHlwZSI6IkhBU19TVEFURSIsInN0eWxlIjp7fSwicHJvcGVydGllcyI6e30sImZyb21JZCI6Im4yIiwidG9JZCI6Im43In1dfSwiZGlhZ3JhbU5hbWUiOiJVbnRpdGxlZCBncmFwaCJ9",0,66607285
2780,https://stackoverflow.com/a/66569906,Can we save data to relationship in neo4j with Spring?,false,"Since you&#39;re using Spring Data Neo4j 5 (which is **not** the latest major version by the way), you can introduce a `@RelationshipEntity` class, to model the relationship between your `User` and `VerificationToken` entities:

```java
@RelationshipEntity(&quot;HAS_VERIFICATION_TOKEN&quot;)
public class VerificationTokenOwnership {

	@Id
	@GeneratedValue
	private Long id;

	// add your extra properties here

	@StartNode
	private User user;

	@EndNode
	private VerificationToken token;

    // getters and setters

}
```

Your `User` field can then become:

```java
    @Relationship(type = &quot;HAS_VERIFICATION_TOKEN&quot;)
    private Set&lt;VerificationTokenOwnership&gt; verificationTokens;
```

Note: it seems a bit strange to have both `HAS_VERIFICATION_TOKEN` and `BELONG_USER` relationships, you should ideally have only one of these.",0,66569906
2781,https://stackoverflow.com/a/66566112,Cypher select vertices whose any neighbours do not contain a property,false,"This will get all Parents without a child name: &#39;abc&#39; or without any child

    MATCH (p:Parent)
    WHERE NOT EXISTS((p)-[:CHILD]-&gt;(:Child {name: &#39;abc&#39;}))
    RETURN p 

&gt; Check if the given parent, p has a child not named: &#39;abc&#39;


==========
EDITED:

Personally I dislike this query because it is collecting x2 then unwinding it later. But for sake of answering the SO question,

    Match (x1:Parent) with x1 
    optional Match (x1)-[:CHILD]-&gt;(x2:Child) with x1 , collect({x1:x1, x2:x2}) as x3 
    UNWIND x3 as x2 
    WITH x2.x1 as x1, x2.x2 as x2, x3 
    where NOT x2.name IN [&#39;abc&#39;] OR x2 is NULL 
    RETURN distinct x1

&gt; I collected BOTH x1 and x2 then UNWIND the collection by getting x1
&gt; and x2 during unwind. This will include other nodes that has no x2
&gt; (without a CHILD).  I also simplified the where condition because x2 is also accessible rather than looping again on x3",0,66566112
2782,https://stackoverflow.com/a/66557722,Adding up a property in the relationship NEO4j,true,"[toInteger][1] is your friend.


  [1]: https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-tointeger

```    merge  (c:Country {name: $Country}) 
            merge  (r:Region {name: $Region})   
            merge  (c1:City {name: $cityfrom})
            merge  (c2:City {name: $cityto})
            merge  (r)-[:IS_IN] -&gt; (c)
            merge  (c1)-[:DISTANCE_TO {distance:toInteger($distance)}] -&gt; (c2)
            merge  (c2)-[:DISTANCE_TO {distance:toInteger($distance)}] -&gt; (c1)
            merge  (c1)-[:IS_IN] -&gt; (r)
            merge  (c2)-[:IS_IN] -&gt; (r)",0,66557722
2783,https://stackoverflow.com/a/66722260,Adding up a property in the relationship NEO4j,false,"Given a `path` variable, you can use `relationships(path)` to get the list of relationships for it.

You can&#39;t use `sum()` on the path or the list of relationships, since `sum()` is an aggregation function that applies over multiple rows, not a scaler function that applies to a list.

You have some options.

If you UNWIND the relationships list to rows, then you can use `sum()`:

    match (dbn:City {name: &#39;Durban&#39;})
    match (unb:City {name: &#39;Pinetown&#39;})
    match path = shortestpath((dbn)-[dist:DISTANCE_TO*]-&gt;(unb))
    UNWIND relationships(path) as rel
    return path, sum(rel.distance) as sum

You can install APOC Procedures and use `apoc.coll.sum()` to sum the elements of the collection:

    match (dbn:City {name: &#39;Durban&#39;})
    match (unb:City {name: &#39;Pinetown&#39;})
    match path = shortestpath((dbn)-[dist:DISTANCE_TO*]-&gt;(unb))
    return path, apoc.coll.sum([rel IN relationships(path) | rel.distance]) as sum

You can use the `reduce()` function to sum the distances:

    match (dbn:City {name: &#39;Durban&#39;})
    match (unb:City {name: &#39;Pinetown&#39;})
    match path = shortestpath((dbn)-[dist:DISTANCE_TO*]-&gt;(unb))
    return path, reduce(sum=0, rel IN relationships(path) | sum + rel.distance) as sum",0,66722260
2784,https://stackoverflow.com/a/66556755,Set constraint on relationship property for variable-path search in GraphDB,true,"You can use the `all()` list predicate to ensure that all relationships in the path adhere to the predicate. This will be evaluated during expansion, so may yield better performance:

    MATCH p=(n:Person {name:&#39;Jennifer&#39;})-[:KNOWS*]-(f)
    WHERE all(rel in relationships(p) WHERE rel.since &lt; 2000)
    RETURN DISTINCT f

That said, Cypher is concerned with finding all possible paths that fit the pattern, and that approach isn&#39;t always a good match when you&#39;re interested in distinct nodes, not distinct paths (especially when the paths backtrack to previously visited nodes via different relationships).

You may want to consider adding an upper limit to your variable length expansion.",0,66556755
2785,https://stackoverflow.com/a/66556389,Cannot construct date time from: NO_VALUE (Failure when processing file,false,"The cypher query language is case sensitive.

So you need to fix the case error: 

* `row.birthdate` =&gt; `row.birthDate`
* `row.hiredate` =&gt; `row.hireDate`

",0,66556389
2786,https://stackoverflow.com/a/66556391,Cannot construct date time from: NO_VALUE (Failure when processing file,false,"My Fault. I was using a wrong column - birthdate instead of birthDate. 
Sorry...",0,66556391
2787,https://stackoverflow.com/a/66552922,App initialization error in neo4j desktop,false,Uninstall Neo4jDesktop then remove these folders: C:\\Program Files\\Neo4j Desktopm and C:\Users\Indra_K\.Neo4jDesktop then re-install Neo4jDesktop. It works for me before.,0,66552922
2788,https://stackoverflow.com/a/66552887,apoc functions not available with Nepo4j even after the plugin in installed,false,"Please follow the instructions on this website:
https://neo4j.com/labs/apoc/4.1/installation/

1. If your neo4j version is 4.2.x, download the jar file from here: https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases/download/4.2.0.1/apoc-4.2.0.1-core.jar
2. Save it in your neo4j_home/plugins folder
3. Change your neo4j_home/conf/neo4j.conf file by adding this: `dbms.security.procedures.whitelist=apoc.*`  Then restart your neo4j",1,66552887
2789,https://stackoverflow.com/a/66552804,Display only properties in Neo4j Tabular format,false,"those items Identity and Label found on neo4j desktop at Table column are displayed to identify the object id and node class. If you click on Text column, then you will see the Properties of the node you are returning.

&gt; identity, label are returned on the neo4j desktop visualization only and not when you integrate it on your program

See example below:

[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/AaLXw.png",0,66552804
2790,https://stackoverflow.com/a/66542515,Match floating point number with regular expression,true,"Here is a regex to match numbers exactly between `0` and `5` with fractional numbers in between:
```
^(?:[0-4](\.[0-9]+)?|5(\.0+)?)$
```
Explanation:
- `^` - start of string
- `(?:` - non-capture group start, used for OR
  - `[0-4]` - integer between `0` and `4`
  - `(\.[0-9]+)?` - optional `.` and digits
  - `|` - OR
  - `5` - literal `5`
  - `(\.0+)?` - optional `.` and zeros
- `)` - non-capture group end
- `$` - end of string
",2,66542515
2791,https://stackoverflow.com/a/66607311,Run multiple neo4j instances on ubuntu-18.4 machine with different ports,false,"Indeed you can, and in fact I do all the time when setting up a cluster. You need to make sure you update all the ports. [This walkthrough][1] tells you all you need to know.


  [1]: https://neo4j.com/docs/operations-manual/current/tutorial/local-causal-cluster/#tutorial-local-cluster",0,66607311
2843,https://stackoverflow.com/a/66532165,Contact Tracing Using Neo4j - Some people are not identified,true,"You iterate over the relationships and compare the timestamps of each relationship with its predecessor. However, you only want to compare the `VISITED` relationships between two persons `(Person)-[:VISITED]-(Location)-[:VISITED]-(Person)`. But in your approach, you are also comparing the relationships between two locations `(Location)-[:VISITED]-(Person)-[:VISITED]-(Location)`. A person could not have been at two locations at the same time.

So, you want to compare only every second pair of relationships. Since your are using an index, you can easily use the modulo operator, such that a relationship pair between two locations (or with one person) is always true:

```sql
MATCH path = (infected:Person {id:&#39;1&#39;})-[*]-(otherPerson:Person)
WITH relationships(path) as rels, otherPerson
WHERE all(i in range(1, size(rels)-1)
  WHERE i % 2 = 0
  OR (rels[i].endTS &gt;= rels[i-1].startTS AND rels[i].startTS &lt;= rels[i-1].endTS)
)
RETURN otherPerson
```

",1,66532165
2844,https://stackoverflow.com/a/66527833,How can I create relationships to all neighbors of a match?,true,"Yes. If you have APOC Procedures installed, and you&#39;re satisfied with the sorting, then the collect() will keep them in sorted order. You can then use `CALL apoc.nodes.link(list, &#39;FOLLOWS&#39;)` and it will create those relationships between all nodes in the list.",1,66527833
2845,https://stackoverflow.com/a/66523781,The neo4j cypher shell and the browser connections are working but the golang client connection is not working,true,"For anyone looking for the answer, the bolt driver will try to use TLS by default and since in my case is not configured, the encryption needs to be disabled in the driver constructor call.



    driver, err := neo4j.NewDriver(&quot;bolt://192.168.0.89:7687&quot;, neo4j.NoAuth(), func(c *neo4j.Config) { c.Encrypted = false })

Hope this helps other people experiencing the same issue :)",0,66523781
2846,https://stackoverflow.com/a/66963729,The neo4j cypher shell and the browser connections are working but the golang client connection is not working,false,"Adding to your answer: it is likely you&#39;re using the v1.x of the Go driver. If you switch to using the v4.x driver instead, you will not have to specify this config value.

You can upgrade by simply adding `v4` in your import statement like so:
```
import github.com/neo4j/neo4j-go-driver/v4/neo4j
```

More info: https://github.com/neo4j/neo4j-go-driver/blob/4.2/MIGRATIONGUIDE.md",1,66963729
2847,https://stackoverflow.com/a/66523638,Import strings from Neo4j json dump,true,"You can still use APOC export and stream the results so that you can either [import it via cypher-shell][1], or if you do not have access to it, [using the Neo4j browser][2].

Example:

To import via cypher-shell -

```
CALL apoc.export.cypher.all(null, {
    batchSize: 5,
    streamStatements: true,
    format: &quot;cypher-shell&quot;,
    useOptimizations: {type: &quot;UNWIND_BATCH&quot;, unwindBatchSize: 5}
})
YIELD nodes, relationships, properties, cypherStatements
RETURN nodes, relationships, properties, cypherStatements;

```

To import via Neo4j browser - 

```
CALL apoc.export.cypher.all(null, {
    format: &quot;plain&quot;,
    useOptimizations: {type: &quot;UNWIND_BATCH&quot;, unwindBatchSize: 20}
})
YIELD file, batches, source, format, nodes, relationships, properties, time, rows, batchSize
RETURN file, batches, source, format, nodes, relationships, properties, time, rows, batchSize;
```


  [1]: https://neo4j.com/labs/apoc/4.1/export/cypher/#export-cypher-cypher-shell
  [2]: https://neo4j.com/labs/apoc/4.1/export/cypher/#export-cypher-neo4j-browser",1,66523638
2848,https://stackoverflow.com/a/66516202,Neo4j doesn&#39;t support in Heroku?,false,"This [news][1] indicates that GrapheneDB shutting down its Heroku add-on.

I have not explored the direct path, as per the documentation you can still use 

&gt; You will still be able to use Heroku with GrapheneDB, just not as a Heroku add-on.



  [1]: https://docs.graphenedb.com/docs/shutdown-of-heroku-add-on",1,66516202
2849,https://stackoverflow.com/a/66518597,Py2neo slow to request all relationships,false,"If you haven&#39;t upgraded to the latest release, do so. There were some significant performance improvements added for reading results in the last patch.",1,66518597
2850,https://stackoverflow.com/a/66522361,Py2neo slow to request all relationships,false,"Your query is actually doing extra work. Because your relationship isn&#39;t directed in the pattern, it&#39;s returning twice for each relationship, just with the start and end nodes flipped (remember that paths consist of ordered nodes, so with the order flipped you will get two distinct paths per pairing).

Your query should go a little faster (less data to return) if you add the direction:

```
Graph.run(&quot;MATCH ()-[r]-&gt;() RETURN r&quot;)
```

Also, the Neo4j Browser restricts the results (by default, 300 nodes for the graphical results view, and I think 1000 results by table or text result view). So depending on total results, the Neo4j Browser may be running faster because it&#39;s not processing and returning all results.",1,66522361
2851,https://stackoverflow.com/a/66512061,How to delete a million of relationships in Neo4J Cypher without stalling the database?,true,"you might want to take a look of `apoc.periodic.iterate` procedure which allows you to perform operations on batches of data returned by a query.
Or probably finding all required relationships wothout using APOC procedure (which is deprecated now) would be somewhat faster.",2,66512061
2852,https://stackoverflow.com/a/66605887,I want to range the nodes by degree - why is this Neo4J Cypher request so slow?,false,"One way to examine degree is using the size function, have you tried something like this?

     size((c1)-[:TO]-(:Concept))

In my graph size() appears to be more efficient, but it might be my cypher rearrangement as well.  

Example: (in my graph) This statement is 81db hits

    PROFILE MATCH (g:Gene {name:&#39;ACE2&#39;})-[r:EXPRESSED_IN]-(a)
    return  count(r)

And this is 4 db hits

    PROFILE MATCH (g:Gene {name:&#39;ACE2&#39;})
    return size((g)-[:EXPRESSED_IN]-())

I&#39;m not sure this next suggestion is faster/more efficient, but if you always calculate degree on a single or subset of relationships, you might look into storing the degree values just to see if that might be an option (faster?).  

I do this on my entire graph right after a bulk load

    CALL apoc.periodic.iterate(
    &quot;MATCH (n) return n&quot;,
    &quot;set n.degree = size((n)--())&quot;,
    {batchSize:50000, batchMode: &quot;BATCH&quot;, parallel:true});

but for a different reason, I want to see the degree value in the neo4j browser (for example...) Note: I rebuilt my graphs daily from the ground up but then it is static until the next rebuild
",0,66605887
2853,https://stackoverflow.com/a/66503324,How to select all the items above threshold or at least the first item?,false,"Using just plain Cypher, you could do this, but it may not be efficient depending on the number of Score nodes you have:

```
MATCH (n:Score) 
WHERE n.value&gt;0.35
WITH collect(n) AS nodes
MATCH (n:Score)
WITH max(n.value) as value, nodes
MATCH (n:Score) WHERE n.value=value
RETURN CASE WHEN size(nodes)=0 THEN n ELSE nodes END
```

APOC&#39;s `when` should perform better but you should try it out on your graph:

```
MATCH (n:Score) 
WHERE n.value&gt;0.35
WITH collect(n) as nodes

CALL apoc.when(
  size(nodes)=0,
  &#39;MATCH (n:Score) WITH max(n.value) AS value, nodes MATCH (n:Score) WHERE n.value=value RETURN n&#39;,
  &#39;UNWIND nodes AS node RETURN node&#39;,
  {nodes:nodes})
YIELD value
RETURN value
```
",0,66503324
2854,https://stackoverflow.com/a/66502554,Aggregating by Month from epoch date - neo4j cypher,true,"The simplest thing is to aggregate by year and month:

    MATCH (d:data) 
    RETURN apoc.date.format(d.submitted, &#39;ms&#39;, &#39;YYYY-MM&#39;) AS month,
           avg(d.score) AS score
    ORDER BY month DESC
    LIMIT 12

Or without apoc.date.format:

    MATCH (d:data)
    WITH d, datetime({epochMillis:d.submitted}) as dt
    RETURN dt.year as year, 
           dt.month as month,
           avg(d.score) AS score
    ORDER BY year DESC, month DESC
    LIMIT 12

But if you want to use the last 12 months (or any other value) with a possible zero, then best way is to create a list of previous months (using the &quot;duration&quot; function), and then optional match the values in the range of dates and calculate the average:

    WITH date() AS today
    UNWIND [
      i IN range(0, 11) | 
      datetime.truncate(&#39;month&#39;, today - duration({months: i}))
    ] AS firstDayOfMonth
    OPTIONAL MATCH (A:data) 
    WHERE A.submitted &gt;= timestamp(firstDayOfMonth) AND
          A.submitted &lt;  timestamp(firstDayOfMonth + duration({months: 1}))
    RETURN apoc.date.format(timestamp(firstDayOfMonth), &#39;ms&#39;, &#39;YYYY-MM&#39;) AS month,
           coalesce(avg(A.score), 0) AS score

",1,66502554
2855,https://stackoverflow.com/a/66493278,How to return a node that&#39;s the same name as another node but of a specific label? Neo4J,false,"You can use EXISTS. It will check if there is a connection between Test1 and Test2 before returning the value of Test3. Then you can have a condition on your query that says Test3.value = &#39;x&#39;. Depending on your input value, your query will look like below;

&gt; Given Test1.name =&#39;x&#39; and Test2.name = &#39;y&#39;

     MATCH (n:Test3 {value: &#39;x&#39;})
     WHERE EXISTS ( (:Test1 {name: &quot;x&quot;})-[:syn_of]-&gt;(:Test2 {name: &quot;y&quot;}) )
     RETURN n


Using WITH clause, you have a variable nameTest1 and assign this to Test3.value

&gt; Given Test2.name = &#39;y&#39;

    MATCH (n:Test1)-[:syn_of]-&gt;(:Test2 {name: &quot;y&quot;})
    WITH n.name as nameTest1
    MATCH (n3:Test3 {value: nameTest1 })
    RETURN n3
    ",0,66493278
2856,https://stackoverflow.com/a/66567435,Path that return a unique node and no relationship,true,"I found the solution, the problem was that the path return a unique node so relationships will be an empty list and when you UNWIND an empty list, it wipes out the rows
if you want you find the discussion here : https://community.neo4j.com/t/path-that-return-a-unique-node-and-no-relationship/34719/2",0,66567435
2857,https://stackoverflow.com/a/66487129,Strange Neo4j Cypher Aggregator behaviour with WITH Clause,true,"It&#39;s not incorrect, this is just a misunderstanding of how implicit grouping keys work when you&#39;re aggregating in Cypher.

When aggregating, the non-aggregation terms becomes the grouping key, which is the context for what you are aggregating over.

The key differences are in your WITH clause when you&#39;re aggregating. In the first query you have:

```
with x1 ,count(x2) as x3 
```

Your aggregation of `count(x2)` is per `x1`. So per distinct x1 node, the count of the associated x2 nodes.

In your second query, the variables are different, and so the grouping key is different:

```
with x1 ,x2, count(x2) as x3 
```

Per x1 and x2, what is the count of that particular x2? If there were multiple rows with the same `x1` and `x2` nodes, then you might have some count &gt; 1. But if there was only one row for that particular `x1` and `x2` nodes, then the count would be 1.

EDIT

If you want to get the counts of x2 per x1, and after that continue to work with x2 nodes, then you will need to collect(x2) at the same time as you count(x2) (since it&#39;s an aggregation term, it isn&#39;t part of the grouping key). Then you can UNWIND the list back to rows.

Your query doesn&#39;t actually use x2 nodes so we really don&#39;t have to do anything with them, but I&#39;ll show the technique anyway:

```
Match (x1:A) 
with x1 
optional Match (x1)-[:A_B]-(x2:B) 
with x1 , collect(x2) as nodes, count(x2) as x3 
where x1.foo= &#39;bar&#39; and (x3 = 1) 
UNWIND nodes as x2
return DISTINCT x1 as A 
SKIP 0 
LIMIT 10
```

",2,66487129
2858,https://stackoverflow.com/a/66607377,Neo4j specify fields and column names for CSV export,false,"You&#39;ll find the [UNION clause][1] very helpful here

Something like...

    MATCH (a:Apple) 
    RETURN a.pk AS pk, a.type AS type, a.name AS name, &quot;&quot; AS `HAS Apple (pk)`, &quot;&quot; AS field1
    UNION
    MATCH (b:B)-[:HAS]-&gt;(ab:Apple) 
    RETURN b.pk AS pk, b.type AS type, b.name AS name, ab.pk AS `HAS Apple (pk)`, b.field1 AS field1


  [1]: https://neo4j.com/docs/cypher-manual/current/clauses/union/",0,66607377
2859,https://stackoverflow.com/a/66827676,Migrate from one Graph Database to another,false,"As someone already mentioned for the property graphs there is no defined standard as of now. There are efforts going to build such standards called GQL [https://www.gqlstandards.org/][1] 

However, for importing data from RDF to property graphs. Tigergraph and neo4j provides option to load your rdf data to the respective platforms. This might not provide complete switch over capabilities from RDF to Property graph but can help with solutions for certain scenarios. 

For interchanging data between property graphs you might have to re-create schema when you switch platforms. For data loading most of property graph dbs provide option to load using csv&#39;s.


  [1]: https://www.gqlstandards.org/",1,66827676
2860,https://stackoverflow.com/a/66481638,Can I filter on a SemiStructured node in Neo4 Model?,false,"You should always use a try and except clause when dealing with this kind of exception.

    try:
        Person.nodes.filter(surname__contains=&#39;atts&#39;,eye_colour=&#39;BLUE&#39;)
    except:
        print (&quot;Couldn&#39;t filter surname and eye_colour&quot;)",0,66481638
2861,https://stackoverflow.com/a/66486730,Strange bug in a Cypher Neo4J request,false,"The exported PROFILE plan image should show the problem, but I can guess at it.

It&#39;s important to remember that with Cypher, operations execute per row. And at the start, you only have one row.

So the first part of the query here:

```
MATCH (c1:Concept)-[:AT]-&gt;(ctx:Context{uid:&#39;60156a60-d3e1-11ea-9477-f71401ca7fdb&#39;}) 
WITH DISTINCT c1 
```

This executes once, and now you have one row per distinct `c1` node. Let&#39;s say, for the sake of example, that you have 1000 rows as a result at this point in the query. Now for the remainder of the query:

```
...
MATCH (c2:Concept)-[:AT]-&gt;(ctx:Context{uid:&#39;60156a60-d3e1-11ea-9477-f71401ca7fdb&#39;}) 
RETURN c1;
```

The MATCH here (which will likely consist of either an index lookup or label scan+filter, then expansion, then label filtering) executes **per input row**. So if you had 1000 rows half-way through, now you&#39;re performing this entire MATCH sequence for each of those rows, so that happens 1000 times. Your rows are multiplying out the operational work that needs to be done, and execution time will multiply out too.

You should see proof of that in the number of rows flowing in your PROFILE plan. Watch how the rows of c1 feed into the next NodeIndex Seek (or NodeByLabelScan and Filter) operation, and how that continues until the end of the query.",0,66486730
2862,https://stackoverflow.com/a/66477597,Graph database vs. RDB with link/bridge tables,true,"On similar hardware platforms, a relational database will never be able to keep up with a well constructed graph database when performing &quot;path-between&quot; queries. Never.

Every graph database product has its own internal storage representation, but they are all fundamentally designed to store nodes and edges and support navigational queries across those nodes and edges. Without the addition of new graph-support features, relational database will struggle to provide graph-like capabilities.

The other advantage of using a native graph database is that the graph query languages are specifically designed to support path-between queries. In Objectivity/DB, a massively scalable and distributable object/graph database, we can use the DO query language to find all of the paths between two entities up to a specified number of degrees apart in milliseconds or seconds. A DO query might look like the following:

    Match p = (:Account { accountId = &quot;1234&quot;})
              -[*..100]-&gt;
              (:Account { accountId = &quot;5678&quot;})
              return p;

Here, we are saying: Find all paths (p) from Account 1234 to Account 5678, where they are between 1 and 100 degrees apart.

To create and execute this same query in a relational database would be much more complicated (without the addition of graph features to the database) and the execution of a query like this in a relational database would be much more resource intensive (memory, cpu, I/O).

If you have the opportunity to explore graph database for your project, make sure you understand your scalability and data distribution requirements. That information will be key to selecting the correct product. 

*Disclaimer: I am the Director of Field Operations for Objectivity.*

",2,66477597
2863,https://stackoverflow.com/a/66473844,Product recommendation cypher,false,"Something like below should work to start with:

    MATCH (i:Invoice)-[]-(a:Article)-[]-(:Invoice)-[]-(b:Article) 
    WHERE i.invoiceNumber = 123
    RETURN b;

What is does is - start from the invoice, then navigate through the articles connected to that invoice, onto other invoices (all other invoices that share this article). From there it collects all the articles connected to those invoices. 
(this assumes that you are using unique `Article`nodes and connecting the invoices to them)",0,66473844
2864,https://stackoverflow.com/a/66482603,Product recommendation cypher,false,"You can use below query for a given Customer (let say Customer1), give me other customers and recommended food based on any food that Customer1 ordered and common to other customers.


    MATCH (c1:Customer {name: &#39;Customer1&#39;})&lt;-[:GENERATED_FOR]-(:Invoice)&lt;-[:ITEMIZED_IN]-(:Article)-[:TYPE]-&gt;(f:FoodArticle)
    WITH c1, collect(f) as food 
    MATCH (c2:Customer)&lt;-[:GENERATED_FOR]-(:Invoice)&lt;-[:ITEMIZED_IN]-(:Article)-[:TYPE]-&gt;(f2:FoodArticle) 
       WHERE c1 &lt;&gt; c2 AND f2 in food
    WITH c2, food, collect(f2) as food2
    WITH c2, [fd IN food WHERE NOT fd IN food2] as recommendations 
       WHERE size(recommendations) &gt; 0
    RETURN c2.name, recommendations


&gt;1. First, get all food that customer1 has ordered
&gt;2. Next, find all customers that has at least one food contained in Customer1&#39;s food 
&gt;3. List out customer2 and collect all food for this customer2
&gt;4. Create a list of recommended food based on those found in customer1 food list BUT NOT found in customer2 food list
&gt;5. Return customer2 name and recommended food but ensure that there is at least one food in Customer1 list that is not found in customer2 list (food2)
",0,66482603
2865,https://stackoverflow.com/a/66465105,Can&#39;t save to Neo4j database,false,"Do you by chance created two users in your database with the same id?

Can you please check that? A good way to avoid that is to 

    create constraint on (u:User) assert u.id is unique;

",1,66465105
2866,https://stackoverflow.com/a/66463910,"Cypher Question, Return results only if connected with all nodes",true,"Here you go:

&gt; 1) You need to collect all rows and all skills 
&gt; 2) Unwind rows as row and check that candidates skills are in all skills you want
&gt; 3) Check that every skill related to this candidate is on the list of ALL skills you want (Java and PHP)


     MATCH  (s:SkillNode) 
     WHERE s.entity_id = row.entity_id
     WITH  collect(row) as rows, collect(s) as allSkills
     UNWIND rows as row
     MATCH (c:CandidateNode)-[r:KNOWS]-&gt;(s:SkillNode) 
     WHERE r.years_of_experience &lt;= row.yearsOfExperience AND s in allSkills
     WITH c, collect(distinct r) as rels, collect(distinct s) as skills, allSkills 
     WHERE ALL(sk in allSkills where sk in skills) 
     RETURN c, rels, skills
    
     Sample result:
     ╒════════════════╤═════════════╤════════════════════════════════════════╕
     │&quot;c&quot;             │&quot;rels&quot;       │&quot;skills&quot;                                │
     ╞════════════════╪═════════════╪════════════════════════════════════════╡
     │{&quot;name&quot;:&quot;Leo&quot;}  │[{},{},{},{}]│[{&quot;name&quot;:&quot;Java&quot;},{&quot;name&quot;:&quot;PHP&quot;        }]│
     ├────────────────┼─────────────┼────────────────────────────────────────┤
     │{&quot;name&quot;:&quot;Manos&quot;}│[{},{},{},{}]│[{&quot;name&quot;:&quot;Java&quot;},{&quot;name&quot;:&quot;PHP&quot;        }]│
     └────────────────┴─────────────┴────────────────────────────────────────┘",1,66463910
2867,https://stackoverflow.com/a/66506562,"Can Cypher do phonetic text search with only a part of the text, without using elastic search?",false,"First, you could try fuzzy matching with a full text index and see if it solves the issue.
An example would be:
Set up the index-
`CALL db.index.fulltext.createNodeIndex(&#39;jobs&#39;, [&#39;Job&#39;], [&#39;name&#39;], {})`

Query the index with fuzzy matching (note the `~`)

`CALL db.index.fulltext.queryNodes(&#39;jobs&#39;, &#39;fynancial~&#39;) `

If you want to go further and use Lucene&#39;s phonetic searches, then you could write a little Java code to register a custom analyzer.


Include the `lucene-analyzers-phonetic` dependency like so:

```
     &lt;dependency&gt;
            &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;
            &lt;artifactId&gt;lucene-analyzers-phonetic&lt;/artifactId&gt;
            &lt;version&gt;8.5.1&lt;/version&gt;
        &lt;/dependency&gt;
```

Then create a custom analyzer:

```
@ServiceProvider
public class PhoneticAnalyzer extends AnalyzerProvider {


	public PhoneticAnalyzer() {
		super(&quot;phonetic&quot;);
	}

	@Override
	public Analyzer createAnalyzer() {
		return new Analyzer() {
			@Override
			protected TokenStreamComponents createComponents(String s) {
				Tokenizer tokenizer = new StandardTokenizer();
				TokenStream stream = new DoubleMetaphoneFilter(tokenizer, 6, true);
				return new TokenStreamComponents(tokenizer, stream);
			}
		};
	}
}
```

I used the DoubleMetaphoneFilter but you can experiment with others.
Package it as a jar, and put it into Neo4j&#39;s plugin directory along with the [Lucene phonetic jar][1] and restart the server.
Then, create a full text index using this analyzer:

`CALL db.index.fulltext.createNodeIndex(&#39;jobs&#39;, [&#39;Job&#39;], [&#39;name&#39;], {analyzer:&#39;phonetic&#39;})`

Querying the index looks the same: 

`CALL db.index.fulltext.queryNodes(&#39;jobs&#39;, &#39;fynancial&#39;)`


  [1]: https://mvnrepository.com/artifact/org.apache.lucene/lucene-analyzers-phonetic/8.5.1",0,66506562
2868,https://stackoverflow.com/a/67138325,"Can Cypher do phonetic text search with only a part of the text, without using elastic search?",true,"It took a while, this is how I solved my question.


    MATCH (a)-[:IS]-&gt;(hs)
    UNWIND a.naam AS namelist
    CALL apoc.text.phonetic(namelist) YIELD value
    WITH value AS search_str, SPLIT(&#39;INPUT FROM DATABASE&#39;, &#39; &#39;) AS input, a
    CALL apoc.text.phonetic(input) YIELD value
    WITH value AS match_str, search_str, a
    WHERE search_str CONTAINS match_str OR search_str = match_str
    RETURN DISTINCT a.naam, label(a)
",0,67138325
2869,https://stackoverflow.com/a/66466538,Creating several millions of relationships in Neo4j takes a very long time,true,"Index and constraint creation is asynchronous, so you&#39;re likely jumping the gun before the indexes and constraints are up. You should probably use `CALL db.awaitIndexes()` just in case. 

Also, the MERGE approach isn&#39;t recommended, as it has to check if such a pattern exists and if not create the whole pattern, which will end up duplicating nodes. MATCHing on the nodes, then either CREATE or MERGE the relationship, is the better approach (only MERGE if the rel might already exist, or if the same nodes might be matched on multiple rows for the given input data). 

Ignore the cartesian product warning, that&#39;s exactly what you need (1 x 1 per row) to create the relationship.",0,66466538
2870,https://stackoverflow.com/a/66451900,Update a list property of a node by values of a CSV file,true,"I assume that the `vector` property on the `Class` nodes is already an array.

```
LOAD  CSV WITH HEADERS FROM &quot;file:///test2.csv&quot; AS  vector
MATCH (c:Class {name: vector.nameCSV})
SET c.vector=c.vector + vector.vectorCSV 
```

This could result in duplicate values. If you do not want duplicates, you can use [apoc.coll.union][1]

```
LOAD  CSV WITH HEADERS FROM &quot;file:///test2.csv&quot; AS  vector
MATCH (c:Class {name: vector.nameCSV})
SET c.vector=apoc.coll.union(c.vector,[vector.vectorCSV]) 
```

  [1]: https://neo4j.com/labs/apoc/4.1/overview/apoc.coll/apoc.coll.union/",0,66451900
2871,https://stackoverflow.com/a/66443206,How to call Neo4j database api in R Studio,false,"HTTP endpoints were changed since version 4 of Neo4J
* Neo4j v3 had endpoint `http://localhost:7474/db/data`
* Neo4j v4 uses `http://localhost:7474/db/{databaseName}/tx` instead of it. 

Seems like Neo4j library for R needs to be updated... 

I&#39;m not familiar with R but you could try to use available HTTP client for R that supports Basic authentication to send `POST` requests to Neo4J API with JSON payload. I also see you use `http` schema which means your credentials will be sent as plain text through the network, which is not good.

Payload for such requests should be in form of:

    {
      &quot;statements&quot;: [
        {
          &quot;statement&quot;: &quot;MATCH(n) RETURN n&quot;
        }
      ]
    }
*(adjust Cypher query to your needs)*  
Response will be JSON object with `data` section containing actual results.",0,66443206
2872,https://stackoverflow.com/a/66508610,How to import data into Neo4j from Azure Blob Storage?,false,"I don&#39;t think there are any free tools.

On the commercial side, [GraphAware Hume Orchestra][1] has Azure BlobStorage connectors

[![enter image description here][2]][2]

[![enter image description here][3]][3]

There is also the possibility to create your own protocol for Neo4j LOAD CSV (for eg s3, azure etc,) .

I have written an example here : https://github.com/ikwattro/neo4j-load-csv-s3-protocol


  [1]: https://graphaware.com/products/hume/
  [2]: https://i.stack.imgur.com/XecEY.png
  [3]: https://i.stack.imgur.com/x8qCH.png",1,66508610
2873,https://stackoverflow.com/a/66665491,How to import data into Neo4j from Azure Blob Storage?,true,I got it done by using python azure-blob-storage and py2neo libraries. It worked like a charm.,1,66665491
2874,https://stackoverflow.com/a/66427832,Cypher query to get path between distant nodes,true,"When you look for all relationships of any length (r:RELATED_TO_*) the value of r is a list of all relationship from value_node named &quot;id&quot; to value_node name &quot;Gewicht&quot;. Thus you should iterate on this list and check if the value of a.value is equal to ALL items in r.

    Match p=(a:Value_Node {katalog_name:&quot;id&quot;})-[r:RELATED_TO_*]-&gt;(b:Value_Node {katalog_name:&quot;Gewicht&quot;}) 
    WHERE ALL(rel in r WHERE rel.id_nr = a.value)
    return p",1,66427832
2875,https://stackoverflow.com/a/66425123,"How to query multiple items in Neo4J, return just one in order of precedence?",true,"With `UNWIND` you can transform a list into rows that keep the order of the list. 

https://neo4j.com/docs/cypher-manual/4.2/clauses/unwind/

First, get the article with the default translation language.
Then, unwind the the list with the preferred languages.
Next, look for translation with preferred language. If there is no such translation, nothing would be returned with `MATCH`. That&#39;s why `OPTIONAL MATCH` is needed, it will be `NULL` if nothing is matched.
Finally, return the first result with either the preferred (if there is any) or the default translation.

```
MATCH (a:Article {id: &#39;123&#39;})-[:HAS_TRANSLATION]-&gt;(default:Translation {default: true})
WITH a, default
UNWIND [&#39;ES&#39;, &#39;EN&#39;] AS lang
OPTIONAL MATCH (a)-[:HAS_TRANSLATION]-&gt;(t:Translation {lang: lang})
RETURN a, CASE WHEN t IS NULL THEN default ELSE t END AS t
LIMIT 1
```

_Disclaimer: I haven&#39;t tested the query._",2,66425123
2876,https://stackoverflow.com/a/66431440,Neo4J Community 4.1.6 Stops after starting,true,"I believe we only support JDK 11 when using Neo4j 4.x. 

https://neo4j.com/docs/operations-manual/current/installation/requirements/#deployment-requirements-java

Your errors may be because you are using JDK 15.

When diagnosing issues, it also helps to check the neo4j.log and debug.log files in the logs directory.",0,66431440
2877,https://stackoverflow.com/a/66442531,How do I return a Neo4j path with Neo4jClient in .NET?,false,"OK, I&#39;ve made an assumption you&#39;re using `BoltGraphClient` - as with `GraphClient` you&#39;re pretty much stuck as the REST endpoint doesn&#39;t give out the IDs you&#39;re after.

There is a class called `PathsResultBolt` in `Neo4jClient` - _but_ it&#39;s giving out `System.Object` as the answer for every property in results of the query - which is less than useful, so you should try this class instead:

```
public class PathsResultBolt&lt;TNode, TRel&gt;
{
	public PathsResultBolt()
	{
		Nodes = new List&lt;PathsResultBoltNode&lt;TNode&gt;&gt;();
		Relationships = new List&lt;PathsResultBoltRelationship&lt;TRel&gt;&gt;();
	}

	internal PathsResultBolt(IPath path)
	{
		Start = new PathsResultBoltNode&lt;TNode&gt;(path.Start);
		End = new PathsResultBoltNode&lt;TNode&gt;(path.End);
		Relationships = path.Relationships.Select(r =&gt; new PathsResultBoltRelationship&lt;TRel&gt;(r)).ToList();
		Nodes = path.Nodes.Select(r =&gt; new PathsResultBoltNode&lt;TNode&gt;(r)).ToList();
	}

	[JsonProperty(&quot;Start&quot;)]
	public PathsResultBoltNode&lt;TNode&gt; Start { get; set; }

	[JsonProperty(&quot;End&quot;)]
	public PathsResultBoltNode&lt;TNode&gt; End { get; set; }

	[JsonIgnore]
	public int Length =&gt; Relationships.Count();

	[JsonProperty(&quot;Nodes&quot;)]
	public List&lt;PathsResultBoltNode&lt;TNode&gt;&gt; Nodes { get; set; }

	[JsonProperty(&quot;Relationships&quot;)]
	public List&lt;PathsResultBoltRelationship&lt;TRel&gt;&gt; Relationships { get; set; }

	public class PathsResultBoltRelationship&lt;T&gt;
	{
		public long Id { get; set; }
		public string Type { get; set; }
		public long StartNodeId { get; set; }
		public long EndNodeId { get; set; }

		public object this[string key] =&gt; Properties[key];

		public Dictionary&lt;string, T&gt; Properties { get; set; }

		public PathsResultBoltRelationship() { Properties = new Dictionary&lt;string, T&gt;(); }

		public PathsResultBoltRelationship(IRelationship relationship)
		{
			Id = relationship.Id;
			StartNodeId = relationship.StartNodeId;
			EndNodeId = relationship.EndNodeId;
			Type = relationship.Type;
			Properties = relationship.Properties.ToDictionary(kvp =&gt; kvp.Key, kvp =&gt; kvp.Value.As&lt;T&gt;());
		}

		public bool Equals(PathsResultBoltRelationship&lt;T&gt; other)
		{
			if (other == null)
				return false;

			return Id == other.Id
				   &amp;&amp; StartNodeId == other.StartNodeId
				   &amp;&amp; EndNodeId == other.EndNodeId
				   &amp;&amp; Type == other.Type
				   &amp;&amp; Properties.ContentsEqual(other.Properties);
		}

		public override bool Equals(object obj)
		{
			return Equals(obj as PathsResultBoltRelationship&lt;T&gt;);
		}

		public override int GetHashCode()
		{
			var hashCode = 2105322407;
			hashCode = hashCode * -1521134295 + Id.GetHashCode();
			hashCode = hashCode * -1521134295 + EqualityComparer&lt;string&gt;.Default.GetHashCode(Type);
			hashCode = hashCode * -1521134295 + StartNodeId.GetHashCode();
			hashCode = hashCode * -1521134295 + EndNodeId.GetHashCode();
			hashCode = hashCode * -1521134295 + EqualityComparer&lt;IReadOnlyDictionary&lt;string, T&gt;&gt;.Default.GetHashCode(Properties);
			return hashCode;
		}
	}

	public class PathsResultBoltNode&lt;T&gt;
	{
		public long Id { get; set; }
		public List&lt;string&gt; Labels { get; set; }
		public object this[string key] =&gt; Properties[key];
		public Dictionary&lt;string, T&gt; Properties { get; set; }

		public PathsResultBoltNode() { Properties = new Dictionary&lt;string, T&gt;(); }

		internal PathsResultBoltNode(INode node)
		{
			Id = node.Id;
			Labels = node.Labels?.ToList();
			Properties = node.Properties.ToDictionary(kvp =&gt; kvp.Key, kvp =&gt; kvp.Value.As&lt;T&gt;());
		}

		public bool Equals(PathsResultBoltNode&lt;T&gt; other)
		{
			if (other == null)
				return false;

			return Id == other.Id
				   &amp;&amp; Labels.ContentsEqual(other.Labels)
				   &amp;&amp; Properties.ContentsEqual(other.Properties);
		}

		public override bool Equals(object obj)
		{
			return Equals(obj as PathsResultBoltNode&lt;T&gt;);
		}

		public override int GetHashCode()
		{
			var hashCode = 1343812023;
			hashCode = hashCode * -1521134295 + Id.GetHashCode();
			hashCode = hashCode * -1521134295 + EqualityComparer&lt;IReadOnlyList&lt;string&gt;&gt;.Default.GetHashCode(Labels);
			hashCode = hashCode * -1521134295 + EqualityComparer&lt;IReadOnlyDictionary&lt;string, T&gt;&gt;.Default.GetHashCode(Properties);
			return hashCode;
		}
	}
}
```

Which you would use like so:

```
client.Cypher
  .Match(&quot;(from:Employee {name:\&quot;Sarah Bradshaw\&quot;})&quot;)
  .Match(&quot;(to:Employee {name:\&quot;Thomas Mitchell\&quot;})&quot;)
  .Call(&quot;apoc.algo.dijkstra(from, to, &#39;&#39;, &#39;d&#39;)&quot;)
  .Yield(&quot;path&quot;)
  .Return&lt;PathsResultBolt&lt;string, string&gt;&gt;(&quot;path&quot;)
  .ResultsAsync
  .Result;
```

What is this `&lt;string, string&gt;` you ask? The first is the property type of the Nodes, the second is for the Relationships.

Now. This is a bit rubbish - and it&#39;s down to the fact I&#39;m not sure how to get the actual object values to be proper `objects` which work. So the best approach (!!) is to use `string` for both node and rels at the moment. In my tests using the standard Movie database, I get this:

[![Results of the query in LinqPad][1]][1]

the `born` property is a `string` but that&#39;s the base level, using `int` would cause an error as `name` is _not_ an int. 

  [1]: https://i.stack.imgur.com/8w3GB.png",0,66442531
2878,https://stackoverflow.com/a/66399090,"Neo4j server activation error, java.lang.IllegalStateException: ManagerFactory, java.io.FileNotFoundException",true,"The problem was that I didn&#39;t have administrator permissions.
If you encounter this problem run cmd as an administrator and then run the command.",0,66399090
2879,https://stackoverflow.com/a/66607504,Neo4j LOAD CSV record processed sequence,true,"The CSV will be processed from top to bottom - in that order. What might be worth considering is doing a double load of your data.

First pass just CREATE/MERGE your org nodes. Second pass, MATCH the org nodes, then create the rest of the data. 

Using this approach you will avoid any potential order issues, as well as dodging eager queries.",1,66607504
2880,https://stackoverflow.com/a/66421806,Neo4j Docker: http-post returns error EOF,true,"it&#39;s probably not clearing down quick enough so you need to look at your memory memory consumption and may need to allocatre more memory to the container. Have a read through [Understanding Memory Consumption][1] within the knowledgebase which may help. You can also have a the [memory recommendations section][2] as well.


  [1]: https://neo4j.com/developer/kb/understanding-memory-consumption/
  [2]: https://neo4j.com/docs/operations-manual/current/tools/neo4j-admin-memrec/",0,66421806
2881,https://stackoverflow.com/a/66390481,Shortest path between a source and multiple destinations,true,"You need to make the relationship to be directional from Child to Book.  This is because when you put *, it will include a path from book3 to library which you don&#39;t need.

    MATCH (c:Child {name:&#39;C1&#39;} ),
      (b:Book),
      p = shortestPath((c)-[*]-&gt;(b))
    RETURN p",0,66390481
2882,https://stackoverflow.com/a/66388893,Visualizing the cluster doesn&#39;t give me the expected result,true,"On your neo4j desktop, increase the values of Node display, max neighbors and max rows so that you will see the nodes including the relationships (links).

 
[![enter image description here][1]][1]

 


  [1]: https://i.stack.imgur.com/dfymo.png",1,66388893
2883,https://stackoverflow.com/a/66411837,Cast massive properties Neo4j,false,"You could pass the list of properties as a parameter and iterate over it with `FOREACH`. Properties can be accessed dynamically ([dynamic property](https://neo4j.com/docs/cypher-manual/4.2/syntax/expressions/)).

```javascript
propList: [&#39;PROPERTY1&#39;, &#39;PROPERTY2&#39;, &#39;PROPERTY3&#39;]
```

```sql
MATCH ()-[r:RELATED_TO]-&gt;()

FOREACH (prop IN $propList |
  SET r[prop] = toInteger(r[prop])
)
```",0,66411837
2884,https://stackoverflow.com/a/66391206,Neo4j graph algorithm / Node similarity,true,"You should start with the candidates rather than the job. This is because you are comparing the similarities among the candidates based on the skills that the job requires.

    MATCH (job:JobNode{job_id:&#39;feed85b9-041c-4bb5-b48a-963c9f927e1d&#39;})-[r:REQUIRES]-&gt;(s:SkillNode)&lt;-[:KNOWS]-(c:CandidateNode)
    MATCH (c)-[:APPLIED_FOR]-(job)
    WITH {item:id(c), categories: collect(id(job))} AS userData
    WITH collect(userData) AS data
    CALL gds.alpha.ml.ann.stream({
       data: data,
       algorithm: &#39;jaccard&#39;
     })
     YIELD item1, item2, similarity
     return gds.util.asNode(item1).name AS Candidate1, gds.util.asNode(item2).name AS Candidate2, similarity
     ORDER BY Candidate1

     Result:
     ╒════════════╤════════════╤════════════╕
     │&quot;Candidate1&quot;│&quot;Candidate2&quot;│&quot;similarity&quot;│
     ╞════════════╪════════════╪════════════╡
     │&quot;Leo&quot;       │&quot;Manos&quot;     │1.0         │
     ├────────────┼────────────┼────────────┤
     │&quot;Manos&quot;     │&quot;Leo&quot;       │1.0         │
     └────────────┴────────────┴────────────┘

EDITED:
I thought the question is about node similarity algorithm in neo4j data science library.  The question is about calculating the percentage of each candidates&#39; skill compared to the total skill required for the job.

Steps:  
1. Get the total number of skills required for the job
2. Get all candidates with those skills that the job requires
3. Ensure that this candidate has applied for that job
4. Return the candidate name and his/her skills divided by total skills needed for that job

NOte: the function round(10^2/10^2) is a hack in neo4j. Neo4j is not capable of displaying decimals in desktop. If you want 3 decimal places, use 10^3

    MATCH (job:JobNode{job_id:&#39;&lt;id&gt;&#39;})-[:REQUIRES]-&gt;(sk:SkillNode)
    WITH job, count(sk) as total_skills
    MATCH (job)-[r:REQUIRES]-&gt;(s:SkillNode)&lt;-[k:KNOWS]-(c:CandidateNode)
    MATCH (c)-[:APPLIED_FOR]-(job)
    WITH c as candidate, count(s) as skills, total_skills
    RETURN candidate.name, round(10^2*skills/total_skills)/10^2 as percent

    Result:
    ╒════════════════╤═════════╕
    │&quot;candidate.name&quot;│&quot;percent&quot;│
    ╞════════════════╪═════════╡
    │&quot;Leo&quot;           │0.67     │
    ├────────────────┼─────────┤
    │&quot;Manos&quot;         │0.67     │
    └────────────────┴─────────┘",1,66391206
2885,https://stackoverflow.com/a/66374461,Can&#39;t create unique constraint in Neo4J,false,"You can check if there is uniqueness on forecast {match} by running this.

    MATCH (a:forecast) 
    RETURN a.match, count(*) LIMIT 5

If you see a value &gt; 1 in count() then forecast.match is not unique.

Note: count() is sorting in descending order in my desktop. In case it is not, then run below:

    MATCH (a:forecast) 
    WITH a.match as match, count(*) as cnt
    RETURN match, cnt ORDER by cnt DESC LIMIT 5",0,66374461
2886,https://stackoverflow.com/a/66427069,Get the last created thing among siblings in neo4j,false,"Here is my answer:

1. First you need to get the createdAt date with the max value
2. Then match all nodes with this max value
3. Finally, return the node that you want


&gt;     MATCH ()-[rel]-&gt;()  
&gt;     WITH  max( rel.cratedAt ) as max_createdAt  
&gt;     MATCH (node)-[r]-&gt;(target) WHERE r.createdAt = max_createdAt 
&gt;     RETURN node  LIMIT 10



     Result:
     ╒═════════════╕
     │&quot;node&quot;       │
     ╞═════════════╡
     │{&quot;name&quot;:&quot;n1&quot;}│
     ├─────────────┤
     │{&quot;name&quot;:&quot;n2&quot;}│
     └─────────────┘


EDITED:  Based on the user comment, I updated the answer below.
&gt;  I&#39;m looking to return the whole structure.


     MATCH ()-[rel]-&gt;()  
     WITH  max( rel.cratedAt ) as max_createdAt  
     MATCH path=(node)-[r]-&gt;(target) WHERE r.cratedAt = max_createdAt 
     RETURN path, type(r) as relationship_name
     LIMIT 10

    Result:
     ╒═══════════════════════════════════╤═══════════════════╕
     │&quot;path&quot;                             │&quot;relationship_name&quot;│
     ╞═══════════════════════════════════╪═══════════════════╡
     │[{&quot;name&quot;:&quot;n1&quot;},{&quot;cratedAt&quot;:&quot;2&quot;},{}]│&quot;reln2&quot;            │
     ├───────────────────────────────────┼───────────────────┤
     │[{&quot;name&quot;:&quot;n2&quot;},{&quot;cratedAt&quot;:&quot;2&quot;},{}]│&quot;reln4&quot;            │
     └───────────────────────────────────┴───────────────────┘",1,66427069
2887,https://stackoverflow.com/a/66431319,Get the last created thing among siblings in neo4j,false,"What you need to do on this one is perform your MATCH, then ORDER BY the rel&#39;s createdAt property, and then collect() the relationships according to the node and target (so per node and target, you&#39;ll get the ordered list of relationships), then take the head() of the list (the latest created rel between them).

You really should be using labels, but for now I&#39;ll just expand off of your Cypher:

    MATCH (node)-[rel]-&gt;(target)
    WITH node, rel, target
    ORDER BY rel.createdAt
    WITH node, target, collect(rel) as rels
    RETURN node, target, head(rels) as rel
    LIMIT 10

If using Neo4j 4.1.x or later, then you can use a subquery to constrain the expansion and aggregation per node instead of having to do one large aggregation. This will be easier on your heap and thus better as your graph grows:

    MATCH (node)
    CALL {
     WITH node
     MATCH (node)-[rel]-&gt;(target)
     WITH rel, target
     ORDER BY rel.createdAt
     WITH target, collect(rel) as rels
     RETURN target, head(rels) as rel
    }
    RETURN node, target, rel
    LIMIT 10

(and again, you should be using labels and rel types, otherwise this has to do an AllNodesScan, which will have terrible performance as your graph grows).",1,66431319
2888,https://stackoverflow.com/a/66363864,Setting up Relationship types in GrandStack,true,"I was accidentally running 
```
const augmentedSchema = augmentSchema(schema);
```
on a schema that I had already ran 
```
makeAugmentedSchema({
  typeDefs,
  resolvers,
  // config: {
  //   query: true,
  //   mutation: true,
  // },
});
```
This was an artifact of moving away from makeExecutableSchema which I had to remove because it was causing issues.

namely:
```
Error: Unknown directive &quot;@relation&quot;.

Unknown directive &quot;@relation&quot;.

Unknown directive &quot;@cypher&quot;.

Unknown directive &quot;@relation&quot;.

Unknown directive &quot;@relation&quot;.

Unknown directive &quot;@relation&quot;.
```
So when i commented out the augmentSchema things started working fine.",0,66363864
2889,https://stackoverflow.com/a/66369711,Neo4j Cypher - How to limit 50% of MATCH results,true,"This is how I see it.  
1) Get all profiles and create a randomized number with each row 
2) Collect all profiles into a list of profiles and sorted by randomized number (r) 
3) Calculate the 50% of the size of the profile list 
4) Unwind the list from start to cnt then return each node
```
MATCH (n:Profile) 
WITH n, rand() as r ORDER by r 
WITH collect(n) as profile_lst
WITH profile_lst, toInt(size(profile_lst)/2) as cnt
UNWIND profile_lst[0..cnt] as prof
RETURN prof
```
",2,66369711
2890,https://stackoverflow.com/a/66385377,Trying to get relationships with unique endpoints from Neo4j Cypher query,false,"To achieve this in Cypher, you can use &#39;WITH&#39;. This is a very useful resource to help understand cypher: [cypher refcard][1]


  [1]: https://neo4j.com/docs/cypher-refcard/current/

The &quot;WITH&quot; works like a &quot;RETURN&quot; and calculates the cypher preceding it, allowing you then to work on the output of that in a another step in the cypher. This is how you can use it to achieve your result:

```
MATCH (A)-[:RELATIONSHIP1_TYPE]-&gt;(obj)-[:RELATIONSHIP2_TYPE]-&gt;(B) 
WITH A, count(distinct B) as unique_related_nodes
WHERE unique_related_nodes &gt; 25 
RETURN A
```

Given you are traversing a couple of hops, it is reasonable to assume you could find you are touching a lot of nodes. A couple things to help performance:

1. Use labels and relationship types, i.e.
```MATCH (A:LABEL_FOR_A)-[:RELATIONSHIP1_TYPE]-&gt;(obj:LABEL_FOR_MID)-[:RELATIONSHIP2_TYPE]-&gt;(B:LABEL_FOR_B)```

The middle node&#39;s label will be especially helpful in optimizing your query, but it may not be possible to know this label immediately. In which case, if needed, I would investigate the distinct labels that &#39;obj&#39; has and then work from there.

2. Use ```EXPLAIN``` to help understand where the query can be optimized:
```
EXPLAIN MATCH (A)-[:RELATIONSHIP1_TYPE]-&gt;(obj)-[:RELATIONSHIP2_TYPE]-&gt;(B) 
WITH A, count(distinct B) as unique_related_nodes
WHERE unique_related_nodes &gt; 25 
RETURN A
```

Enjoy!

",0,66385377
2891,https://stackoverflow.com/a/66391593,java.lang.IllegalArgumentException: Unsupported type [TEXT] of value String,true,"The problem is that the &quot;rating&quot; property is stored as a string. What you can do is cast it first as a float and then run the exact same GDS query.

So, first casting the rating property to a float:

    MATCH ()-[r:review]-&gt;()
    SET r.rating = toFloat(r.rating)

Now rerun the same GDS query and it should work.",1,66391593
2892,https://stackoverflow.com/a/66356343,Combining multiple nodes into one and map all the relations to that node neo4j,false,"if you remove the label constraint from your nodes, you should get all nodes and relationships between any two nodes that are have a sells relationship 
```
MATCH (a)-[:sells]-(b)
return *
```

",0,66356343
2893,https://stackoverflow.com/a/66369375,Combining multiple nodes into one and map all the relations to that node neo4j,false,"I&#39;ve given this a bit more thought and ideally, your model wouldn&#39;t differentiate between :Buyer and :Seller nodes, you&#39;d just have one node label, say :Entity which sells to another node of the same label.

[![Single node type Entity][1]][1]

However, we live in the real world and you may need to label nodes as :Buyer and :Seller, in which case, your only option would be to add a :Seller label to any :Buyers that sell and a :Buyer label to any :Sellers that buy. This would mean you end up with some nodes having two labels, one for each status they can be in, but it would  enable you to visualise what you want to:
[![Node with two labels][2]][2] 

As you can see, the highlighted node has two labels.

Unfortunately, you will not be able to generate this representation from the model you have as your :Buyer node 01AAAC is a completely different node to :Seller 01AAAC and they have no shared relationship between them.



  [1]: https://i.stack.imgur.com/0KRzZ.png
  [2]: https://i.stack.imgur.com/iDwl7.png",1,66369375
2894,https://stackoverflow.com/a/66350845,Can I run Flask and Neo4j in the same container?,false,"You generally want to run only one program in a container.  This is especially true if one of those programs is a database, and one an application that stores data there: you want to be able to replace the application container while leaving the database running, and in a production environment you could want to run multiple application containers for scale and redundancy but still have a single copy of the database.

Docker Compose is a standard tool, driven by a YAML file, that lets you describe multiple containers that need to work together:

&lt;!-- language: lang-yaml --&gt;

    # docker-compose.yml
    version: &#39;3.8&#39;
    services:
      application:
        build: .
        ports:
          - &#39;5000:5000&#39;
        environment:
          NEO4J_HOST: database # see below
      database:
        image: neo4j:4.2 # https://hub.docker.com/_/neo4j
        volumes:
          - dbdata:/data
    volumes:
      dbdata:


Each container is its own `localhost`, so you need to configure the application to look somewhere else for the database.  The Compose service names `application` and `database` are usable as host names, within this Docker environment (not by other Compose setups, not by browser applications even if they&#39;re served out of Docker, and not directly from the host).  [Networking in Compose](https://docs.docker.com/compose/networking/) in the Docker documentation describes this further.

This means your application will need some way to configure the database location.  An environment variable is easy to use:

&lt;!-- language: lang-py --&gt;

    from neo4j import GraphDatabase
    import os

    db_host = os.environ.get(&#39;NEO4J_HOST&#39;, &#39;localhost&#39;)
    db_port = os.environ.get(&#39;NEO4J_PORT&#39;, &#39;7687&#39;)
    driver = GraphDatabase.Driver(f&#39;neo4j://{db_host}:{db_port}&#39;)

The defaults here are fine for your host non-Docker development environment.  In your `docker-compose.yml` file you can specify alternate environment variable settings, which is the `environment:` block from above.

In production you could very reasonably want to run the database somewhere else: if your cloud provider has a hosted version of Neo4j you could use that, or you could want to run the database on dedicated hardware, even if the rest of the system runs in Docker.  The environment-variable mechanism lets you configure this as needed; it is not specific to Docker.

You shouldn&#39;t need to do anything special in your Dockerfile.  The Python Neo4j driver doesn&#39;t appear to have special host requirements, so it&#39;s enough to include it in your `requirements.txt` or `Pipfile` and build a plain Python-application image.  Don&#39;t include the database location or credentials in your source code or Dockerfile (beyond the developer-oriented defaults if the environment variables aren&#39;t set).",0,66350845
2895,https://stackoverflow.com/a/66371708,Neo4j cypher query results into Pandas DataFrame,true,"I am using py2neo so if you are using differently, you can either use it or tell me which neo4j lib you are using and I will edit my answer.

#1: Desired Result

&gt; I want results into pandas DataFrame in the format with nodes ids and
&gt; relation ids such as defined in csv above by querying the data from
&gt; graphDB and iterate the results row by row.

 
     from py2neo import Graph 
     from pandas import DataFrame
     # remove search by au.id=&#39;1&#39; and limit so that you will get all 
     # return the id in your query 
     session = Graph(&quot;bolt://localhost:7687&quot;, auth=(&quot;neo4j&quot;, &quot;****&quot;))
     query = &#39;&#39;&#39; MATCH (paper)-[au:AUTHORED{id: &#39;1&#39;}]-&gt;(author) RETURN paper.id, author.id, au.id LIMIT 3; &#39;&#39;&#39; 
     # access the result data
     result = session.run(query).data() 
     # convert result into pandas dataframe 
     df = DataFrame(result)
     df.head()

Result:

    0   1   1
    4   2   1
    44  3   1

#2: Another question 

&gt; how can I access the induvial properties of nodes and relation during
&gt; the cypher query  ANS: the properties inside nodes are dict so use the get function
 
     # Note that we are returning the nodes and not ids
     query = &#39;&#39;&#39; MATCH (paper)-[au:AUTHORED{id: &#39;1&#39;}]-&gt;(author) RETURN paper, author, au LIMIT 3; &#39;&#39;&#39; 
    result = session.run(query).data() 
    print (&quot;What is data type of result? &quot;, type(result))
    print (&quot;What is the data type of each item? &quot;, type(result[0]))
    print (&quot;What are the keys of the dictionary? &quot;, result[0].keys())
    print (&quot;What is the class of the node? &quot;, type(result[0].get(&#39;paper&#39;)))
    print (&quot;How to access the first node? &quot;, result[0].get(&#39;paper&#39;))
    print (&quot;How to access values inside the node? &quot;, result[0].get(&#39;paper&#39;,{}).get(&#39;id&#39;))

    Result:
    What is data type of result?  &lt;class &#39;list&#39;&gt;
    What is the data type of each item?  &lt;class &#39;dict&#39;&gt;
    What are the keys of the dictionary?  dict_keys([&#39;paper&#39;, &#39;author&#39;, &#39;au&#39;])
    What is the class of the node?  &lt;class &#39;py2neo.data.Node&#39;&gt;
    How to access the first node?  (_888:paper {id: &#39;1&#39;})
    How to access values inside the node?  &#39;1&#39;",2,66371708
2896,https://stackoverflow.com/a/66607522,Creating knowledge graphs in Neo4j,false,"You can import RDF data into Neo4j, however it will not be exactly in that format. Using [Neosemantics][1], the triples will be converted into a property graph.

Neosematics can reconvert the property graph data back into triples should that be required.


  [1]: https://neo4j.com/labs/neosemantics/",0,66607522
2897,https://stackoverflow.com/a/66357146,Neo4J Params on Javascript,false,"The comment of @fbiville helped me as a hint to get to an answer. I changed the param of the property to props and now it works.
Thank you 

```
app.post(&quot;/person/originalname/add&quot;, function(req, res) {
  var originalname = req.body.originalname;
  var id = req.body.id;

  session
    .run(
      &quot;MATCH (n) where id(n) = $idParam SET n = $props&quot;,
      {
        props: {
          &quot;original_name&quot;: originalname
        },
        idParam: id
      })

    .then(function(result) {
      res.redirect(&#39;/&#39;);

    })
    .catch(function(error) {
      console.log(error);

    });

});
```",0,66357146
2898,https://stackoverflow.com/a/66324995,Neo4j building initial graph is slow,true,"You may want to EXPLAIN the query and make sure that NodeIndexSeeks are being used, and not NodeByLabelScan. You also mentioned an index on :Person(pn), but you have a lookup on :Person(userId), so you might be missing an index there, unless that was a typo.

Regarding the cartesian product warning, disregard it, the cartesian product is necessary in order to get the nodes to create the relationship, this should be a 1 x 1 = 1 row operation so it&#39;s only going to be costly if multiple nodes are being matched per side, or if index lookups aren&#39;t being used.

If these are part of some batch load operation, then you may want to make your query apply in batches. So if 100 contacts are being loaded by a user, you do NOT want to execute 100 queries each, with each query adding a single contact. Instead, pass as a parameter the list of contacts, then UNWIND the list and apply the query once to process the entire batch.

Something like:

```
UNWIND $batch as row
MATCH (p1:Person {pn: row.p1}), (p2:Person {pn: row.p2) 
MERGE (p1)-[:REL]-&gt;(p2) 
RETURN p1, p2
```

It&#39;s usually okay to batch 10k or so entries at a time, though you can adjust that depending on the complexity of the query 

Check out this blog entry for how to apply this approach.

https://dzone.com/articles/tips-for-fast-batch-updates-of-graph-structures-wi",1,66324995
2899,https://stackoverflow.com/a/66325052,Neo4j building initial graph is slow,false,"You can use the index you created on Person by suggesting a planner hint.
Reference: https://neo4j.com/docs/cypher-manual/current/query-tuning/using/#query-using-index-hint

    CREATE INDEX ON :Person(pn);
    
    MATCH (p1:Person {userId: &quot;.....&quot;}) 
    WITH p1
    MATCH (p2:Person) using index p2:Person(pn)
    WHERE p2.pn = &quot;.....&quot;
    MERGE (p1)-[:REL]-&gt;(p2) 
    RETURN p1, p2",0,66325052
2900,https://stackoverflow.com/a/66325749,Load database from offline back-up Neo4j,true,"If you are replacing your existing database with name &quot;db&quot; then use the --force option:

`bin/neo4j-admin load --from=/var/lib/neo4j/data/c: --database=dbase --force`

If you are restoring into a new database, then after the load, you need to create the database `CREATE DATABASE dbase`

Note that I changed the name of your database from `db` to something else since database names in Neo4j must be at least 3 characters long.",1,66325749
2901,https://stackoverflow.com/a/66318768,Get the all the nodes connected to a specific node with relationship,true,This is a Neo4j Browser functionality. Disable &quot;connect result nodes&quot; in neo4j browser and you will only get the relationships from your query.,2,66318768
2902,https://stackoverflow.com/a/66322469,Get nodes sorted by proximity and at the same level sort by date,false,"When you aggregate the nodes, it will not remove duplicates so adding the keyword &quot;distinct&quot; will fix it.  Instead of COLLECT(o), use COLLECT(DISTINCT o) as opponents and COLLECT(DISTINCT ops). 

    // Getting direct opponents
    MATCH (p:Player {userId: &quot;34618&quot;})&lt;-[:HAS_PLAYERS]-(g:Game)-[:HAS_PLAYERS]-&gt;(o:Player)
    WITH p, o, g ORDER BY g.gameDate DESC 
    WITH p, COLLECT(DISTINCT o) AS opponents
    // Getting opponents-of-opponents (ops)
    MATCH (p)-[:HAS_PLAYERS*3]-(gops:Game)--(ops:Player)
    WHERE p.userId &lt;&gt; ops.userId AND NOT ops IN opponents
    // Trying to remove duplicated nodes
    WITH DISTINCT ops, opponents, gops
    WITH opponents, ops, gops ORDER BY gops.gameDate DESC
    // Concat both lists: opponents and opponents-of-opponents
    WITH REDUCE(s = opponents, o2 IN COLLECT(DISTINCT ops) | s + o2) as listAllOpponents
    UNWIND listAllOpponents as opPlayer
    RETURN opPlayer

    Result:
       PlayerB
       PlayerC
       PlayerE
       PlayerD",1,66322469
2903,https://stackoverflow.com/a/66488684,Get nodes sorted by proximity and at the same level sort by date,true,"This is my solution:

    # Getting direct opponents
    MATCH (p:Player {userId: &quot;PlayerA&quot;})&lt;-[:HAS_PLAYERS]-(g:Game)-[:HAS_PLAYERS]-&gt;(o:Player)
    WITH p, o, max(g.gameDate) as maxDate
    WITH p, o ORDER BY maxDate DESC
    WITH p, COLLECT(o) AS opponents
    # Getting opponents-of-opponents (ops)
    OPTIONAL MATCH (p)-[:HAS_PLAYERS*3]-(gops:Game)--(ops:Player)
    WHERE p.userId &lt;&gt; ops.userId AND NOT ops IN opponents
    WITH opponents, ops, max(gops.start) as maxDate
    WITH opponents, ops ORDER BY maxDate DESC
    WITH opponents, COLLECT(ops) AS opponentsOfOpponents
    # Concat both lists: opponents and opponents-of-opponents
    UNWIND (opponents + opponentsOfOpponents) AS player
    RETURN player",0,66488684
2904,https://stackoverflow.com/a/66313246,Full outer join in Neo4j,false,"I couldn&#39;t think of a better query than looking for each type pair, checking that they are not connected to other types, and then combining each sub-query with `UNION`. This results in a quite big query. Maybe someone else can think of a more dynamic query.

```
MATCH (n1:Type1)--(n2:Type2)
OPTIONAL MATCH (n2)--(n3:Type3)
OPTIONAL MATCH (n3)--(n4:Type4)
OPTIONAL MATCH (n4)--(n5:Type5)
WITH n1, n2, n3, n4, n5
WHERE n3 IS NULL
RETURN n1, n2, n3, n4, n5

UNION

MATCH (n2:Type2)--(n3:Type3)
OPTIONAL MATCH (n2)--(n1:Type1)
OPTIONAL MATCH (n3)--(n4:Type4)
OPTIONAL MATCH (n4)--(n5:Type5)
WITH n1, n2, n3, n4, n5
WHERE n1 IS NULL AND n4 IS NULL
RETURN n1, n2, n3, n4, n5

UNION

MATCH (n3:Type3)--(n4:Type4)
OPTIONAL MATCH (n3)--(n2:Type2)
OPTIONAL MATCH (n2)--(n1:Type1)
OPTIONAL MATCH (n4)--(n5:Type5)
WITH n1, n2, n3, n4, n5
WHERE n2 IS NULL AND n5 IS NULL
RETURN n1, n2, n3, n4, n5

UNION

MATCH (n4:Type4)--(n5:Type5)
OPTIONAL MATCH (n4)--(n3:Type3)
OPTIONAL MATCH (n3)--(n2:Type2)
OPTIONAL MATCH (n2)--(n1:Type1)
WITH n1, n2, n3, n4, n5
WHERE n3 IS NULL
RETURN n1, n2, n3, n4, n5
```

__UPDATE:__

Without the requirement of returning `NULL` the query can be shortened:

```
MATCH (n1:Type1)--(n2:Type2)
WHERE NOT (n2)--(:Type3)
RETURN n1, n2

UNION

MATCH (n1:Type2)--(n2:Type3)
WHERE NOT (n1)--(:Type1) AND NOT (n2)--(:Type4)
RETURN n1, n2

UNION

MATCH (n1:Type3)--(n2:Type4)
WHERE NOT (n1)--(:Type2) AND NOT (n2)--(:Type5)
RETURN n1, n2

UNION

MATCH (n1:Type4)--(n2:Type5)
WHERE NOT (n1)--(:Type3)
RETURN n1, n2
```",1,66313246
2905,https://stackoverflow.com/a/66306912,Developing graph database model for department/supplier/items,true,"You want to store and query a triangular relationship between `:Dept`, `:Item`, and `:Company`. This can&#39;t be accomplished by a linear relationship pattern. Comparing IDs of entities is not the Neo4j way, you would neglect the strengths of a graph database.

(Assuming that I understood your use case scenario) I would introduce an additional node of type `:SupplyEvent` that has relationships to `:Dept`, `:Item`, and `:Company`. You could also split up `:SOLD` relationship in a similar way, if you want relations between department, item, and, e.g., a customer.

[![enter image description here][1]][1]

Now, you can query all companies that supplied which items to which departments (without comparing any IDs):

```sql
MATCH (company:Company)&lt;-[:SUPPLIED_FROM]-(se:SupplyEvent)-[:SUPPLIED_TO]-&gt;(dept:Dept),
      (se)-[:SUPPLIED]-&gt;(item:Item)
RETURN company, item, dept
```

  [1]: https://i.stack.imgur.com/FgMZ9.jpg",1,66306912
2906,https://stackoverflow.com/a/66313576,How to use ForEach in .Net Client,false,"You can&#39;t, and (despite the other question) I don&#39;t think you&#39;ve ever been able to. I can&#39;t find that overload anywhere in the codebase, even in April 2016 it doesn&#39;t seem to be there. 

The only way at the moment would be to do:

```
var myArray = new [] {1,2,3};
client.Cypher
    .ForEach(&quot;(val IN $myParam | ...)&quot;)
    .WithParam(&quot;myParam&quot;, myArray)
    /// etc
```",0,66313576
2907,https://stackoverflow.com/a/66313709,Execute recursive saves together or seperately?,false,"There&#39;s no real way to answer as it&#39;s dependent on your use case. 

*If* your subgraphs etc should all be there, or not at all, then you should do it all in one transaction. This is no different to anything else - database or indeed application wise. The benefit of the transaction is that is any one part of it fails, it all fails. 

In terms of performance, there&#39;s no real difference between the two approaches, in both you are making *n* calls to the DB.",0,66313709
2908,https://stackoverflow.com/a/66319010,neo4j - creating graph projection from flat data,false,"User1 and User2 belongs to the same class (node): Person
The relationship between person is :has_followed with counts and category as attributes. 
Here is the script to load the data such as

    LOAD CSV WITH HEADERS FROM &#39;https://***.csv&#39; AS row
    MERGE (p1: Person {name: row.User1})
    MERGE (p2: Person {name: row.User2})
    MERGE (p1)-[:HAS_FOLLOWED {count: row.Count, category: row.Category}]-&gt; (p2)

No need to worry about Tim, Harry and Danny because this person is found in multiple rows. Merge command will not create another node (Person) if it already exists.",0,66319010
2909,https://stackoverflow.com/a/66295813,Issues writing a query that would fetch the second degree friends of Abiodun considering the pattern and the relationships,true,"You can use a fixed length relationship from Abiodun to Amanda.
The meaning of &quot;*2&quot; in the relationship is &quot;give me a friend of friend of Abiodun&quot;.

    MATCH (:Person {name: &quot;Abiodun&quot;}) - [:FRIEND*2] -&gt; (p:Person)
    RETURN p

This is found in details here: https://neo4j.com/docs/cypher-manual/current/clauses/match/#varlength-rels",0,66295813
2910,https://stackoverflow.com/a/66325130,What is exact time in Neo4j execution time?,false,"You may want to check your debug logs around the time of the query&#39;s execution. Look for stop-the-world pauses.

The query execution time is a wall clock time that will include any VM pauses that happened between query start and query stop. If you see this, then depending on whether you see positive GC counts or not in the pause readout, it could indicate that there are some unoptimized queries triggering garbage collections that cause VM pauses, and you may need to do some query tuning to optimize them.",0,66325130
2911,https://stackoverflow.com/a/66272160,Neo4j create edges with multiple labels/properties,true,"Yes you can- these are relationship/edge properties. A relationship does not have labels, just a type and properties.

To create the relationship with all properties in one go, you can do

```
MATCH (u:User {name:&quot;A&quot;})
MATCH (i:Item {name:&quot;B&quot;})
CREATE (u)-[r:CLICKED]-&gt;(i)
SET r.createdAt=$timestamp, r.userKey=$userkey
```

Or if you already have the relationship and want to add properties to it:


```
MATCH (u:User {name:&quot;A&quot;})
MATCH (i:Item {name:&quot;B&quot;})
MERGE (u)-[r:CLICKED]-&gt;(i)
SET r.createdAt=$timestamp, r.userKey=$userkey
```

",2,66272160
2912,https://stackoverflow.com/a/66325192,Neo4j 3.5 Query Performance Issue,true,"You&#39;re not using the `name` property in this query, so your index won&#39;t help. The only indexes that may help would be on `:master_node(latest_ingestion)` or `:PERF(latest_ingestion)`, that may change the query from using label scans to index scans, depending on db statistics. 

Also, you may want to consider batching these updates, likely using `apoc.periodic.iterate()` from APOC procedures. Something like:

    CALL apoc.periodic.iterate(&quot;
      MATCH (a:master_node:PERF:Application)--&gt;(n:master_node:PERF)-[:AFFINITY]-&gt;(m:master_node:PERF)&lt;--(a1:master_node:PERF:Application)
      WHERE exists(n.latest_ingestion)
        AND exists(m.latest_ingestion)
        AND id(a) &lt;&gt; id(a1)
      RETURN a, a1&quot;,
      &quot;MERGE (a)&lt;-[:APP_AFFINITY]-(a1)&quot;, 
      {}) YIELD batches, total, errorMessages
    RETURN batches, total, errorMessages",1,66325192
2913,https://stackoverflow.com/a/66258532,Designing and implementing SaaS Application with Muti-tenancy GraphDB (Neo4J / ArangoDB),false,"With ArangoDB you only need one instance and can simply use a database per tenant.

Each database is isolated, for example, AQL queries run in the context of a single database and you can only access the collections and named graphs of that database.

[![ArangoDB Architecture - Hierarchy of Databases, Collections and Documents][1]][1]

You can create an ArangoDB user for each customer and restrict its access to the respective database to achieve the desired isolation.

For scalability and resilience, there is also the [OneShard](https://www.arangodb.com/docs/stable/architecture-deployment-modes-cluster-architecture.html#oneshard) feature (Enterprise Edition / [managed service](https://cloud.arangodb.com/)). It enables you to have a cluster where each database is treated like a single shard, i.e. all collections of a customer are stored on one DB-Server (excluding replicas), so that queries can be executed locally on that node. This is especially beneficial for graph traversals.

  [1]: https://i.stack.imgur.com/ItynO.jpg",0,66258532
2914,https://stackoverflow.com/a/66267938,Designing and implementing SaaS Application with Muti-tenancy GraphDB (Neo4J / ArangoDB),false,"Since Neo4j 4.0 multi-tenancy is supported via multi-database.

In the system database you can create as many databases as you want and from a client select the database to talk to on a session by session basis, so you can use each database for a tenant.

Here is the JS API:

https://neo4j.com/docs/api/javascript-driver/current/class/src/driver.js~Driver.html#instance-method-session

Each database instance can handle hundreds or thousands of databases.

[![enter image description here][1]][1]

With Neo4j Fabric enabled you can do cross-database federated queries.


here are some more examples

* https://adamcowley.co.uk/neo4j/multi-tenancy-neo4j-4.0/
* https://graphaware.com/neo4j/2020/02/06/multi-tenancy-neo4j.html
* https://neo4j.com/developer/multi-tenancy-worked-example/


  [1]: https://i.stack.imgur.com/y9Nkp.png",1,66267938
2915,https://stackoverflow.com/a/66257012,Read json property names in json with CYPHER,true,"The [`keys`][1] function can help here. Elaborating on your initial query:

```
WITH &quot;file:///data.json&quot; as json
CALL apoc.load.json(json) YIELD value
UNWIND value.list AS item
UNWIND item.actors AS actors
// Extract map&#39;s keys, that will be the ID
WITH keys(actors) as keys, actors
// &quot;loop&quot; over keys
UNWIND keys as key
RETURN key as id, actors[key] as name
```

Result:
```
╒═══════╤══════╕
│&quot;id&quot;   │&quot;name&quot;│
╞═══════╪══════╡
│&quot;78901&quot;│&quot;Tata&quot;│
├───────┼──────┤
│&quot;45867&quot;│&quot;Tutu&quot;│
├───────┼──────┤
│&quot;74017&quot;│&quot;Titi&quot;│
├───────┼──────┤
│&quot;88187&quot;│&quot;Toto&quot;│
├───────┼──────┤
│&quot;45867&quot;│&quot;Tutu&quot;│
├───────┼──────┤
│&quot;42815&quot;│&quot;Lala&quot;│
└───────┴──────┘
```


  [1]: https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-keys",1,66257012
2916,https://stackoverflow.com/a/66251770,Multi-tenancy Architecture in a graph DB,false,"With ArangoDB, a solution that works is:
 - Use a single database for all customers
 - Use Foxx microservices in that database to provide access to all data
 - Enforce a tenantId value on every call to Foxx
 - Use dedicated collections for each tenant in that database
 - Set up a web server (e.g. Node.js) in front of ArangoDB that serves data to all tenants
 - Only allow connections to Foxx from that front end web server

Each tenant will need a few collections, depending on your solution, try to keep that number as low as possible.

This model works pretty well, and you&#39;re able to migrate customers between instances / regions as their data is portable, because it&#39;s in collections.",0,66251770
2917,https://stackoverflow.com/a/66235616,Periodic commit through bolt port in neo4j (java driver),true,"https://neo4j.com/docs/driver-manual/1.7/sessions-transactions/

We need to use auto-commit transactions in this case. As the documents says:

**Auto-commit transactions are the only way to execute USING PERIODIC COMMIT Cypher statements.**

Example:

```
public void addPerson( String name )
{
    try ( Session session = driver.session() )
    {
        session.run( &quot;CREATE (a:Person {name: $name})&quot;, parameters( &quot;name&quot;, name ) );
    }
}
```",1,66235616
2918,https://stackoverflow.com/a/66243590,Periodic commit through bolt port in neo4j (java driver),false,"Faced the same, while working in python. You can use apoc&#39;s according based on your requirement 

    apoc.periodic.iterate(&#39;statement returning items&#39;, &#39;statement per item&#39;, {batchSize:1000,iterateList:true,parallel:false,params:{},concurrency:50,retries:0})

or 

    apoc.periodic.commit(statement,params)

",0,66243590
2919,https://stackoverflow.com/a/66236172,Restore Neo4j DB from Backup with Neo4J Desktop,false,"You&#39;ll need to use the [neo4j-admin tool][1] 
From Neo4j desktop, go to your database/create a new one, then open the Terminal for that database (in older versions, it was in the Manage menu, in newer versions, you&#39;ll find it in the 3 ... menu)

Once you have the terminal open, `cd bin` and follow the manual to restore


  [1]: https://neo4j.com/docs/operations-manual/current/backup-restore/restore-backup/#restore-backup",0,66236172
2920,https://stackoverflow.com/a/66232150,Search in a List that starts with a string in Neo4j,false,"You can use the `ANY` predicate:  

    MATCH (e:Employees) 
    WHERE ANY(x IN [&#39;CLR&#39;, &#39;MVV&#39;, &#39;OPP&#39;] WHERE e.Code STARTS WITH x)
    RETURN *",0,66232150
2921,https://stackoverflow.com/a/66223042,How to exclude a label in neo4j for relationship,true,"Relationships do not have **label**s, only nodes have. 
Relationships have a single **type**.
In your query, `p` is already of type `PLAYED` so it cannot be of any other type.

Moreover, `p:Today` is the syntax for **label** predicates, but `p` is bound to a relationship, hence the error.

If you had a less constrained pattern such as `()-[p]-&gt;()`, then you could check the type with `TYPE(p)`. Note however that you will end up traversing the whole connected graph with this pattern.",1,66223042
2922,https://stackoverflow.com/a/66222387,Cypher: How to traverse across any relationship except for a specific label,true,"You can go with a WHERE statement like this:

```
MATCH (t:Thing {name: &#39;Starting Point&#39;})-[x*1..4]-(o)
WHERE all(r in x WHERE type(r) &lt;&gt; &#39;CREATED_BY&#39;)
RETURN t, o
```

It basically loops over all relationships in `r`, extracts the relationship type and compare it to &#39;CREATED_BY&#39;. The `all` predicate ensures all relationships in the path are not of the type &#39;CREATED_BY&#39;.

Check the documentation for the `all` function here:
https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-all


You can also check the APOC advanced querying tool (https://neo4j.com/labs/apoc/4.1/graph-querying/), especially the path expander procedures, but as far as I know, you can&#39;t blacklist a certain relationship type (only whitelist the allowed ones). If you can turn your exclusion into a inclusion list, it would be a nice alternative.
",1,66222387
2923,https://stackoverflow.com/a/66217516,Neo4j Cypher Query multiple relationship from same node,false,"If your node `M` is connected like this `S -&gt; M &lt;- C` (M is `Member`, S is `Shop`, and C is `Club`), then you can use query similar like example in **4.2 Multiple Relationships** in [documentation](https://neo4j.com/docs/cypher-manual/current/clauses/match/):

```
MATCH (s: Shop) - [rs: MEMBER_BELONGS_TO_SHOPS] -&gt;
      (m: Member { username: $memberUsername ,
                   password: $password}) &lt;- [r: MEMBER_BELONGS_TO_CLUBS] - (c: Club)
RETURN m, c, r, s, rs
```

Also you can use syntax like in this [example](https://community.neo4j.com/t/multiple-match-queries/16696) with multiple `MATCH`:
```
MATCH (m: Member { username: $memberUsername ,
                  password: $password})
MATCH (s: Shop) - [rs: MEMBER_BELONGS_TO_SHOPS] -&gt; (m)
MATCH (m) &lt;- [r: MEMBER_BELONGS_TO_CLUBS] - (c: Club)
RETURN m, c, r, s, rs
```

And both queries returns something only if `M` is connected with both `S` and `C`. If you
don&#39;t want that restrictions you can use `OPTIONAL MATCH` [documentation](https://neo4j.com/docs/cypher-manual/current/clauses/optional-match/).",0,66217516
2924,https://stackoverflow.com/a/66263929,Add relationships to existing data in Neo4j,false,"Do you have indexes set? Looking at your first query, you&#39;d need:

    CREATE INDEX ON :Flight(Dest);
    CREATE INDEX ON :Airport(IATA_Code);
    
If you don&#39;t have indexes/constraints set on the label/property, the look up/merge will be very slow.",0,66263929
2925,https://stackoverflow.com/a/66198983,Spring Neo4j JPA native dynamic order by query,false,"Use the the variable sortBy how parameter in the function service and repository, and use this variable for create a dinamic order in the native query.",0,66198983
2926,https://stackoverflow.com/a/66321616,Spring Neo4j JPA native dynamic order by query,true,"I found the solution. Just use SpEL.

https://docs.spring.io/spring-data/neo4j/docs/6.0.5/reference/html/#custom-queries.spel

",1,66321616
2927,https://stackoverflow.com/a/66264135,Neo4j - Adding indexes correctly,false,"As you&#39;re not ANDing different properties, you would need to create an index for each property you&#39;re doing filtering against.

This [blog post][1] might be useful.


  [1]: https://maxdemarzi.com/2020/02/19/composite-indexes-in-neo4j-4-0/",0,66264135
2928,https://stackoverflow.com/a/66179541,Why don&#39;t these Cypher queries do the same thing?,false,"I am not exactly sure what seems to be the problem. I can give you hint how you can improve your query a bit. When you want to do filtering on later steps, you don&#39;t have to use another MATCH statement. In your case:

    MATCH (t:type)-[:HAS]-&gt;(m:model)-[:HAS]-(r:region)-[:HAS]-(p:param)-[:HAS]-(i:init { value: 1613044800})-[init_has:HAS]-(u:{url: &#39;http://something2.png&#39;}) 
    DELETE init_has, u
    WITH [i,p,r,m,t] AS parents
    UNWIND parents AS parent
    WITH parent 
    WHERE NOT (parent)-[:HAS]-&gt;()
    DETACH DELETE parent

I am not sure if this will solve your problem though. The query looks fine so it is hard to say whats wrong without an example.",1,66179541
2929,https://stackoverflow.com/a/66901410,Neo4j - encountering FetchURLError whenever using any query with GET or POST,false,"I recently ran into the same problem and for me it worked by writing the full URL. E.g.:

    :GET http://localhost:7474/rdf/neo4j/describe/11",0,66901410
2930,https://stackoverflow.com/a/66172541,Neo4j combine arrays from a return,false,"I was being stupid, I simply needed to match ContentAttachment and return id.",0,66172541
2931,https://stackoverflow.com/a/66170687,Javascript Neo4j Driver Json parse express api,true,"Based on the [existing examples][1], what about:

```javascript
session
    .readTransaction((tx) =&gt; 
       tx.run(`MATCH (foo:FamilyMember)-[:HAS_SISTER]-&gt;(sister:FamilyMember)
               WHERE foo.firstName = &#39;bar&#39;
               RETURN sister.firstName AS Name, sister.lastName AS Surname`)
    )
    .then(results =&gt; results.records.map((record) =&gt; {
       return {
              Name: record.get(&#39;Name&#39;),
              Surname: record.get(&#39;Surname&#39;)
       }
    })
```

You could keep `session.run`, but the `session.{read,write}Transaction` variants are [usually recommended][2] because they work in every environment (where `session.run` may sometimes fail in a cluster environment).

Please also make sure to use a dictionary of parameters (2nd argument of `tx.run`) instead of using string interpolation, if your query needs to be parameterized. If the value of `foo.firstName` comes from a variable (let&#39;s say `someFirstName`), the `tx.run` would become:

```javascript
tx.run(&quot;MATCH (foo:FamilyMember)-[:HAS_SISTER]-&gt;(sister:FamilyMember)
               WHERE foo.firstName = $firstName
               RETURN sister.firstName AS Name, sister.lastName AS Surname&quot;,
       {firstName: someFirstName})
``` 

  [1]: https://github.com/neo4j-examples/movies-javascript-bolt/blob/main/src/neo4jApi.js#L22
  [2]: https://neo4j.com/docs/driver-manual/current/session-api/configuration/#driver-simple-transaction-fn",1,66170687
2932,https://stackoverflow.com/a/66166795,Delete DB and transaction logs on Neo4j 4.2.3 Community Server,true,"With Neo4j 4+, you will need to delete:

```
/data/databases/&lt;your_db_name&gt;
/data/transactions/&lt;your_db_name&gt;
```

",1,66166795
2933,https://stackoverflow.com/a/66163134,How to prevent neo4j MERGE from creating duplicate relationships?,true,"The `MERGE` statement checks if the pattern as a whole already exists or not. So, if there is one node different, the whole pattern is determined as non-existent and all relationships are created.

The solution is to split this `MERGE` statement into multiple, i.e. one `MERGE` for each relationship:

```sql
MERGE (t)-[:HAS]-(m)-[:HAS]-(r)-[:HAS]-(p)-[:HAS]-(i)-[:HAS]-(u)
```

becomes

```sql
MERGE (t)-[:HAS]-(m)
MERGE (m)-[:HAS]-(r)
MERGE (r)-[:HAS]-(p)
MERGE (p)-[:HAS]-(i)
MERGE (i)-[:HAS]-(u)
```",1,66163134
2934,https://stackoverflow.com/a/66170443,How to store the returned record of the results of a Neo4J query in Python?,false,"Something like:

```python
with graphDB_Driver.session() as graphDB_Session:
        graphDB_Session.run(query)
        nodes = graphDB_Session.run(edge_query)
        df = []
        for x in nodes:
            df.append(node)
df
```

should work.",0,66170443
2935,https://stackoverflow.com/a/66134266,Is there any way i can run cypher command starting from :Param using py2neo 2021.0.0,false,"You can pass a dictionary of parameters to the `run` method, as documented [here][1].


  [1]: https://py2neo.org/2021.0/database/index.html#py2neo.database.Graph.run",0,66134266
2936,https://stackoverflow.com/a/66141636,Is there any way i can run cypher command starting from :Param using py2neo 2021.0.0,false,"The `:PARAM` command is a client-side browser/shell built-in. It does not exist in Cypher itself. As mentioned by [@fbiville][1], you will need to pass a dict of parameters instead.


  [1]: https://stackoverflow.com/users/277128/fbiville",1,66141636
2937,https://stackoverflow.com/a/66130103,Neo4j errorMessages&#39;: {&#39;Invalid input \&#39;a\&#39;: expected \&#39;u/U\&#39;},true,"Your usage of `CREATE CONSTRAINT` is invalid- it should not be part of a Cypher query such as LOAD CSV.

Create the constraint first: 

```
CREATE CONSTRAINT constraint_name IF NOT EXISTS ON (n:House) ASSERT n.household IS UNIQUE
```

And then you can run a new Cypher statement to load data. 

Unrelated note: You do not need to use apoc.periodic.iterate to batch the LOAD CSV, you can use a periodic commit too https://neo4j.com/docs/cypher-manual/current/clauses/load-csv/#load-csv-setting-the-rate-of-periodic-commits 

",1,66130103
2938,https://stackoverflow.com/a/66134119,Query to check all source status in node is complete?,true,"You can aggregate all the sources with [COLLECT][1] and run a predicate with [ALL][2].

```
MATCH (sub:Sub)-[:HAS]-&gt;(source:Source)
WITH sub, COLLECT(source) AS sources 
WHERE ALL(src IN sources WHERE src.status = &#39;COMPLETE&#39;)
DETACH DELETE sub
```


  [1]: https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-collect
  [2]: https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-all",0,66134119
2939,https://stackoverflow.com/a/66130151,"Skiping relationship creation if already exist, not about MERGE",false,"There&#39;s no need to create nodes in this fashion, i.e. set properties and then load the same csv again but match all nodes in the graph and do a cartesian join.

Instead:

```
USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS FROM &#39;file:///departments.csv&#39; AS row
CREATE (d:Department) SET d.deptNo=row.dept_no, d.name=row.dept_name
```

```
USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS FROM &#39;file:///dept_emp.csv&#39; AS row
MATCH (d:Department {deptNo:row.`dept_no`})
WITH d
MERGE (e:Employee {empNo: row.`emp_no`})
MERGE (e)-[:BELONGS_TO]-&gt;(d)
```
",0,66130151
2940,https://stackoverflow.com/a/66117799,Relationships between nodes are not created or updated,false,"try to use create it will create relationship
```
CREATE (w)-[:HAS_WRITTEN]-&gt;(b)
```",0,66117799
2941,https://stackoverflow.com/a/66117946,Relationships between nodes are not created or updated,true,"`params` only has the key `id` but yet you lookup `bookid` and `writterid` in the cypher. Maybe try,

    params.append({&#39;bookid&#39;:row.bookid, &#39;writterid&#39;:row.writterid})",1,66117946
2942,https://stackoverflow.com/a/66114956,How to recover deleted nodes and relationships in neo4j,false,"Unfortunately not, unless you have a backup. ",3,66114956
2943,https://stackoverflow.com/a/66105299,Graphlytic Desktop error Neo4j Graph is not running.Please start Neo4j Graph and then restart Graphlytic,false,"This is a common issue when you start the Graphlytic Desktop app from the left menu in Neo4j Desktop project and no Neo4j Graph is Activated. 

Solution: start any Neo4j Graph and then start the Graphlytic App again.
Check out the official guidelines here: https://graphlytic.biz/blog/how-to-install-graphlytic-in-neo4j-desktop",1,66105299
2944,https://stackoverflow.com/a/66158958,How to connect to neo4j on remote server using cytoscape neo4j plugin,false,"It certainly should work, but since Neo4J uses it&#39;s own port, which isn&#39;t opened by default on most hosts, you may need to tweak your server firewall.

-- scooter",0,66158958
2945,https://stackoverflow.com/a/66095651,neo4j admin import csv with multiple labels fails to parse labels when array delimiter are enabled,true,"The default array delimiter is `;` so your first example correctly assigns both the Movie and Sequel labels to nodes that have `Movie;Sequel` in the LABEL column.

Not sure why you wish the delimiter to be a `|`? Your csv file would then need to look like

```
movieId:ID,title,year:int,:LABEL
tt0133093,&quot;The Matrix&quot;,1999,Movie
tt0234215,&quot;The Matrix Reloaded&quot;,2003,Movie|Sequel
tt0242653,&quot;The Matrix Revolutions&quot;,2003,Movie|Sequel
```",1,66095651
2946,https://stackoverflow.com/a/66077122,neo4j query conversion to use in function,false,"I&#39;m not clear how the order is different with 

```
MATCH (q:Queue)-[:queue_person]-&gt;(pr:Person)-[:person_successor]-&gt;(:next:Person)
WHERE q.name in [&#39;A&#39;,&#39;B&#39;]
RETURN pr.name, next.name
```
It is hard to tell from the response you shared.

Another way to write it would be

```
MATCH (q:Queue)
WHERE q.name in [&#39;A&#39;,&#39;B&#39;]
WITH q
MATCH (pr:Person)-[:person_successor]-&gt;(next:Person)
WHERE (q)-[:queue_person]-&gt;(pr)
RETURN pr.name, next.name
```",0,66077122
2947,https://stackoverflow.com/a/66083294,neo4j query conversion to use in function,true,"I think the problem of this query in your question

    MATCH (q:Queue)-[:queue_person]-&gt;(pr:Person)-[:person_successor]-&gt;(:next:Person)
    WHERE q.name in [&#39;A&#39;,&#39;B&#39;]
    RETURN pr.name, next.name
is in this : `(:next:Person)`. and you just need to change to `(next:Person)`


But if it is not , you can use UNWIND :

          UNWIND [&quot;A&quot;, &quot;B&quot;] AS name
          MATCH (pr:Person)-[:person_successor]-&gt;(next:Person)
          WHERE (:Queue {name: name}) -[:queue_person]-&gt; (pr)
          RETURN pr.name, next.name",1,66083294
2948,https://stackoverflow.com/a/66115323,grandstack add mutation with relationship,false,"You can provide several operations in Graphql in the following way:

```
mutation($name: String!, $login: String!) {
  CreateRepository(name: $name) {
    name
  }
  AddRepositoryOwner(from: { login: $login }, to: { name: $name }) {
    from {
      login
    }
    to {
      name
    }
  }
}
```

Also providing the variables:

```
{
    variables: {
        login: &quot;login&quot;,
        name: &quot;name&quot;,
    }
}
```

That&#39;s the closest to what you want to achieve I am aware of.",0,66115323
2949,https://stackoverflow.com/a/66072761,How to Pass Input Value into Cypher Query?,false,"After a little more experimenting, I am able to pass the input value to my Cypher query.

2 modifications were necessary:

 1. I needed to add a var inside my function that would capture the value of the input: 
```
var inputthebeer = document.getElementById(&quot;inputbeer&quot;).value;
```
 2. I had to update my Cypher query to allow me to insert that var: 
```js
`
MATCH (bry:Brewery)-[r:BREWS]-&gt;(b:Beer {name: &#39;`+inputthebeer+`&#39;})-[r2:IS_A]-&gt;(bt:BeerType) 
Optional Match (b)-[r3:BREWED_WITH]-&gt;(h:Hop) 
Return bry,r,b,r2,bt,r3,h
`
```
",-1,66072761
2950,https://stackoverflow.com/a/66072951,How to Pass Input Value into Cypher Query?,true,"You are trying to use [Javascript template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals). The syntax you are looking for is
```
const injectedString = &#39;containing a variable&#39;;
const templateString = `This is a string ${injectedString}`;
console.log(templateString);
//logs &quot;This is a string containing a variable&quot;;
```

**HOWEVER,**
## DO NOT DO IT THAT WAY

This leaves you open to injection attacks, e.g. a input value of `&#39;aBeerName&#39;}) DETACH DELETE bry //` for `inputthebeer` would delete several nodes


# Use parameters

## If you&#39;re using the REST API
Use `params` to pass the parameters and let Neo4j safely escape and inject them into the query. 
```
{
  &quot;query&quot; : &quot;MATCH (bry:Brewery)-[r:BREWS]-&gt;(b:Beer {name: {inputthebeer}})-[r2:IS_A]-&gt;(bt:BeerType) Return bry,r,b,r2,bt,r3,h&quot;,
  &quot;params&quot; : {
    &quot;inputthebeer&quot; : &quot;aBeerName&quot;,
  }
}
```
It&#39;s not clear how your `restPost()` works, but consult the [REST API documentation](https://neo4j.com/docs/rest-docs/current/#rest-api-use-parameters) for examples. 
The important part is that your query string should contain `{name: {inputthebeer}}` and that you should add `inputthebeer` as a parameter.


## Using the Javascript driver
A better solution is probably to use the [Neo4j Javascript Driver](https://github.com/neo4j/neo4j-javascript-driver).

Install it with `npm`
```
npm install neo4j-driver
```

or if you&#39;re not using npm or bundling your source, include it in your HTML
```html
&lt;script src=&quot;https://unpkg.com/neo4j-driver@X.Y.Z/lib/browser/neo4j-web.min.js&quot;&gt;&lt;/script&gt;
```

You&#39;ll need to initialize the driver and open a session, then
```
session
  .run(
    &#39;MATCH (bry:Brewery)-[r:BREWS]-&gt;(b:Beer {name: $inputthebeer})-[r2:IS_A]-&gt;bt:BeerType) Return bry,r,b,r2,bt,r3,h&#39;,
    {
      inputthebeer: &#39;aBeerName&#39;
    }
  )
```

The important thing to note in this example is that this is **NOT** a Javascript template literal. The value `$inputthebeer` is literally in the string, and the *driver* is passing the parameter, and Neo4j safely escapes the variable (preventing injection attacks)


# WARNING
It looks like the Neo4j REST API may be exposed publicly - if this is the case, the injection attack above may be moot, as attackers could directly execute any query by sending requests directly to the REST API

",1,66072951
2951,https://stackoverflow.com/a/66068655,Add the first row of csv as the attributes of a node type - Neo4J,true,"It would be best to choose only the few properties that are really needed &quot;in the graph&quot;, and only load those.  Generally speaking it is not best practice to replicate a relational data store table structure (with large column counts) inside Neo4j, first sketch out a new graph meta-model, then load it, this usually requires some ETL steps, and often data cleaning.  One can sketch out the meta-model on paper with a pencil, or using the [arrows tool][1], which provides a more polished diagram if needed for the documentation.

Note, I can however envision a need to dynamically handle the property list, perhaps the property list is short but always changing?  I imagine there are several ways to do it, but off the top of my head one way would be to dynamically build the cypher statement in a string and then execute it using this APOC call

[CALL apoc.cypher.run()][2]


  [1]: https://neo4j.com/labs/arrows/
  [2]: https://neo4j.com/labs/apoc/4.1/cypher-execution/running-cypher/",1,66068655
2952,https://stackoverflow.com/a/66066225,"ClientError 404, cannot connect mongodb to neo4j",false,"You should check whether the version of py2neo you are using is compatible with the version of Neo4j. I suspect it isn&#39;t, since `py2neo.packages.httpstream` is a wildly out of date package name, and probably refers too a deprecated/removed HTTP endpoint.",0,66066225
2953,https://stackoverflow.com/a/66069123,How to know if a Neo4j background job completed successfully?,false,"If there is a way to directly check error status on the fire&amp;forget routines, I don&#39;t see it in the documentation (they are fire&amp;forget, so it comes with the territory?)  

Ideas
- don&#39;t background the query itself, background a process/task that waits for a blocking Cypher execution to finish and capture the error code...
- check for success instead of failure?  (if it didn&#39;t succeed you know it failed right?), this may be evident based on what the Cypher does, or you could add a graph content update for this purpose.  E.g. Update property on a NODE with last_updated.  Do that last so that if the cypher fails, the property is not updated
- You could enable query log and then check there to see what happened, most likely this query has a unique signature and the last execution could be found easily in the log (with status/error code)
",0,66069123
2954,https://stackoverflow.com/a/66049992,What determines how node names are displayed in Neo4j?,true,"If you want to display a specific property value, you have to configure it on the browser. :

[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/aP8UP.png",0,66049992
2955,https://stackoverflow.com/a/66264291,Is there a way to migrate a neo4j database with its relationships included?,false,"As Tomaž says in the comments, your best bet here is to use the database dump utility. You can read more about making an [offline copy][1], and [restoring one][2].


  [1]: https://neo4j.com/docs/operations-manual/current/backup-restore/offline-backup/
  [2]: https://neo4j.com/docs/operations-manual/current/backup-restore/restore-dump/",0,66264291
2956,https://stackoverflow.com/a/66014760,Neo4J - How to merge nodes with the same attribute value (name) but different node labels,false,"You can collect all names in the nodes and combine them. Then UNWIND (it is like a For loop) and return distinct name.

    MATCH (a)-[r:SYN_OF]-&gt;(b) WHERE a.name = b.name AND id(a) &lt;&gt; id(b)
    WITH collect(distinct a.name) + collect(distinct b.name) as names
    UNWIND names as name
    RETURN distinct name

Result:

    ╒═══════════╕
    │&quot;name&quot;     │
    ╞═══════════╡
    │&quot;Same Name&quot;│
    └───────────┘",0,66014760
2957,https://stackoverflow.com/a/66152861,How to get the intersection after union queries,false,"After several days struggling with this problem, I was not able to solve it within the query, so I had to post-process the query results in the code of my app.

I&#39;m closing this because I think what I want to do is not possible in Cypher.",0,66152861
2958,https://stackoverflow.com/a/65999373,"Neo4j/Cypher attempting to UNWIND a list of user ids, create one Notification and relationship to all users that were matched",false,"Use Merge function instead of Create.  Merge will not create a duplicate because if it sees the same node/relationships exists, then it will skip it and not create another one. It is like a MATCH then CREATE if not found.  Meanwhile, CREATE will not check if the same node/relationshps exists or not.  

    OPTIONAL MATCH (allMentionedUsers:User)
    WHERE allMentionedUsers.id in $mentions
    UNWIND allMentionedUsers as mentionedUser
    MERGE (p)-[:HAS_NOTIFICATION]-&gt;(n:Notification {
        id: apoc.create.uuid(),
        notificationType: &#39;MENTION&#39;,
        notifierName: u.username,
        body: &#39;mentioned you&#39;,
        createdAt: datetime(),
        updatedAt: datetime()
    })-[:NOTIFIES]-&gt;(mentionedUser)",0,65999373
2959,https://stackoverflow.com/a/66014864,"Neo4j/Cypher attempting to UNWIND a list of user ids, create one Notification and relationship to all users that were matched",true,"Your UNWIND isn&#39;t actually doing anything, it&#39;s a no-op here. UNWIND works on lists, but `allMentionedUsers` isn&#39;t a list (and it would be a good idea to use singular instead of plural for the variable name. 

You could MERGE the notification first, and only afterwards create the rest of the pattern.

```
...
MERGE (n:Notification {
    id: apoc.create.uuid(),
    notificationType: &#39;MENTION&#39;,
    notifierName: u.username,
    body: &#39;mentioned you&#39;,
    createdAt: datetime(),
    updatedAt: datetime()
})
WITH u, p, n
OPTIONAL MATCH (mentionedUser:User)
WHERE mentionedUser.id in $mentions
MERGE (p)-[:HAS_NOTIFICATION]-&gt;(n)
MERGE (n)-[:NOTIFIES]-&gt;(mentionedUser)
```

Or you could collect the users into a list and do the same, which may work a bit better since the MERGE operation would happen once instead of for each row:

```
...
OPTIONAL MATCH (mentionedUser:User)
WHERE mentionedUser.id in $mentions
WITH u, p, collect(mentionedUser) as allMentionedUsers
MERGE (n:Notification {
    id: apoc.create.uuid(),
    notificationType: &#39;MENTION&#39;,
    notifierName: u.username,
    body: &#39;mentioned you&#39;,
    createdAt: datetime(),
    updatedAt: datetime()
})
MERGE (p)-[:HAS_NOTIFICATION]-&gt;(n)
FOREACH (mentionedUser IN allMentionedUsers | 
  MERGE (n)-[:NOTIFIES]-&gt;(mentionedUser) )
```

I&#39;m using a FOREACH to process the notification per mentioned user, as it will keep the cardinality down, which is important if you don&#39;t have any other operations to perform per mentioned user.

One final alternative is to keep allMentionedUsers in a list from start to end, but this requires using a list comprehension and pattern comprehension, as well as using a weird alternate pattern syntax to capture the pattern of a single node in a multi-part pattern (since Cypher doesn&#39;t seem to consider single-nodes as valid patterns for a pattern comprehension).

```
...
WITH u, p, [id in $mentions | [(user:User {id:id})-[*0]-() | user][0]] as allMentionedUsers
MERGE (n:Notification {
    id: apoc.create.uuid(),
    notificationType: &#39;MENTION&#39;,
    notifierName: u.username,
    body: &#39;mentioned you&#39;,
    createdAt: datetime(),
    updatedAt: datetime()
})
MERGE (p)-[:HAS_NOTIFICATION]-&gt;(n)
FOREACH (mentionedUser IN allMentionedUsers | 
  MERGE (n)-[:NOTIFIES]-&gt;(mentionedUser) )
```",1,66014864
2960,https://stackoverflow.com/a/66005163,Spring Data Neo4j 6 @ConvertWith implementation,true,"Solving it without the @ConvertWith by registering a GenericConverter does work.
So you write a converter for the actual MyCustomClass, to neo4j driver StringValue, instead of writing a conversion for the whole list( List&lt;MyCustomClass&gt;). Because neo4j can convert by itself from a List&lt;String&gt;. 
Then there is no need to write @ConvertWith above the property or anything else but what is below.

So the solution then:

    public class CustomConverter implements GenericConverter 

    {
    	@Override
    	public Object convert(final Object source, final TypeDescriptor sourceType, final TypeDescriptor targetType)
    	{
    		if (sourceType.getType().equals(StringValue.class))
    		{
    			System.out.println(&quot;reading converted&quot;);
    			return this.toEntityAttribute((StringValue) source);
    		}
    		else
    		{
    			System.out.println(&quot;writing converting&quot;);
    			return this.toGraphProperty((MyCustomClass) source);
    		}
    	}
    
    	@Override
    	public Set&lt;ConvertiblePair&gt; getConvertibleTypes()
    	{
    		Set&lt;ConvertiblePair&gt; convertiblePairs = new HashSet&lt;&gt;();
    		convertiblePairs.add(new ConvertiblePair(MyCustomClass.class, Value.class));
    		convertiblePairs.add(new ConvertiblePair(Value.class, MyCustomClass.class));
    		return convertiblePairs;
    	}
    
    	private MyCustomClass toEntityAttribute(final StringValue value)
    	{
    		MyCustomClass result = null;
    		try
    		{
    			result = AbstractJsonConverter.createObjectFromJson(value.asString(), MyCustomClass.class);
    		}
    		catch (IOException e)
    		{
    			CustomConverter.log.warn(e.getMessage(), e);
    		}
    		System.out.println(&quot;reading result:&quot; + result);
    		return result;
    	}
    
    	private Value toGraphProperty(final MyCustomClass value)
    	{
    		String result = null;
    		try
    		{
    			result = AbstractJsonConverter.createJsonFromObject(value);
    		}
    		catch (RepresenationCreationException e)
    		{
    			CustomConverter.log.warn(e.getMessage(), e);
    		}
    		return Values.value(result);
    	}
    }

And then you have to register the converter by defining a bean.

    @Bean
    public Neo4jConversions neo4jConversions()
    {
    	Set&lt;GenericConverter&gt; additionalConverters = Collections.singleton(new CustomConverter());
    	return new Neo4jConversions(additionalConverters);
    }

",0,66005163
2961,https://stackoverflow.com/a/66004266,Neo4J merge/union tables returned from same query but different nodes,false,"The UNION error is because the columns do not match- changing it to 

```
MATCH (g:Gene {name: &quot;G1&quot;})-[r]-(n)
RETURN DISTINCT type(r) as type,  count(r) as count
UNION ALL 
MATCH (g:Gene {name: &quot;G2&quot;})-[r]-(n)
RETURN DISTINCT type(r) as type ,  count(r) as count
```

will work. ",0,66004266
2962,https://stackoverflow.com/a/66019092,Neo4J merge/union tables returned from same query but different nodes,false,"You can use [UNWIND][1]. and you need to return the node (g in here).

    UNWIND [&quot;G1&quot;, &quot;G2&quot;] AS name
    MATCH (g:Gene {name: name})-[r]-(n) 
    RETURN g , DISTINCT type(r) as type,  count(r) as count

  [1]: https://neo4j.com/docs/cypher-manual/current/clauses/unwind/",0,66019092
2963,https://stackoverflow.com/a/65999498,"Simplifying cypher, match all nodes and relationships between two node types",false,"
You can use a variable length relationship in your query. *6 means you can get the nodes from Kingdom up to max of six hops (or relationships) until you reach Species. Then from this path, return all nodes that you found.

    MATCH p=(:Kingdom)-[:RELTYPE*6]-(:Species)
    RETURN nodes(p)",2,65999498
2964,https://stackoverflow.com/a/66039164,"Simplifying cypher, match all nodes and relationships between two node types",true,"No need to specify the relationship types, but it is good practice to set an upper limit (even if it&#39;s a high one). For example:

```
MATCH p=(:Kingdom)-[*..15]-&gt;(:Species)
RETURN nodes(p)
```",1,66039164
2965,https://stackoverflow.com/a/65985242,Need to display single post of a user on each page Neo4j Cypher,false,"You could do:

     MATCH (p:Posts)-[:CREATED_BY]-&gt;(u:User)
     WHERE p.CreatedDateTime &gt;= datetime(&#39;2021-01-31&#39;) 
     WITH p, u
     ORDER BY datetime(p.CreatedDateTime) DESC
     WITH u, collect(p)[$page] as post
     WHERE NOT post is null
     RETURN u, post

that gives you for always incrementing page numbers always the latest post
With apoc you could use instead apoc.agg.nth(p, $page)
",1,65985242
2966,https://stackoverflow.com/a/65980221,Shortest Path between nodes of some specific type and destination node,false,"I think i&#39;ve found a solution using the sanningTree procedure.

This works pretty fast! I do not understand why. **And** how to include link properties to minimize on fysical properties instead of number of hops.

    // first match to and collect end nodes
    MATCH (m:Asset {type:&#39;central production unit&#39;})
    WITH collect(m) as endNodes
    MATCH (n:Asset {id:&#39;1234&#39;})
    // proc call will be executed per n node, finding the first shortest path found from n to one of the end nodes
    CALL apoc.path.spanningTree(n, {endNodes:endNodes, limit:1}) YIELD path
    RETURN path",0,65980221
2967,https://stackoverflow.com/a/65999836,Which elements from networkx graph might become labels at neo4j graph?,true,"I made some reserch and finally I have got a process to be able to export a networkx graph into a neo4j graph managing the labels. 
Some details have to be considered:

1.- **When creating the nodes**: the **property** to become a label at neo4j must be **named as *labels*** (notice that it is in plural, do not ask why, it works). Its value must be a string starting with &#39;:&#39;

    G.add_nodes_from([(1,{&#39;labels&#39;:&#39;:NUMBER&#39;, &#39;color&#39;:&#39;blue&#39;}), (&#39;A&#39;,{&#39;labels&#39;:&#39;:LETTER&#39;, &#39;state&#39;:&#39;done&#39;})])

2.- **When creating the edges**: the **property** to become a label at neo4j must be **named as *label*** (now it is in singular!!). Its value must be a string starting with &#39;:&#39;

    G.add_edges_from([(1,&#39;A&#39;,&#39;dir&#39;,{&#39;label&#39;:&#39;IMPACTS&#39;, &#39;when&#39;:&#39;old&#39;})])

3.- **For MultiDiGraph** the k value is not going to be imported. My workarround is to **duplicate *k* as an edge property** called, for exampel *id*.

    for u,v,k in G.edges(keys=True):
    G[u][v][k][&#39;id&#39;]=k

4.- Export networkx graph to **graphml** using **named_key_ids=True**

    nx.write_graphml(G, &#39;test.graphml&#39;, named_key_ids=True)

5.- Import to neo4j with parameteres *readLabels: true* and *storeNodeIds:true*. At neo4j browser you might have:

    CALL apoc.import.graphml(&quot;test.graphml&quot;, {readLabels: true, storeNodeIds:true})

Here I include a graph created in networkx that can be imported to neo4j as described:

    import networkx as nx
    
    G=nx.MultiDiGraph()

    #creation of nodes with property called &#39;labels&#39;
    G.add_nodes_from([
        (1,{&#39;labels&#39;:&#39;:NUMBER&#39;, &#39;color&#39;:&#39;blue&#39;}),
        (2,{&#39;labels&#39;:&#39;:NUMBER&#39;, &#39;color&#39;:&#39;yellow&#39;}),
        (&#39;A&#39;,{&#39;labels&#39;:&#39;:LETTER&#39;, &#39;state&#39;:&#39;done&#39;}),
        (&#39;B&#39;,{&#39;labels&#39;:&#39;:LETTER&#39;, &#39;state&#39;:&#39;pending&#39;})
        ])
    #creation of edges with property called &#39;label&#39;
    G.add_edges_from([
        (1,&#39;A&#39;,&#39;dir&#39;,{&#39;label&#39;:&#39;IMPACTS&#39;, &#39;when&#39;:&#39;old&#39;}),
        (1,&#39;A&#39;,&#39;n_dir&#39;,{&#39;label&#39;:&#39;IMPACTS&#39;, &#39;when&#39;:&#39;new&#39;}),
        (1,&#39;B&#39;,&#39;n_dir&#39;,{&#39;label&#39;:&#39;ALTS&#39;, &#39;when&#39;:&#39;future&#39;}),
        (2,&#39;B&#39;,&#39;dir&#39;,{&#39;label&#39;:&#39;IMPACTS&#39;, &#39;when&#39;:&#39;new&#39;}),
        (2,&#39;B&#39;,&#39;n_dir&#39;,{&#39;label&#39;:&#39;IMPACTS&#39;, &#39;when&#39;:&#39;old&#39;}),
        (2,&#39;A&#39;,&#39;n_dir&#39;,{&#39;label&#39;:&#39;ALTS&#39;, &#39;when&#39;:&#39;new&#39;}),
        ])
    #k is duplicated at every node as a property
    for u,v,k in G.edges(keys=True):
        G[u][v][k][&#39;id&#39;]=k
    
    nx.write_graphml(G, &#39;test.graphml&#39;, named_key_ids=True)

What is pending? To figure out how to assing to a node or an edge more than one label. Any help will be welcome",2,65999836
2968,https://stackoverflow.com/a/65968548,Configuration of embedded Neo4j to run APOC procedures,true,"Probably the way the path to the plugin directory was created. There&#39;s an example from Michael Simons here that explains using the neo4j classloader: https://github.com/michael-simons/neo4j-examples-and-tips/blob/master/examples/testing-ogm-against-embedded-with-apoc/src/test/java/org/neo4j/tips/testing/testing_ogm_against_embedded_with_apoc/ApplicationTests.java#L53
",2,65968548
2969,https://stackoverflow.com/a/65992879,Returning neo4j results to a C# object,true,"I think the problem is your:

```
Results = mycollection.As&lt;IEnumerable&lt;Neo4jResult&gt;&gt;(),
```

Bit. What you&#39;re actually wanting is a `COLLECT` so something like:

```
Results = mycollection.CollectAs&lt;Neo4jResult&gt;()
```

`mycollection` isn&#39;t _actually_ an `IEnumerable` - and you can see it if you run the query in the browser - you don&#39;t put it here, so this is a &#39;rough&#39; version.

If you executed:

```
MATCH (m:Movie)
RETURN m.title, count(m)
```

You&#39;ll get:

```
Title1, 1
Title2, 1
Title3, 1
```

etc

If you execute:

```
MATCH (m:Movie)
RETURN COLLECT(m.title), count(m)
```

You&#39;ll get:

```
[title1, title2, title3], 3
```

for example.",1,65992879
2970,https://stackoverflow.com/a/65962391,Neo4j Condition Based Output,true,"I created below sample data as you described.  The query involves a simple case when else and I collected the documents then check if passport, votercard and pancard exists in the collection.

    (P1:Person)-[:HAS_Document]-&gt;(&quot;Passport&quot;,&quot;VoterCard&quot;,&quot;PanCard&quot;)
    (P2:Person)-[:HAS_Document]-&gt;(&quot;VoterCard&quot;,&quot;PanCard&quot;)`
    (P3:Person)-[:HAS_Document]-&gt;(&quot;PanCard&quot;,&quot;AadharCard&quot;,&quot;VoterCard&quot;)
    (P4:Person)-[:HAS_Document]-&gt;(&quot;PanCard&quot;)
    
    Create (p1:Person {Name: &#39;P1&#39;})
    Create (p2:Person {Name: &#39;P2&#39;})
    Create (p3:Person {Name: &#39;P3&#39;})
    Create (p4:Person {Name: &#39;P4&#39;})
    Create (d1:Document {Doc_Type: &#39;Passport&#39;})
    Create (d2:Document {Doc_Type: &#39;VoterCard&#39;})
    Create (d3:Document {Doc_Type: &#39;PanCard&#39;})
    Create (d4:Document {Doc_Type: &#39;AadharCard&#39;})
    Merge (p1)-[:HAS_DOCUMENT]-(d1)
    Merge (p1)-[:HAS_DOCUMENT]-(d2)
    Merge (p1)-[:HAS_DOCUMENT]-(d3)
    Merge (p2)-[:HAS_DOCUMENT]-(d2)
    Merge (p2)-[:HAS_DOCUMENT]-(d3)
    Merge (p3)-[:HAS_DOCUMENT]-(d3)
    Merge (p3)-[:HAS_DOCUMENT]-(d4)
    Merge (p3)-[:HAS_DOCUMENT]-(d2)
    Merge (p4)-[:HAS_DOCUMENT]-(d3)

    Query:
        MATCH (p: Person)-[: HAS_DOCUMENT]-(d:Document) 
        WHERE d.Doc_Type in [&quot;Passport&quot;, &quot;VoterCard&quot;, &quot;PanCard&quot;]
        WITH p.Name as Name, collect(d.Doc_Type) as docType
        RETURN Name, 
        CASE WHEN &#39;Passport&#39; in docType THEN &#39;Passport&#39;
         WHEN &#39;VoterCard&#39; in docType THEN &#39;VoterCard&#39;
         WHEN  &#39;PanCard&#39; in docType THEN &#39;PanCard&#39; 
        ELSE NULL END as DocType
        ORDER BY Name

    Result:
    ╒══════╤═══════════╕
    │&quot;Name&quot;│&quot;DocType&quot;  │
    ╞══════╪═══════════╡
    │&quot;P1&quot;  │&quot;Passport&quot; │
    ├──────┼───────────┤
    │&quot;P2&quot;  │&quot;VoterCard&quot;│
    ├──────┼───────────┤
    │&quot;P3&quot;  │&quot;VoterCard&quot;│
    ├──────┼───────────┤
    │&quot;P4&quot;  │&quot;PanCard&quot;  │
    └──────┴───────────┘",0,65962391
2971,https://stackoverflow.com/a/65959709,Cypher relating many nodes to one node,true,"I think what you need is a simple IN clause,
https://neo4j.com/docs/cypher-manual/current/clauses/where/#where-in-operator

    MATCH (a:Object),(b:Person)
    WHERE a.name IN [&#39;5ffdbb309d9a6&#39;, &#39;5ffd73259ad18&#39; ...] AND b.name = &#39;David&#39;
    CREATE (a)-[r:CREATEDBY]-&gt;(b);

or am i missing something?",1,65959709
2972,https://stackoverflow.com/a/65968831,Performance with pagination,false,"Without the ORDER BY, cypher can lazily evaluate the tenants and stop at 10 rather than matching every tenant in City1. However, because you need to order the tenants, the only way it can do that is to fetch them all and then sort. 

If the only labels that can live in apartments is Tenants then you could possibly save a Filter step by removing the `Tenant` in your query like `MATCH (t)-[:lives_in]-&gt;(:Apartment)...`.

You might want to check the profile of your query as well and see if it uses the [index backed order by][1] 

What sort of numbers are you expecting back from this query? What&#39;s the worst case number of tenants in a given city?

**EDIT**

I was hoping a USING JOIN on t would use the index to improve the plan but it does not. 
The query performs slightly better if you add a redundant relation from the tenant to the city:

```
MATCH (t:Tenant)-[:CITY]-&gt;(:City {name: &#39;City1&#39;})
RETURN t
ORDER BY t.id 
LIMIT 10
```

and similarly by embedding the city name onto the tenant- no major gains. I tested for 150,000 tenants in City1, perhaps the gains are more visible as you approach millions, but not sure. 

  [1]: https://neo4j.com/docs/cypher-manual/4.2/query-tuning/advanced-example/#advanced-query-tuning-example-index-backed-order-by",1,65968831
2973,https://stackoverflow.com/a/65961929,Query optimization that collects and orders nodes on very large graph,false,"Initial thoughts
 - you are using a string field to store PMID, but PMIDs are numeric, it might reduce the database size, and possibly perform better if stored as int (and indexed as int, and searched as int)
 - if the PMID list is usually large, and the server has over half dozen cores, it might be worth looking into the apoc parallel cypher functions
 - do you really need every property from the Mention nodes? if not try gathering just what you need
 - what is the size of the database in GBs? (some context is required in terms of memory settings), and what did neo4j-admin memrec recommend?
 - If this is how the db is always used, all the time, a sql database might be better, and when building that sql db, collect the mentions into one field (once and done)

Note: Go PubMed!",1,65961929
2974,https://stackoverflow.com/a/65968992,Neo4J: How to correctly match key-value-pairs in Cypher query,false,"[UNWIND][1] is one way to do it. 
I used browser params to demo the concept to you:

`:param carspeeds =&gt; ({cars:[{ id:1, speed:10},{ id:2, speed:20}]})`

```
UNWIND $carspeeds.cars AS carspeed
MATCH (c:Car {id:carspeed.id})
SET c.maxSpeed=carspeed.speed
```


  [1]: https://neo4j.com/docs/cypher-manual/4.2/clauses/unwind/#unwind-creating-nodes-from-a-list-parameter",0,65968992
2975,https://stackoverflow.com/a/65974922,Issue with Neo4j GDS 1.4.1 K-Spanning tree,false,"O.K., get the key that the Prim algorithm only applies to UNDIRECTED graph, should be mentioned in [the algorithm document][1].
Read the source of Prim algorithm at https://github.com/neo4j/graph-data-science/blob/master/alpha/alpha-algo/src/main/java/org/neo4j/graphalgo/impl/spanningTrees/Prim.java .


  [1]: https://neo4j.com/docs/graph-data-science/current/alpha-algorithms/minimum-weight-spanning-tree/#alpha-algorithms-minimum-weight-spanning-tree",0,65974922
2976,https://stackoverflow.com/a/65941951,Spring data neo4j SDN 6,false,"I&#39;m facing the exact same issue. Apparently, there is no workaround that I&#39;ve found so far. The query keeps running and eventually fails with Outofmemory error.

The issue happens because of the self reference. This appears to be a defect since the self-reference nodes appear to be the ideal use case for graphs whereas they break while trying to find the nodes. Here is my query that is generated by SDN: 

    MATCH (n:Part) WHERE n.sku = &quot;SKU000009&quot;  WITH n, id(n) AS __internalNeo4jId__ RETURN n{.allowCustomerReviews, __nodeLabels__: labels(n), __internalNeo4jId__: id(n), __paths__: [p = (n)-[:SOLD_BY|GROUPED_WITH|PART_OF|FITS_INTO]-&gt;()-[:SOLD_BY|GROUPED_WITH|PART_OF|FITS_INTO|MANUFACTURED_BY*0..]-()-[:MANUFACTURED_BY*0..1]-&gt;()-[*0..]-() | p]}",0,65941951
2977,https://stackoverflow.com/a/65944017,nodejs javascript promise resolve,false,"It finally clicked with me. Here is the solution I came up with. Hopefully it will help others. If there is a better way please let me know. Thank you @fbiville for you help.

*async actions*
``` javascript
const neo4j = require(&#39;neo4j-driver&#39;)
var parser = require(&#39;parse-neo4j&#39;)
const astria_queries = require(&#39;./astriaQueries&#39;)

const uri = &#39;bolt://astria_graph:7687&#39;
const user = &#39;neo4j&#39;
const password = &#39;neo&#39;

async function getRecords(query) {
  //   run statement in a transaction
  const driver = neo4j.driver(uri, neo4j.auth.basic(user, password))
  const session = driver.session({ defaultAccessMode: neo4j.session.READ })
  const tx = session.beginTransaction()
  try {
    const records = await tx.run(query)
    const parseRecords = await parseQuery(records)
    return parseRecords
  } catch (error) {
    console.log(error)
  } finally {
    session.close()
    driver.close()
  }
}

async function parseQuery(result) {
  try {
    const parsedRes = await parser.parse(result)
    // console.log(parsedRes)
    return parsedRes
  } catch (err) {
    console.log(err)
  }
}

// getRecords(astria_queries.get_data_sources)

module.exports = {
  getRecords,
}
```
*api send()*
``` javascript
exports.get_data_sources = async (req, res) =&gt; {
  try {
    queryFuns.getRecords(astria_queries.get_data_sources).then((response) =&gt; {
      res.send(response)
    })
  } catch (error) {
    res.status(500).send(error)
    console.log(error)
  }
}
```",1,65944017
2978,https://stackoverflow.com/a/65939661,Subqueries in neo4j 3.5 (for Pagination),true,"Something like this?

```
CALL apoc.cypher.run(&quot;MATCH (x:Type1) return count(*) as total&quot;, {})
YIELD value AS total
WITH total
MATCH (o:Brand)
WITH total, o
ORDER BY o.name SKIP 5 LIMIT 5
WITH total, collect({uuid:o.uuid, name:o.name}) AS brands
RETURN {total:total, brands:brands}
```

",1,65939661
2979,https://stackoverflow.com/a/65929897,Neo4j match using a list,true,"You can use `IN` to check if a value is present in the array/list.

    MATCH (n:a) 
    WHERE 1 IN n.listNumb  
    RETURN n;",0,65929897
2980,https://stackoverflow.com/a/65931296,Creating a relationship between all nodes with a set property with Cypher,true,"Sure, you can do:

    MATCH (a:Animal)
    WHERE a.class IN [&quot;mammal&quot;,&quot;reptile&quot;]
    SET a.limbs=4

To query all animals with 4 limbs:

    MATCH (a:Animal {limbs:4}) 
    RETURN a",0,65931296
2981,https://stackoverflow.com/a/65926768,is it possible to use jqassistant output with graphlytic?,true,"As it turns out after reading jqassistant docs (duh), it is possible to run separate neo4j database with simple 
`mvn jqassistant:server`
running on default ports, which graphlytic can freely access. 
That is actually much better choice.",2,65926768
2982,https://stackoverflow.com/a/65926993,Unexpected relation and node COUNT in Neo4j,false,"The short answer is that you need to use a collect statement to make it work. 

```
MATCH (p)&lt;-[rel]-(v:myDistinctNode) WITH collect(v) AS nodes RETURN count(nodes)
```

This should return one. 
I&#39;m not a cypher expert, but I believe the reason it doesn&#39;t work is that the cypher result seems more like a table where in one row you have p, another row you have r, and the last row you have v. Even though v is a unique entity, there are still 80 rows that have v.",1,65926993
2983,https://stackoverflow.com/a/65924177,Neo4j not starting on Raspberry Pi (memory issues and java.lang.NoClassDefFoundError),true,"After some more trying it seems like it is a problem with the latest Neo4j version (4.2.3).
I now installed version 4.0.11 and it works without any problems.",0,65924177
2984,https://stackoverflow.com/a/65908227,Neo4j Cypher: Filtering a query results based on another query,true,"You can have another ``WITH`` and ``UNWIND``.


    Match (m:class)-[r]-(n:student) where n.name in [&#39;aa&#39;,&#39;bb&#39;,&#39;cc&#39;]    
    WITH COLLECT(m) AS EXCLUDED
    MATCH  (m1:class)-[r1]-(n1:student) where n1.name in [&#39;dd&#39;,&#39;ee&#39;] 
    WITH EXCLUDED, COLLECT(m1) AS included
    WITH FILTER(m1 IN included WHERE NOT m1 IN EXCLUDED) as _results
    UNWIND _results as results
    RETURN results.name

**Note:** ``FILTER()`` is deprecated in neo4j 3.5 and removed in 4.0 in favor of [List Comprehension](https://neo4j.com/docs/cypher-manual/current/syntax/lists/#cypher-list-comprehension)
",0,65908227
2985,https://stackoverflow.com/a/65923310,Neo4j Create node if no relationship exists,false,"I strongly recommend changing your DB schema. If all the nodes are having identical properties, I don&#39;t know how are you planning to perform ``MATCH`` later on. All nodes might be identical to user but neo4j has a ``&lt;id&gt;`` field, which is unique to each entity (node and relationship). 

Anyways coming to the problem, As far as I understand you need to check if a particular node is already connected to another particular node. Since you didn&#39;t give the entities properties I assume some properties here.

**DB elements**

    (:Position {position: prev_move})-[:Move {move: next_move}]-&gt;(:Position {position: next_move})

**Cypher Query**

    MATCH (n: Position {position: prev_move})
    OPTIONAL MATCH (n)-[rel:Move {move: next_move}]-&gt;(:Position {position: next_move))
    CALL apoc.do.when(rel is NULL, 
      &quot;CREATE (next: Position {position : next_move}) CREATE (n)-[:Move {move: next_move}]-&gt;(next) RETURN next&quot;, 
      &quot;&quot;, {n:n})
    YEILD value
    RETURN n

**EDIT** 

You might need a different ``MATCH``ing condition to get the exact node you are looking for. ``MATCH (n: Position {position: prev_move})`` will yield in multiple nodes. Please fell free to update the matching condition, rest remains same. 


",0,65923310
2986,https://stackoverflow.com/a/65905864,"How to return a specific string instead of (no changes, no records) in Cypher query",false,"You can do ``OPTIONAL MATCH``, it returns ``NULL`` when there are no nodes matching the condition. 

    OPTIONAL MATCH (n:device) 
    WHERE n.nid = &#39;non-existing&#39;
    RETURN DISTINCT CASE n WHEN NULL THEN &#39;Failure&#39; ELSE &#39;Success&#39; END",0,65905864
2987,https://stackoverflow.com/a/65903393,Can Apache Tinkerpop&#39;s Neo4jGraph.open() open a database from the file system?,true,"I would expect `Neo4jGraph.open(path)` to open an existing graph if present at that path or create a new one if it does not find one. I would not expect it to overwrite. I assume that you are not committing your transaction in your unit test prior to closing your graph:

    gremlin&gt; graph = Neo4jGraph.open(&#39;/tmp/neo4j&#39;)
    ==&gt;neo4jgraph[community single [/tmp/neo4j]]
    gremlin&gt; g = graph.traversal()
    ==&gt;graphtraversalsource[neo4jgraph[community single [/tmp/neo4j]], standard]
    gremlin&gt; g.addV(&#39;person&#39;).property(&#39;name&#39;,&#39;marko&#39;)
    ==&gt;v[0]
    gremlin&gt; graph.close()
    ==&gt;null
    gremlin&gt; graph = Neo4jGraph.open(&#39;/tmp/neo4j&#39;)
    ==&gt;neo4jgraph[community single [/tmp/neo4j]]
    gremlin&gt; g = graph.traversal()
    ==&gt;graphtraversalsource[neo4jgraph[community single [/tmp/neo4j]], standard]
    gremlin&gt; g.V()
    gremlin&gt; g.addV(&#39;person&#39;).property(&#39;name&#39;,&#39;marko&#39;)
    ==&gt;v[0]
    gremlin&gt; g.tx().commit()
    ==&gt;null
    gremlin&gt; graph.close()
    ==&gt;null
    gremlin&gt; graph = Neo4jGraph.open(&#39;/tmp/neo4j&#39;)
    ==&gt;neo4jgraph[community single [/tmp/neo4j]]
    gremlin&gt; g = graph.traversal()
    ==&gt;graphtraversalsource[neo4jgraph[community single [/tmp/neo4j]], standard]
    gremlin&gt; g.V()
    ==&gt;v[0]

As you can see, if I `close()` without `g.tx().commit()` and then re-open the graph the vertex I added is not present. However, with a call to `commit()` I can re-open and get my vertex. ",0,65903393
2988,https://stackoverflow.com/a/65903405,What are Base nodes?,false,"You can create nodes with multiple labels in the graph database. I am not familiar with the bloodhound but it might be adding an extra label to nodes called ``&quot;Base&quot;`` to distinguish its data from the existing ones **or** There might be a good chance that there are several higher categories under which lower categories fall e.g., ``&quot;User&quot;``, ``&quot;Group&quot;``, ``&quot;Computer&quot;``... fall under ``&quot;Base&quot;``. By doing ``MATCH (n:Base)....`` you are matching all the nodes under ``&quot;Base&quot;`` category.",0,65903405
2989,https://stackoverflow.com/a/65912038,What are Base nodes?,false,"The Base label, as previously suggested, has nothing to do with Neo internals.

While the documentation for the tool does not address the base label, the source code provides some hints. I recommend looking at these:
- https://github.com/BloodHoundAD/BloodHound/blob/08a3469c523b4066e8e5248bdbcfb985acab5117/src/js/newingestion.js
- https://github.com/BloodHoundAD/BloodHound/blob/08a3469c523b4066e8e5248bdbcfb985acab5117/src/js/newingestion.js
- https://github.com/BloodHoundAD/BloodHound/blob/67cf1dee4f6c8d77a71b3eceb49b4040a5eb9550/src/components/Graph.jsx

Base appears to be a convenience grouping. It is common to have multiple labels for any node. For example, you can have UserAccount nodes (~Base) that have also other labels that define the role of any specific UserAccount.
",0,65912038
2990,https://stackoverflow.com/a/65904961,How to auto update node attributes in ne04j after a specific time period,false,"You can use ``apoc`` procedure calls for scheduling background jobs. ``apoc.periodic.schedule()`` makes sense in your case.

    CALL apoc.periodic.schedule(&#39;offerValidater&#39;, 
    &quot;MATCH (n: Offer) WHERE apoc.date.currentTimestamp() - n.CREATED_ON &gt; 604800000 SET n.IS_VALID = &#39;No&#39;&quot;, 
    86400)

Here I assumed that ``offer.CREATED_ON`` is in epoch milliseconds. If you are using other format timestamps you need to do a comparison accordingly. ``offerValidater`` routine is scheduled to run with a delay of 86400 seconds (1 day). ",1,65904961
2991,https://stackoverflow.com/a/65906712,"How to return a Neo4j schema with relationship names, from node names and to node names in one table?",false,"The one you&#39;re after is [apoc.meta.data][1]. 


  [1]: https://neo4j.com/labs/apoc/4.1/overview/apoc.meta/apoc.meta.data/",1,65906712
2992,https://stackoverflow.com/a/65904221,neo4j - get attribute value from multiple related objects into one return row,true,"MATCH (n) WHERE n.Type IN [&#39;x&#39;, &#39;y&#39;] 
WITH n OPTIONAL MATCH (f)-[:PART_OF]-&gt;(n) 
WITH n, COLLECT({ftype: f.Type, fsubtype:f.SubType, flocalipaddr: f.LocalIpAddr, fip: f.IP, fremotetunnelendpoint: f.RemoteTunnelEndpoint, fpeername: f.PEERNAME}) AS fcp 
WITH n, fcp, [x IN fcp WHERE x.ftype = &#39;IKEP&#39; AND  x.fsubtype = &#39;Security Gateway&#39; and n.SubType = &#39;eNodeB&#39;| x.fpeername]  AS fpeername, 
[x IN fcp WHERE x.ftype = &#39;DEVIP&#39; AND  x.fsubtype = &#39;SYNC&#39; and n.SubType = &#39;eNodeB&#39;| x.fip]  AS fip 
RETURN &#39;Base Station&#39; AS OptType, n.SubType, fpeername[0], fip[0]",0,65904221
2993,https://stackoverflow.com/a/65888302,Remove automorphisms of a cypher query output,false,"In the query you are making, ``(a)-[r:X]-(b)`` and ``(a)-[t:X]-(c)`` refer to a similar pattern. Since (b) and (c) can be interchanged. What is the need to repeat matching twice? ``MATCH (a)-[r:X]-(b) RETURN a, r, b`` returns all the subgraphs you are looking for.

**EDIT**

You can do something as follows to find the nodes, which are having two relations of type ``X``.

    MATCH (a)-[r:X]-(b) WHERE size((a)-[:X]-()) = 2 RETURN a, r, b",1,65888302
2994,https://stackoverflow.com/a/66037540,Remove automorphisms of a cypher query output,false,"For these kind of mirrored patterns, we can add a restriction on the internal graph ids so only one of the two paths is kept:

    MATCH (a)-[:X]-(b)-[:X]-(c)
    WHERE id(a) &lt; id(c)
    RETURN a, b, c

This will also prevent the case where `a = c`.",0,66037540
2995,https://stackoverflow.com/a/65925254,neo4j - pagination return same results even when skip and order by are specified,true,"Neo4j doesn&#39;t have fallback when the `order by` is facing 2 or more nodes with the same value. I tried to `order by` the `title` `Timer` and there is several of `Shops` with this `title`. the work around was adding the fallback to another comparison. 

`ORDER BY shops.title, shops.id`

wired that neo4j doesn&#39;t provide failsafe ( like, id of the node ), and resolving in sending the same node when skip is used. ",0,65925254
2996,https://stackoverflow.com/a/65906779,how to insert a node in a middle of a linked list in cypher,false,"All you need to do is plumb in the new node, and then remove the old relationships, something like... (I&#39;m assuming some properties here)

    MATCH (n1:Node {name:&#39;node1&#39;})-[r:NEXT]-&gt;(n2)
    CREATE (n1)-[:NEXT]-&gt;(:Node {name: &#39;new Node&#39;})-[:NEXT]-&gt;(n2)
    DELETE r

",0,65906779
2997,https://stackoverflow.com/a/65883123,How can I create in Cypher an index that involves 2 primary keys?,false,"With [Neo4j 3.x][1], the syntax is:

```
CREATE INDEX ON :ShoppingCart(productID, clientID)
```

With [Neo4j 4.x][2], the syntax is:

```
CREATE INDEX shopping_cart_index FOR (n:ShoppingCart) ON (n.productID, n.clientID)
```

Note: at the time of writing, [only Neo4j 3.5.x is supported][3] in the 3.x series.


  [1]: https://neo4j.com/docs/cypher-manual/3.5/schema/index/#schema-index-create-a-composite-index
  [2]: https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/#administration-indexes-create-a-composite-index
  [3]: https://neo4j.com/developer/kb/neo4j-supported-versions/",0,65883123
2998,https://stackoverflow.com/a/65862930,How to process each of the allShortestPaths in Neo4j?,false,"It is possible of course. The `allShortestPaths` query returns a `List` of paths that you can unwind, then for each of them you can [`reduce`][1] the properties of the relationships : 

```
MATCH paths = allShortestPaths((m)-[r*]-(n)) 
WHERE m.name = &#39;x&#39; AND n.name &lt;&gt; &#39;x&#39;
UNWIND paths AS path
WITH n.name AS name, 
reduce(total = 0, rel IN relationships(path) | total + rel.y) AS total
RETURN name, min(total)
```


  [1]: https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-reduce",0,65862930
2999,https://stackoverflow.com/a/65852155,apoc.merge.node with special identifier fails,true,"
**EDIT**

It seems there is a bug in APOC which causes the identifier to be encoded twice.

First with `Util::quote` https://github.com/neo4j-contrib/neo4j-apoc-procedures/blob/4.1/core/src/main/java/apoc/util/Util.java#L674

And then in the merge procedure https://github.com/neo4j-contrib/neo4j-apoc-procedures/blob/4.1/core/src/main/java/apoc/merge/Merge.java#L85


I&#39;ve filed an issue: https://github.com/neo4j-contrib/neo4j-apoc-procedures/issues/1783 


---
In Neo4j, you can use backticks **`** around a key that contain special characters : 

```
CALL apoc.merge.node([&quot;test&quot;], apoc.map.fromPairs([[&quot;`i:d`&quot;,&quot;123&quot;]])) 
YIELD node 
return node
```

Same is true everywhere in the Cypher syntax, escaping a label with a whitespace for eg : 

```
MERGE (n:`Land Vehicle` {id: &quot;land-rover-1&quot;})
```",0,65852155
3000,https://stackoverflow.com/a/65852298,Dynamic property keys used in Cypher Query to manipulate properties (regardless of the property values),false,"Indeed, this is one of the use cases for using the APOC library in Neo4j, to circumvent the limitations of Cypher where variables cannot be used : labels, relationship types, property keys.

The [`apoc.create.removeProperties`][1] procedure will help you with that : 

```
WITH distinct n, collect(k) as list
CALL apoc.create.removeProperties([n], list)
YIELD node
return node{.*}
```


  [1]: https://neo4j.com/labs/apoc/4.1/overview/apoc.create/apoc.create.removeProperties/#usage-apoc.create.removeProperties",1,65852298
3001,https://stackoverflow.com/a/65846470,"Problem with WHERE in Neo4J, deserialization error",true,"With these things, it&#39;s always good to check _what_ you are generating from the client. To that end you should look at the `query.DebugQueryText` property. If you do, you&#39;ll see the query you would generate would look like this:

```
MATCH (a:User{Username: &#39;NN&#39;})-[:INTERESTED_IN]-&gt;(res:Category)&lt;-[:TAG]-(b:Document)
WHERE NOT(b.isArchived AND c.isArchived AND b.CreatedBy =~ &#39;NN&#39;)
WITH b.name AS name, b.CreatedBy AS creator, b.Pictures AS pictures, b.Paragraphs AS paragraphs, COUNT(res) AS interest1
RETURN name AS Name, creator AS Creator, pictures AS Pictures, paragraphs AS Paragraphs, interest1 AS Interest
ORDER BY interest1 DESC
LIMIT 10
```

If you try to execute that in your browser - it won&#39;t work, and that&#39;s because you use an alias `c` to access the `isArchived` property, but there is no `c` in your `MATCH`.

",1,65846470
3002,https://stackoverflow.com/a/66044916,What certificate to use along with neo4j@code-signer,true,"Maybe this is going to help somebody: 
There wasn&#39;t any issue with my certificates.

I got an answer from neo4j offical, that they are (at the time being) signing apps internaly, and that there is no automated way to do this (yet).",0,66044916
3003,https://stackoverflow.com/a/65843874,neo4j-go-driver force to abort long running query,true,"I believe it should terminate it.
The code should look something like this (replace `ReadTransaction` by `WriteTransaction` depending on the query):

```go
query := &quot;MATCH (n) RETURN n&quot;
timeout := 30 * time.Second
result, err := session.ReadTransaction(func(tx neo4j.Transaction) (interface{}, error) {
	result, err := tx.Run(query, map[string]interface{}{})
	// do something interesting
}, neo4j.WithTxTimeout(timeout))
```",1,65843874
3004,https://stackoverflow.com/a/65857507,neo4j-go-driver force to abort long running query,false,"You can set transaction timeout from the server as well to some value, by default it is disabled:

     neo4j&gt; CALL dbms.setConfigValue(&#39;dbms.transaction.timeout&#39;, &#39;360s&#39;) ;",1,65857507
3005,https://stackoverflow.com/a/65826012,how to gather the unique related rows in a neo4j cypher query?,false,"In your query you are effectively doing the following:

 - Match all posts
 - Match all comments that have a COMMENTED_ON relationship
 - MATCH all nodes that have a MADE_A_POST relationship
 - MATCH all nodes that have POSTED_COMMENT relationship

As I don&#39;t have sight of your data model, I can only guess, but it looks like you&#39;re making no direct connection between posts with comments, and then finding the authors of those.

Taking a guess, I think your query should look like the following:

    MATCH (p:Posts)
    WITH p
    MATCH (n)-[:POSTED_COMMENT]-(c:Comments)-[r:COMMENTED_ON]-(p)
    MATCH (u)-[:MADE_A_POST]-&gt;(p)
    RETURN {post:p,comments:c,author:u,commentator:n}",0,65826012
3006,https://stackoverflow.com/a/65834942,How to do element wise addition on two list using Cypher on Neo4J,false,"Maybe it is not the most performant approach, but this query will do the trick.

    MATCH (n:Note)
    WITH n, size(n.embedding) as length
    WITH length, collect(n.embedding) as embeddings, count(*) as count
    UNWIND range(0,count - 1) as i
    UNWIND range(0, length -1) as j
    WITH j,apoc.coll.sum(collect(embeddings[i][j])) as sums
    RETURN [x in collect(sums) | toInteger(x)] as result",0,65834942
3007,https://stackoverflow.com/a/65834672,"Cypher MATCH, WHERE, REMOVE and WITH in right order for two separate relationships",false,"You can just add a `WITH` clause between `REMOVE` and `MATCH` as the error statement says:


    MATCH (user:USER) -[:HAS_FIRST_ADDRESS]-&gt; (address:ADDRESS:TTL) WHERE ID(user) = 3
    WITH address REMOVE address.ttl REMOVE address:TTL
    WITH address
    MATCH (user:USER) -[:HAS_ROLE]-&gt; (role:ROLE) WHERE ID(user) = 36
    RETURN {user: user, role: role, address: address}
",1,65834672
3008,https://stackoverflow.com/a/65834733,How can I query including a specific range condition?,true,"It seems your query just lack an `AND` statement between predicates:

    MATCH (u:Users)-[r:FOLLOWS]-&gt;(i:ImportantUsers) 
    WITH i, COUNT(u) as followers WHERE followers&gt;=10000 AND followers&lt;=50000 
    RETURN i.Name, followers ORDER BY followers DESC

Although a more optimized version of this query is:

    MATCH (i:ImportantUsers)
    WITH i, size((i)&lt;-[:FOLLOWS]-()) as followers 
    WHERE followers &gt;= 10000 AND
          followers &lt;= 50000
    RETURN i.Name, followers ORDER BY followers DESC",0,65834733
3009,https://stackoverflow.com/a/65905326,Neo4j Collaborative Filtering (CF) recommendation query using Pearson,false,"So the formula for Pearson is described here: https://en.wikipedia.org/wiki/Pearson_correlation_coefficient#For_a_sample

nom is simply the numerator of that formula, defined here:
&quot;WITH sum( (r.r1.rating-u1_mean) * (r.r2.rating-u2_mean) ) AS nom,&quot;

Likewise, denom is the denominator.

I&#39;m less clear on the other two questions, but hopefully this helps!",0,65905326
3010,https://stackoverflow.com/a/65849703,Neo4j cypher query perfomance,false,"Have you tried subqueries?  If you can use a subquery to shrink down the number of nodes before passing it along to subsequent queries.  (It would seem that an omniscient Query Planner could do this, but Cypher isn&#39;t there yet.). You may have to experiment with which subquery would filter out the most Nodes.

An example of using a subquery is here:
https://community.neo4j.com/t/slow-query-with-very-limited-data-and-boolean-false/31555

Another one is here:
https://community.neo4j.com/t/why-is-this-geospatial-search-so-slow/31952/24

(Of course, I assume you already have the appropriate properties indexed.)",0,65849703
3011,https://stackoverflow.com/a/65932583,Neo4j cypher query perfomance,true,"We can leverage [index-backed ordering](https://neo4j.com/docs/cypher-manual/current/query-tuning/advanced-example/#advanced-query-tuning-example-index-backed-order-by) to try a different approach here. By providing a type hint (something to indicate the property value is a string) along with the ordering by the indexed property, we can have the planner use the index to check :Member nodes in the order you want (by `m.createdAt DESC`) for free (meaning we don&#39;t need to check every :Member node and order them), and check each of those in the given order to find the ones that meet the desired criteria until we get the 10 you need.

From some back-and-forth on the Neo4j users slack, you mentioned that of your 100k :Member nodes, about 52k of them fit the criteria you&#39;re looking for, so this is a good indicator that we may not have to look very far down the ordered :Member nodes before finding the 10 that meet the criteria.

Here&#39;s the query:

```
MATCH (m:Member)
WHERE m.createdAt &gt; &#39;&#39;  // type hint
WITH m
ORDER BY m.createdAt DESC
MATCH (m)-[:HAS_WALLET]-&gt;(w) 
WHERE w.currentBalance &lt; 250 AND EXISTS {
	MATCH (m)-[:HAS_ORDERS]-&gt;(:Order {statusId:74})  
} 
WITH m, w
LIMIT 10
RETURN m as member, w as wallet, [(m)-[:HAS_ORDERS]-&gt;(o:Order {statusId:74}) | o] as orders
```

Note that by using an existential subquery, we just have to find one order that satisfies the condition. We wait until after the limit of 10 members is reached before using a pattern comprehension to grab all the orders for the 10 members.",1,65932583
3012,https://stackoverflow.com/a/65807968,Neo4j algo.unionFind equivalent with new Graph Data Science Library,true,The algorithm has been renamed to `gds.wcc.write` in the new GDS library.,0,65807968
3013,https://stackoverflow.com/a/65790081,"Use CREATE, SET and add a relationship in Cypher",true,"You can rewrite your query as such:

```
CREATE (a:USER:TTL {
    mail: &#39;a@b.de&#39;,
    fullName: &#39;example&#39;,
    password: &#39;spgjwetpjsfj32523rmdcp23r&#39;,
    createdAt : datetime.transaction(&#39;Europe/Berlin&#39;),
    ttl : timestamp() + 172800000,
    confirmHash: 697159094
})-[:HAS_FIRST_ADDRESS]-&gt;(address:ADDRESS:TTL {
    addressStreet: &#39;ab&#39;,
    addressAddition: &#39;zusatz&#39;,
    addressCityCode: 12334,
    addressCity: &#39;city&#39;,
    createdAt: datetime.transaction(&#39;Europe/Berlin&#39;),
    ttl: timestamp() + 172800000})
RETURN a
```

If you really need those `SET` clauses, remember that `SET` can only be used for setting properties and labels, not relationships to nodes.
You need `CREATE` (or `MERGE`) to create a relationship between two nodes.

```
CREATE (a:USER:TTL {mail: &#39;a@b.de&#39;, fullName: &#39;example&#39;, password: &#39;spgjwetpjsfj32523rmdcp23r&#39;})
SET a += {
    createdAt : datetime.transaction(&#39;Europe/Berlin&#39;),
    ttl : timestamp() + 172800000,
    confirmHash: 697159094 }
CREATE (address:ADDRESS:TTL {
    addressStreet: &#39;ab&#39;, addressAddition: &#39;zusatz&#39;, addressCityCode: 12334, addressCity: &#39;city&#39;})
SET address.createdAt = datetime.transaction(&#39;Europe/Berlin&#39;), address.ttl = timestamp() + 172800000
CREATE (a)-[:HAS_FIRST_ADDRESS]-&gt;(address)
RETURN a
```

Side note: labels usually follow the `PascalCase` case convention, not `UPPERCASE` (`UPPERCASE` is the conventional case for relationship types).",2,65790081
3014,https://stackoverflow.com/a/65831620,JQAssistant with multiple projects and builds,false,"There&#39;s a little misunderstanding: the idea behind the team instance is to have Neo4j instance per project with a single (i.e. latest) snapshot of the graph (usually filled by a nightly CI run). So there&#39;s currently no build (identifiable by a date, number etc.) in the data - but could be an interesting feature.
",1,65831620
3015,https://stackoverflow.com/a/65786925,How to combine two or more neo4j cypher result columns,true,"You can combine multiple fields as follows: 

    RETURN {post: a, author: b, comment: c}

",1,65786925
3016,https://stackoverflow.com/a/65780878,Neo4j v4.1.5 Community Edition CREATE INDEX doesn&#39;t recognise OPTIONS,true,"The `OPTIONS` clause was added in Neo4j 4.2.0 ( See changelog here : https://github.com/neo4j/neo4j/wiki/Neo4j-4.2-changelog#cypher-2 )

When reading the documentation, make sure you select the correct version of your Neo4j server : 

[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/kSlmZ.png",1,65780878
3017,https://stackoverflow.com/a/65779820,How to handle result,true,"Welcome!
If you query ends with `RETURN user` and because it seems you want a single result, you can write:

```go
	record, err := res.Single()
    // [...] check err
	userRecord, err := record.Get(&quot;user&quot;)
    // [...] check err
    userAttributes := userRecord.(dbtype.Node).Props // 1st cast record into node and extract properties
    userData.pseudo := userAttributes[&quot;pseudo&quot;].(string) // then cast each property value to expected type 
    // ...
```",0,65779820
3018,https://stackoverflow.com/a/65771355,neo4j cypher APOC.case returns null properties,false,"According to your condition `p.region_audience IS NOT NULL AND NOT (2 IN p.region_audience),` in `apoc.when` query:

In the **ifQuery**, the `apoc.when` returns `RETURN null` (**value** will be **null**) and in **elseQuery** returns `p` with Alias `post`.

So to access the result of the `apoc.when` query, you&#39;ve to use the alias given in **ifQuery** or **elseQuery** : `value.post.title`.

&gt; **Note that the result of `value` will always be `null` if the `ifQuery` is executed *(when the condition is respected)*.**",2,65771355
3019,https://stackoverflow.com/a/65863048,neo4j 4.2 how to copy users/passwords from one instance to other instance?,true,"In 4.X there is system database containing the users &amp; roles that need to be backup-ed and restored to the new location in order user credentials to be transferred , but let me know if there is other easiest option...",0,65863048
3020,https://stackoverflow.com/a/65758971,Is there a way to use Cypher in python without setting up a Neo4j server?,false,"There is pypher library that can do it:
https://github.com/emehrkay/Pypher",0,65758971
3021,https://stackoverflow.com/a/65757268,Spring bootRun fails during the installation of a plateform,true,"**NodeJs** is not required, forget it. Ok, you mean Neo4J

&gt; bootRun task that allows a developer to start the application in a
&gt; “developer mode” without first building a JAR file and then starting
&gt; this JAR file allows you to run the application **bypassing the test**.

./gradlew build only build your project/software. It does not execute it. 
**./gradlew bootRun** can be used to quickly compile and run your application

During build, other phases are executed, like test phase. If you want to compile the project by passing the tests, run 

    ./gradlew build -x test

For the purpose you have (to run the application), it is not necessary to run the tests at this time.

You must make sure you have postgres installed.
You must make sure exists a database user named &quot;postgres&quot; as **required by your application**. https://gitlab.com/TIBHannover/orkg/orkg-backend/-/blob/master/src/main/resources/config/application.yml#L35

Your application tries to connect to the PostgreSQL server using a user named &quot;postgres&quot; with password &quot;postgres&quot;.

Fails, when not finding connection with the server or the attempt to connect with the user &quot;postgres&quot; fails.

You can look at this article or some other related
https://chartio.com/resources/tutorials/how-to-set-the-default-user-password-in-postgresql/

**UPDATE:**


**Error:** 
  scheme &#39;none&#39; is only allowed when authentication is disabled

&gt; As with any other Spring Boot starter, the only thing you have to do
&gt; is to include the starter module via your dependency management.  If
&gt; you don’t configure anything, than the starter assumes
&gt; bolt://localhost:7687 as Neo4j URI and a server that has **disabled**
&gt; **authentication**. https://neo4j.com/developer/java-driver-spring-boot-starter/


By default your application doesn&#39;t provide user/password.
Add username/password to your yaml configuration:  https://gitlab.com/TIBHannover/orkg/orkg-backend/-/blob/master/src/main/resources/config/application.yml#L31

      data:
        neo4j:
          uri: bolt://localhost:7687
          username: admin
          password: admin


**How to test your Neo4J password**

Make sure that you can navigate http://localhost:7474/ you will be redirected to http://localhost:7474/browser/
Provide user/password
    admin
    admin

Then you will see the neo4J Dashboard

**UPDATE 2**

Try this&gt;  **If you didn&#39;t provide the no auth option on startup**, the default username and password is neo4j/neo4j.&quot; You need to select &quot;Username/password Authentication type&quot; and provide your user/password. 

Note:I have changed my user / password to exemplify in the image.

[![enter image description here][1]][1]


[![][2]][2]


  [1]: https://i.stack.imgur.com/HkiE6.png
  [2]: https://i.stack.imgur.com/cxP7u.png",1,65757268
3022,https://stackoverflow.com/a/65746191,figuring out what customers bought together with the most popular product in graph database,false,"The query to get a list of the stockcodes of products purchased with your most popular stock and the number of times they were purchased with the most popular item would be something like:
```
MATCH (pr:product{stockcode:&quot;85123A&quot;})&lt;-[includes]-(pu:purchase)-[includes]-&gt;(pr2:product)
RETURN pr2.stockcode, count (*) as quantity",0,65746191
3023,https://stackoverflow.com/a/65759416,No write operations are allowed directly on this database. Writes must pass through the leader. The role of this server is: FOLLOWER,false,"You need to use bolt+routing if you want to open connection to FOLLOWER, but writes to be sent to LEADER:

      ./cypher-shell -a bolt+routing://the_follower:7637",0,65759416
3024,https://stackoverflow.com/a/65736823,How to find the the most popular product in graph database?,false,"If a purchase can contain multiple time the same product, you&#39;ll need to traverse the full path from the customer and just return the path counts : 

```
MATCH (a:customer)-[r1:MADE]-&gt;(b:purchase)-[r2:includes]-&gt;(c:product)
RETURN c.id, count(*) AS score
ORDER BY score DESC
LIMIT 1
```

If a product can be included in a purchase only once, then you can just return the `degree` of the product for the `includes` relationship : 

```
MATCH (c:product)
RETURN c.id, size((c)&lt;-[:includes]-()) AS score
ORDER BY score DESC
LIMIT 1
```",1,65736823
3025,https://stackoverflow.com/a/65732018,Neo4j - How to display a graph of Nodes connected to properties of related nodes,true,"You can use [APOC Virtual Nodes and Relationships][1] to display such graph :

```
MATCH (n:Product)&lt;-[:TRANSACTION]-(c:Customer)
WITH n.category AS category, c, count(*) AS numberOfPurchases
WITH 
apoc.create.vNode([&#39;Category&#39;], {name: category}) AS catNode,
c,
numberOfPurchases
RETURN catNode, c, 
apoc.create.vRelationship(c, &#39;PURCHASED_IN_CATEGORY&#39;, {amount: numberOfPurchases}, catNode) AS rel
```


  [1]: https://neo4j.com/labs/apoc/4.1/virtual/virtual-nodes-rels/",1,65732018
3026,https://stackoverflow.com/a/65731948,Return group results in Cypher query (using apoc),false,"The result of the `apoc.nodes.group` procedure is not a single node but a list of nodes, as you can see in the error message.

You can just unwind them and return the result : 

```
CALL apoc.nodes.group([&#39;Package&#39;],[&#39;Repository&#39;])
YIELD nodes
UNWIND nodes AS node
RETURN node.Repository, node._count;",0,65731948
3027,https://stackoverflow.com/a/65730604,Cypher: how to update a property value in a node that exists in the Neo4j database?,false,"Please check the type of $id, maybe it&#39;s a string when you execute the update query. Tried with your example Neo4j doesn’t create a new node.
",1,65730604
3028,https://stackoverflow.com/a/65772910,Cypher: how to update a property value in a node that exists in the Neo4j database?,true,"First, you must determine what set of properties make the `Article` nodes unique (side note: the PascalCase is more common for labels than UPPERCASE).

Let&#39;s assume `id` is unique per article.

In that case, you only need to merge on that:

```
MERGE (article:Article {id: $id})
// [...]
```

It&#39;s usually a good idea to create an index as well, so that the `MATCH`ing part of `MERGE` executes fast. In that case, you would create an index for `:Article(id)`.

Assuming the title never changes after the node creation:
```
MERGE (article:Article {id: $id})
ON CREATE SET article.title = $title
// [...]
```

Given the score **always** changes, you can then run a simple `SET` clause without any `ON CREATE` or `ON UPDATE` prefix:
```
MERGE (article:Article {id: $id})
ON CREATE SET article.title = $title
SET article.score = $score
```

Of course, I made a few assumptions about your domain. Feel free to comment if I got some of them wrong and I&#39;ll update the answer.",1,65772910
3029,https://stackoverflow.com/a/68491983,Cypher: how to update a property value in a node that exists in the Neo4j database?,false,"A simpler solution:

`MATCH (a:ARTICLE {id:$id}) SET a.score = $score`",0,68491983
3030,https://stackoverflow.com/a/65730308,Neo4j: Check if node exists and use the result as a condition,true,"You can Match the node and then check the count of matching nodes if it&#39;s greater than zero it means the node exists. Here `node_exists` returns `true/false` you can replace `RETURN` with your apoc statements.

    MATCH (u:User {user_id: 1})
    WITH COUNT(u) &gt; 0  as node_exists
    RETURN node_exists",0,65730308
3031,https://stackoverflow.com/a/65735209,Neo4j not performing for undirected relationship,false,"I eventually solved this by changing my query to rely on directed relationships only. This brought the performance down to sub-second for very large data sets.

The query ended up looking like:

    MATCH (p:Person {id: 100}) - [h:HAS_SKILL] -&gt; (s:Skill) - [r:IS_IN_CAT*..] -&gt; (parentSkill:Skill) &lt;- [r:IS_IN_CAT*..] - (s2:Skill) &lt;- [h2:HAS_SKILL] - (p2:Person)

The introduction of the `parentSkill` allowed the relationships to stay directional.",0,65735209
3032,https://stackoverflow.com/a/65706047,“Invalid use of aggregating function in this context” using COUNT query (Neo4j),false,"I figured it out, Here is the solution.

```
MATCH (p:Persons)-[r:submitted]-&gt;(c:Claims) 
WITH p,count(c) as rels, collect(c) as claims
WHERE rels &gt; 1
RETURN p,claims,rels
```",0,65706047
3033,https://stackoverflow.com/a/65954158,Create graph from recursive JSON data using apoc.load.json and use UNWIND and FOREACH for setting property,true,"I got it solved. This is the query I used :

```
WITH &#39;file:///part-of-VTree.json&#39; AS json_file 
CALL apoc.load.json(json_file,&quot;$..FileId&quot;) YIELD value AS result 
WITH json_file, result.result AS keys UNWIND range(0,size(keys)-1) AS i 
CALL apoc.load.json(json_file,&quot;$..[?(@.FileId == &#39;&quot; + toString(keys[i]) + &quot;&#39;)].ChildNodes[*].FileId&quot;) YIELD value AS children 
CALL apoc.load.json(json_file,&quot;$..[?(@.FileId == &#39;&quot; + toString(keys[i]) + &quot;&#39;)].FileName&quot;) YIELD value AS rname
CALL apoc.load.json(json_file,&quot;$..[?(@.FileId == &#39;&quot; + toString(keys[i]) + &quot;&#39;)].ChildNodes[*].FileName&quot;) YIELD value AS cname
WITH keys[i] AS parent_key, children.result AS children, rname.result AS rn, cname.result AS cn
MATCH (n {name:parent_key})
WITH n, children,rn,cn
UNWIND children AS child_key
OPTIONAL MATCH (n)-[:CHILD]-&gt;(m {name:child_key})	 
WITH n, rn, cn, collect(m) AS siblings
UNWIND range(0,size(rn)-1) AS k
SET n.label=toString(rn[k])
With cn,siblings
UNWIND range(0,size(cn)-1) AS j
FOREACH(j IN range(0, size(siblings)-1) |
 FOREACH (p1 in [siblings[j]] |
  Set p1.label=toString(cn[j])
 ))
RETURN *

```
Hope this would help someone.",0,65954158
3034,https://stackoverflow.com/a/65702548,Cypher to show relationships of hidden nodes,false,"Not sure it&#39;s the better way to do it. But I did found the answer:

    MATCH (a:Asset)-[rel]-(b:Asset) WHERE a.level &gt;= 2 AND b.level &gt;= 2 
    RETURN a, rel, b

    UNION

    MATCH (a:Asset) -[:USING]-(:Asset)-[:ATTACHED]-(b:Asset) WHERE a.level &gt;= 2 
    AND b.level &gt;= 2
    CALL apoc.create.vRelationship(a,&#39;USING&#39;,{}, b) YIELD rel
    RETURN a, rel, b

    UNION

    MATCH (a) WHERE NOT (a)--() 
    RETURN a, null as rel, null as b;",0,65702548
3035,https://stackoverflow.com/a/65680054,Using DASK to read files and write to NEO4J in PYTHON,true,"You are getting this error because you are trying to share the driver object amongst your worker.

The driver object contains private data about the connection, data that do not make sense outside the process (and also are not serializable).

It is like trying to open a file somewhere and share the file descriptor somewhere else. 
It won&#39;t work because the file number makes sense only within the process that generates it. 

If you want your workers to access the database or any other network resource, you should give them the directions to connect to the resource. 

In your case, you should not pass the `global_driver` as a parameter but rather the connection parameters and let each worker call `get_driver` to get its own driver.",1,65680054
3036,https://stackoverflow.com/a/65673386,How do I return relationship properties (Neo4j + Spring data)?,true,"Starting with Spring Data Neo4j 6, relationship cannot be top-level entities anymore.

As a consequence, your repository methods must return `Skill`, `SomeCollection&lt;Skill&gt;` (where `SomeCollection` can be a `List`, `Set`, `Flux`, `Page` etc).
You can also return projections based on `Skill`, but not `@RelationshipProperties`-annotated classes.",4,65673386
3037,https://stackoverflow.com/a/65654704,GraphQL &amp; Neo4j : how to modify a property with a mutation request?,false,"Id suggest using an [optional match](https://neo4j.com/docs/cypher-manual/current/clauses/optional-match/) and use `SET`.

```cypher
OPTIONAL MATCH (a:Article {id:$id, saved:$saved})
SET a.saved = true
WITH a IS NOT NULL AS found
RETURN found
```

Here I am returning a boolean to represent if the node was matched, thus set. Using the boolean here to reduce the amount of data sent back but you could just as easily return the node. 

```graphql
type Mutations {
    saved(article: ID! director: ID!): Boolean @cypher(statement:&quot;&quot;&quot;
      OPTIONAL MATCH (a:Article {id:$id, saved:$saved})
      SET a.saved = true
      WITH a IS NOT NULL AS found
      RETURN found
    &quot;&quot;&quot;)
}
```",1,65654704
3038,https://stackoverflow.com/a/69183234,Simulate a MERGE in Neptune&#39;s OpenCypher implementation,true,"openCypher does not provide a robust capability to perform the type of logic in a query that you show in your pseudocode.  Until `MERGE` is a supported clause in AWS Neptune the best way to achieve this functionality is to use the Gremlin pattern for this as described [here][1]. Neptune provides the ability to use both openCypher and Gremlin (via drivers or over HTTPS) on property graph data stored in Neptune.  For your pseudo code above the Gremlin equivalent would look like this:

    g.V().
      has(&#39;Person&#39;, &#39;name&#39;, &#39;Sam&#39;).
      fold().
      coalesce(
        addV(&#39;NEW LABEL&#39;).property(&#39;propertyName&#39;, &#39;foo&#39;),
        property(&#39;updateProperty&#39;, &#39;bar&#39;))


  [1]: http://tinkerpop.apache.org/docs/current/recipes/#element-existence",1,69183234
3064,https://stackoverflow.com/a/69017449,Cypher - Add multiple connections,false,"You probably need to use **`UNWIND`**.

I haven&#39;t tested the code, but something like this might work:

```
MATCH 
    (s:Student)-[:STUDENT_BELONGS_TO]-&gt;(c:Classroom),
    (u:Subjects)-[:SUBJECTS_TAUGHT_IN]-&gt;(c:Classroom)
WITH
    s AS student, COLLECT(u) AS subjects
UNWIND subjects AS subject
CREATE (student)-[:IN_SUBJECT]-&gt;(subject)
```",0,69017449
3065,https://stackoverflow.com/a/69017503,Cypher - Add multiple connections,true,"I think what you are looking for is UNWIND. If you have an array as parameter to your query:

```
studentList :
[
  studentId: &quot;sid1&quot;, classroomId: &quot;cid1&quot;,  subjectNames: [&#39;s1&#39;,&#39;s2&#39;] },
  studentId: &quot;sid2&quot;, classroomId: &quot;cid2&quot;,  subjectNames: [&#39;s1&#39;,&#39;s3&#39;] },
  ...
]
```

You can UNWIND that parameter in the beginning of your query:
```
UNWIND $studentList as student
MATCH
  (s:Student)-[:STUDENT_BELONGS_TO]-&gt;(c:Classroom),
  (u:Subjects)-[:SUBJECTS_TAUGHT_IN]-&gt;(c:Classroom)
WHERE
  s.id = student.studentId
AND c.id = student.classroomId
AND u.name = in student.subjectNames
AND NOT (s)-[:IN_SUBJECT]-&gt;(u)
CREATE (s)-[:IN_SUBJECT]-&gt;(u)",0,69017503
3066,https://stackoverflow.com/a/68946704,Cypher query for gremlin traversal,false,"I&#39;m not 100% sure what you are looking for as the Gremlin above seems incomplete compared to the description but I think what you are looking for is something like this:

    MATCH (e1:Entity1)&lt;-[:Entity2]-(e2)-[:Entity3]-&gt;(e3)-[:Entity4]-&gt;(e4 {code: &#39;LHR&#39;})
    WHERE e1 IN (id1)
    RETURN e2",0,68946704
3067,https://stackoverflow.com/a/68946739,Cypher query for gremlin traversal,true,"Straight answer: 
```
MATCH (m:Entity1 )&lt;-[:Entity2]-(n) 
WHERE (n)-[:Entity3]-&gt;()-[:Entity4]-&gt;({name: &quot;ABC&quot;}) 
       AND m.id in [&quot;id1&quot;]
RETURN n

# Assuming id is a property here. 

# If id is the actual ID of the node

MATCH (m:Entity1 )&lt;-[:Entity2]-(n) 
WHERE (n)-[:Entity3]-&gt;()-[:Entity4]-&gt;({name: &quot;ABC&quot;}) 
       AND ID(m) in [&quot;id1&quot;]
RETURN n

```

I tried to create the graph for you use-case using this query: 
```
CREATE (a:Entity2)-[:Entity2]-&gt;(b:Entity1 {id:&quot;id1&quot;}), 
    (a)-[:Entity3]-&gt;(:Entity3)-[:Entity4]-&gt;(:Entity4 {name:&quot;ABC&quot;})
```

the graph looks like this: 

[![sample graph][1]][1]

However, I think while writing your gremlin traversal you had the intention of specifying the label of the vertex rather than label of the edge. That is why in the query I wrote to create the graph, the relationship and the vertex, relationship is pointing to have same label. 

If that is your intention then your cypher query would look like. 
```
MATCH (:Entity1 {id:&quot;id1&quot;})&lt;--(n:Entity2) 
WHERE (n)--&gt;(:Entity3)--&gt;(:Entity4 {name: &quot;ABC&quot;})
RETURN n

```

  [1]: https://i.stack.imgur.com/OiIWc.png",3,68946739
3068,https://stackoverflow.com/a/68731334,openCypher client for AWS Neptune,true,"With the recent release of openCypher on Neptune we have provided support for querying and visualizing results of openCypher queries via the Jupyter notebook as you have mentioned.  This tool is good for writing and visualizing queries but does not have graph exploration functionality for clicking on and expanding connected nodes/edges.  

However with the release of openCypher Neptune supports interoperability between Gremlin and openCypher on top of the same data.  This means that you can load the data one time and use either query language.  This allows you to use any of the graph exploration tooling that works with Gremlin, such as https://github.com/prabushitha/gremlin-visualizer or https://www.tomsawyer.com/graph-database-browser to provide graph exploration capabilities without having to reload the data.

",1,68731334
3069,https://stackoverflow.com/a/68846990,nodejs recover createCipher data with createCipheriv,false,"&gt; I tried setting the iv to null but not working

This is because this method didn’t allow for passing an initialization vector (IV), and instead derived the IV from the key using the OpenSSL `EVP_BytesToKey` derivation function, using a `null` salt meaning that the IV would be deterministic for a given key which is an issue for ciphers with counter mode like CTR, GCM and CCM.

Looking at your code:

```js
 const cipher = crypto.createCipher(&#39;aes192&#39;, password);
```

If you want to make this code backwards compatible, you need to call OpenSSL’s `EVP_BytesToKey` function yourself, typically through [evp_bytestokey module](https://www.npmjs.com/package/evp_bytestokey) which makes it available in JS userland.

&gt; Is it possible to decode with `createDecipheriv` data encoded with `createDecipher` and to generate the same secret with `createCipher` and `createCipheriv`.

Yes, you can. check out my example code here:

```js
const crypto = require(&#39;crypto&#39;);
const EVP_BytesToKey = require(&#39;evp_bytestokey&#39;)
const ALGO = &#39;aes192&#39;;
const password = &#39;Your_Password_Here&#39;;
const KEY_SIZE = 24;

function decrypt_legacy_using_IV(text) {
    const result = EVP_BytesToKey(
      password,
      null,
      KEY_SIZE * 8, // byte to bit size
      16
    )

    let decipher = crypto.createDecipheriv(ALGO, result.key, result.iv);
	let decrypted = decipher.update(text, &#39;hex&#39;,&#39;utf8&#39;) + decipher.final(&#39;utf8&#39;);
	return decrypted.toString();
}

function encrypt_legacy_using_IV(text) {
    const result = EVP_BytesToKey(
      password,
      null,
      KEY_SIZE * 8, // byte to bit size
      16
    )

    var cipher = crypto.createCipheriv(ALGO, result.key, result.iv);
	var encrypted = cipher.update(text, &#39;utf8&#39;, &#39;hex&#39;) + cipher.final(&#39;hex&#39;);
	return encrypted.toString();
}

```
For complete running example, clone [node-snippets](https://github.com/ApOgEE/node-snippets/blob/main/answering_stackoverflow/apogee-legacy-crypto-cipheriv.js) and run `node apogee-legacy-crypto-cipheriv.js`.

However the reason this function is deprecated in the first place is because **you shouldn’t use it**, and instead use a random unpredictable IV, which requires you to change your code to something like this:

```js
const iv = crypto.randomBytes(16)
const cipher = crypto.createCipheriv(&#39;aes192&#39;, password, iv)
```

Here, for AES-192 in CBC mode (`aes192` being aliased to `AES-192-CBC` by OpenSSL), the IV size is expected to be the same as the block size, which is always 16 bytes.

In order to decrypt the message, you will need the IV as well. Typically you’d store the IV together with the message, as the important part is for the IV to not be predictable ahead of time.
",1,68846990
3070,https://stackoverflow.com/a/68584145,Dom Traversal with lxml and save their relashionship into a Key/Value Pair Cypher Query,false,"`ElementTree` provides a method, `getiterator()`, to iterate over every element in the tree.

As you visit each node, you can also get a list of its children with `element.getchildren()` or its parent with `element.getparent()`.

```
from lxml import html
tree = html.parse(&quot;about.html&quot;)
for element in tree.getiterator():
    if parent := element.getparent():
        print(f&quot;The element {element.tag} with text {element.text} and attributes {element.attrib} is the child of the element {parent.tag}&quot;)

```

",1,68584145
3071,https://stackoverflow.com/a/68447747,How to reverse engineer simple checksum,false,"No. 

Well, most checksum algorithms, even old ones, are designed exactly to prevent this. Change any one bit on the input, get a completely random looking checksum, that looks completely unrelated to every other possible checksum. 

Of course you could run the different example inputs you have through all the algorithms you know and see if the output contains any of the example outputs (it could be at the beginning or the end, or maybe somewhere in the middle). 

If it&#39;s any more sophisticated, it&#39;s probably using &quot;[salt][1]&quot;. Adding a secret phrase (the &quot;salt&quot;) to the data before running it through the algorithm. You could brute-force start guessing, but i hope you see this is getting very unrealistic very quickly. 


  [1]: https://en.wikipedia.org/wiki/Salt_(cryptography)",0,68447747
3072,https://stackoverflow.com/a/68469720,How to reverse engineer simple checksum,false,"I found something, maybe...

I think that the hashing has been done using some crc method, and by using this very helpful tool:

https://reveng.sourceforge.io/readme.htm

I found these results:

    width=32 poly=0x2882b989 init=0xc6ea9616 refin=false refout=false xorout=0x00000000 check=0x6d514c85 residue=0x000000000 name=(none)

Because this not being a standard CRC I don&#39;t know how to check if this polynomial works (I don&#39;t want to implement a CRC hash generator by myself)...

Is there any tool that can create a CRC hash given data input and polynomial&#39;s characteristics (like poly, init)?

I have found:

https://github.com/madler/crcany

but I don&#39;t know how to make it work (I didn&#39;t find any examples).

Thanks",0,68469720
3073,https://stackoverflow.com/a/68383957,Changing node reference in RedisGraph relationship,true,"RedisGraph doesn&#39;t have an equivalent to the `mergeNodes` functionality, nor does it support changing the endpoint of an existing edge.

As such, you will need to delete the original edge and introduce a new one:
```
MATCH (bob:User {uid: 1})-[p:Paid {amount: 5, date: &quot;Feb 5 2021 10:10:05&quot;}]-&gt;(alice:User {uid: 2}) WITH bob, p, {amount: p.amount, date: p.date} AS props MATCH (john:User {uid: 3}) DELETE p CREATE (bob)-[p2:Paid]-&gt;(john) SET p2=props
```

This can be simplified a bit if your program is aware of the property values and can use them as literals:
```
MATCH (bob:User {uid: 1})-[p:Paid {amount: 5, date: &quot;Feb 5 2021 10:10:05&quot;}]-&gt;(alice:User {uid: 2}) DELETE p CREATE (bob)-[p2:Paid {amount: 5, date: &quot;Feb 5 2021 10:10:05&quot;}]-&gt;(john)
```
Either approach will cause the new edge to have the same ID as the previous one, as the edge ID is released by the `DELETE` and immediately reused by the `CREATE`. ",1,68383957
3074,https://stackoverflow.com/a/68330030,Architecture and querying in RedisGraph,true,"&gt; what would be a better architecture?

I believe you refer to what is called &quot;graph modelling&quot;. Graph modelling in the basic form consists out of deriving entities and verbs out of sentences
- entities -&gt; candidate labels
- verbs -&gt; candidate relationship types

&gt; A payment can be deposited from a user. Some other user can eventually
&gt; withdraw that deposit,

- entities: Payment/Deposit/Transaction (I assume you use this interchangeably) and User
- verbs: deposit and withdraw

So you did a good job nailing that.


With regards to your second question. Given two transactions

```
(u1:User {uid:1})-[:Deposit]-&gt;(t1:Transaction {tid:1})&lt;-[:Withdrawal]-(u3:User {uid:3})
(u2:User {uid:2})-[:Deposit]-&gt;(t2:Transaction {tid:2})
```

```
redis:6379&gt; GRAPH.QUERY g &quot;MERGE (u1:User {uid:1})-[:Deposit]-&gt;(t1:Transaction {tid:1})&lt;-[:Withdrawal]-(u3:User {uid:3}) MERGE (u2:User {uid:2})-[:Deposit]-&gt;(t2:Transaction {tid:2})&quot;
1) 1) &quot;Labels added: 2&quot;
   2) &quot;Nodes created: 5&quot;
   3) &quot;Properties set: 5&quot;
   4) &quot;Relationships created: 3&quot;
   5) &quot;Cached execution: 0&quot;
   6) &quot;Query internal execution time: 1.920000 milliseconds&quot;
```

You can add a `WHERE NOT` clause at query time

```
MATCH (u:User)-[d:Deposit]-&gt;(t:Transaction)
WHERE NOT ((t)&lt;-[:Withdrawal]-())
RETURN u.uid
```
Which should only return the user with uid 2
```
redis:6379&gt; GRAPH.QUERY g &quot;MATCH (u:User)-[d:Deposit]-&gt;(t:Transaction) WHERE NOT ((t)&lt;-[:Withdrawal]-()) RETURN u.uid&quot;
1) 1) &quot;u.uid&quot;
2) 1) 1) (integer) 2
3) 1) &quot;Cached execution: 0&quot;
   2) &quot;Query internal execution time: 0.816100 milliseconds&quot;
```

",2,68330030
3075,https://stackoverflow.com/a/68142785,Assigning numerical values to letters in a word,false,"You can use enumerate for this:

    m=[i for i in enumerate(sorted(listword), 1)]
    
    for k in m:
        print(k[1], &#39; equals &#39;, k[0])

Output:

    a  equals  1
    c  equals  2
    e  equals  3
    i  equals  4
    l  equals  5
    n  equals  6
    n  equals  7
    n  equals  8
    o  equals  9
    o  equals  10
    p  equals  11
    s  equals  12
    t  equals  13
    t  equals  14",0,68142785
3076,https://stackoverflow.com/a/67893704,Detect if a text encrypted using AES CBC is padded or not,false,"The comments are correct, however, there is a better way on the programming side; the [bad padding exception][1] ( assuming the Java)

```java
try {
     
     //do the decryption....

    } catch (javax.crypto.BadPaddingException e ){
          Sytem.out.Println(&quot;It is not PKCS#7 padding&quot;)
          e.printStackTrace();

    } catch (Exception e) {
        e.printStackTrace();
        return null;
    }

```
If you get an exception, then it is not PKCS#7. If you don&#39;t get an exception then you have a 1/256 probability that it is not PKCS#7 but your file ended with the byte `0x01`. There are other cases like your file ended with `0x0202`, however, the probability is very low, and lower than this for other cases, too. The easiest is to try more than one file.

Why I did say `PKCS#7 padding` is simple. Although Java says PKCS#5 padding it is not, it is PKCS#7 padding that supersedes #5. #5 was designed for 64-bit block-sized ciphers like DES and #7 was designed up to 256-bytes, where AES has a 128-bit block size.

----

Note that the probability is assuming that the files are random, not regular text files.


  [1]: https://docs.oracle.com/javase/8/docs/api/javax/crypto/BadPaddingException.html",1,67893704
3077,https://stackoverflow.com/a/67689587,redisgraph.js - Parsing results of MERGE command,false,"the result-set statistics will let you know how many nodes/edges were created, if none that means the pattern existed, otherwise merge created the pattern.",0,67689587
3078,https://stackoverflow.com/a/67056168,cypher query with subpath and exists in redisgraph,false,"It&#39;s equivalent, rewrite:
```
MATCH (k)-[:HAS]-&gt;(a:temporary) WHERE k.name=&#39;k1&#39;
MATCH p = (a)-[:KNOWS*0..]-&gt;(b) 
WHERE not ()-[:KNOWS]-&gt;(a) AND not (b)-[:KNOWS]-&gt;() 
RETURN p
```

",1,67056168
3079,https://stackoverflow.com/a/67030913,"Given a plain text and a possible cipher text, determine whether the cipher text can be formed from the plain text using the mentioned scheme",true,"&gt; [IPYNB Formatted Code Here][1]

    s = input()
    p = input()
    #s = s[::-1]
    t = &#39;&#39;
    for c in s:
      t+=chr((ord(c)+5-ord(&#39;A&#39;))%26 + ord(&#39;A&#39;))
      
    
    def removeSpaces(string): 
        string = string.replace(&#39; &#39;,&#39;&#39;) 
        string = string.replace(&#39;,&#39;,&#39;&#39;)
        return string.lower()
    def check(t, p):
         
        # the sorted strings are checked 
        if(sorted(t)== sorted(p)):
            print(&quot;Yes&quot;,end=&#39;&#39;) 
        else:
            print(&quot;No&quot;,end=&#39;&#39;)         
             
    check(t, p)


  [1]: https://roboticswithpython.com/week-12-iitropar-joy-of-computing-with-python-programming-nptel/",0,67030913
3080,https://stackoverflow.com/a/67030960,"Given a plain text and a possible cipher text, determine whether the cipher text can be formed from the plain text using the mentioned scheme",false,"Thanks guys this is what i came up with 

    `x=input()
    y=input()
    a=&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;
    t=&#39;&#39;
    for i in x:
      c=a.index(i)
      cj=(c+5)%26
      t=t+a[cj]
    if(sorted(y)==sorted(t)):
      print(&quot;Yes&quot;,end=&#39;&#39;)
    else:
      print(&quot;No&quot;,end=&#39;&#39;)`",0,67030960
3081,https://stackoverflow.com/a/67030968,"Given a plain text and a possible cipher text, determine whether the cipher text can be formed from the plain text using the mentioned scheme",false,"    a=input()
    d={}
    for i in a:
      d[chr(((ord(i)-60)%26)+65)]=d.get(chr(((ord(i)-60)%26)+65),0)+1
    b=input()
    for i in b:
      if d.get(i,0)&lt;=0:
        print(&quot;No&quot;,end=&quot;&quot;)
        break
      d[i]-=1
    else:
      print(&quot;Yes&quot;,end=&quot;&quot;)",-1,67030968
3082,https://stackoverflow.com/a/67096244,How do I search for nodes without incoming edges/relations in AgensGraph?,true,"You&#39;re query `match (n) where not (n)&lt;-[]-() return *;` is close however you need to add 2 more elements to get the  query to work.

 1. Your pattern (n)&lt;-[]-() needs to be surrounded by parenthesis.
 2. You need to prefix your pattern with EXISTS

So I ran this query: `MATCH (a) WHERE NOT EXISTS ((a)&lt;-[]-()) RETURN *;` and it worked.",1,67096244
3083,https://stackoverflow.com/a/66345563,Normalize node property cypher linear and log,false,"Thanks to Andrew Bowman @neo4j
The short answer is 

    MATCH (n:MYLABEL) 
    WHERE n.count &gt; 0
    WITH max(n.count) as maxCount
    MATCH (n:MYLABEL) 
    WHERE n.count &gt; 0
    SET n.count_n = n.count/maxCount

A different approach is

    MATCH (n:MYLABEL) 
    WHERE n.count &gt; 0
    WITH max(n.count) as maxCount, collect(n) as nodes
    UNWIND nodes as n
    SET n.count_n = n.count/maxCount

The reason of my misunderstanding:
the grouping key provides context for what you&#39;re aggregating over. n.count was the grouping key. So per that value, you asked for the max of that value, which is itself.
You need to remove that as the grouping key so max () is calculated with respect to all results. So either remove it completely, or collect () the values (it would become an aggregation term so not part of the grouping key), then UNWIND it back to rows afterwards.
",0,66345563
3095,https://stackoverflow.com/a/66338569,Cypher relating distant nodes and displaying the merged relationship,false,"Assuming that your project node is identifiable through a label and/or properties, this is one way.

```
MATCH (p:Person {name: &#39;Bob&#39;})
MATCH (project:Project)
MATCH path=(p)-[*]-(project)
RETURN path LIMIT 1
```",0,66338569
3096,https://stackoverflow.com/a/66154152,Cypher BFS with multiple Relations in Path,false,"Since it&#39;s viable to have 7 different path sections, I don&#39;t see how 3 BFS patterns (`... BFS*0..n`) would yield a valid solution. It&#39;s impossible to have an empty path because the pattern contains some nodes between them (I have to double-check that).

Writing individual patterns is not great.

Some options are:

* `MATCH path=(s)-[:BFS*0.n]-(d) WHERE {{filter_expression}}` -&gt; The expression has to be quite complex in order to yield valid paths.
* `MATCH path=(s)-[:BFS*0.n]-(d) CALL module.filter_procedure(path)` -&gt; The `module.procedure(path)` could be implemented in Python or C/C++. Please take a look [here](https://docs.memgraph.com/memgraph/reference-guide/query-modules). I would recommend starting with Python since it&#39;s much easier. Python for the PoC should be fine. I would also recommend starting with this option because I&#39;m pretty confident the solution will work, + it&#39;s modular. After all, the `filter_procedure` could be extended easily, while the query will stay the same.

**Could you please provide a sample dataset in a format of a Cypher query** (a couple of nodes and edges / a small graph)? I&#39;m glad to come up with a solution.",1,66154152
3097,https://stackoverflow.com/a/66028652,redisgraph create edge between nodes if not exist already in high traffic,true,"Please see [RedisGraph Merge docs][1] more specifically `ON MATCH` and `ON CREATE`

e.g. 

```
MATCH (a:ACTOR {id: &#39;Charlie&#39;}), 
      (m:MOVIE {id: &#39;TwoAndAHalfMen&#39;}) 
MERGE (a)-[e:ACTED {prop1: val1}]-&gt;(m) 
ON CREATE SET e.prop2 = &#39;cur-time&#39;
```

  [1]: https://oss.redislabs.com/redisgraph/commands/#merge",1,66028652
3098,https://stackoverflow.com/a/65897755,How to sum all values in a returned column Cypher?,true,"You are forcing the split by returning ``c, i.kit, count(i)``. And what graph database does absolutely makes sense. To get aggregate just return ``count(i)``

And if for some odd reason you seek to get the result you are asking.

    MATCH (c:Customers {name:&#39;Paul Pogba&#39;})-[:ORDERED]-&gt;(o:Orders)-[:BOUGHT]-&gt;(i:Items)
    WITH collect(DISTINCT c) AS _c, collect(DISTINCT i) AS _i, count(i) AS count_i
    UNWIND _c AS c
    UNWIND _i AS i
    RETURN c, i.kit, count_i",0,65897755
3099,https://stackoverflow.com/a/65646953,How to create nodes with parameterized labels in Cypher,true,"With pure Cypher you can&#39;t, but nowadays everybody use the [APOC library][1] with the [`apoc.create.node`][2] procedure : 

```
LOAD CSV WITH HEADERS FROM &#39;https://xyz/nodes.csv&#39; AS line
CALL apoc.create.node([&#39;EVAL&#39;, line.type], {name: line.name})
YIELD node
RETURN node
```


  [1]: https://neo4j.com/developer/neo4j-apoc/
  [2]: https://neo4j.com/labs/apoc/4.1/overview/apoc.create/apoc.create.node/",1,65646953
3100,https://stackoverflow.com/a/65640364,How i find neo4j cypher?,true,"I assume you only need a Person node that would like to recommend.
Here is how you can proceed in 2 steps:

**Step-1. Find Persons (friend-of-friend) and count of common friends:**

    MATCH path=(neo:Person {name: &quot;You&quot;})-[:RELATED_TO*2]-&gt;(target:Person) 
    WHERE target &lt;&gt; neo
    WITH neo, target, count(path) as cf 
    RETURN target, cf

**Step-2. Filter Persons who have 2 or more friends in common:**

    MATCH path=(neo:Person {name: &quot;You&quot;})-[:RELATED_TO*2]-&gt;(target:Person) 
    WHERE target &lt;&gt; neo
    WITH neo, target, count(path) as cf 
    WITH target WHERE cf &gt;= 2
    RETURN target, cf

",2,65640364
3101,https://stackoverflow.com/a/65635431,match using variable and create relationship between the results of the same variable,false,"You can collect all network functions that has a send or receive relationship with mobility management. Then for each network pairs, create that relationship (A_RELATIONSHIP).  Note that I used an APOC function (apoc.coll.combinations) so ensure that this function is installed.

    MATCH (n:NetworkFunction)
    WHERE size((n)-[:SENDS|:RECEIVES]-(:MobilityManagement)) &gt; 0
    WITH collect(n) as allNetworkFunctions
    UNWIND apoc.coll.combinations(allNetworkFunctions, 2) as network
    WITH network[0] as first, network[1] as second
    MERGE (first)-[:A_RELATIONSHIP]-(second)",0,65635431
3102,https://stackoverflow.com/a/65631364,Need to optimize Neo4j Query,false,"A simple thing would be to update to Neo4j 3.5.x at least.

If a person has all activities linked to it with HAS_ACTIVITY relationship, why do you need to further traverse the NEXT relationship? Would the following query not suffice?

    MATCH (m:Person { id: &#39;58c1370350b91a0005be0136&#39;})-[:FOLLOWS*1..1]-&gt;(f:Person)-[:HAS_ACTIVITY]-&gt;(la:Activity)
    WHERE la.verb IN [&#39;post&#39; ,&#39;post_media_item&#39; ,&#39;watch_activity&#39;] 
    RETURN f, la ORDER BY la.published DESC LIMIT 10",0,65631364
3103,https://stackoverflow.com/a/65601337,How to continue executing a Neo4J Cypher request after MATCH is not matched?,false,"Use OPTIONAL MATCH.  If there is no match is found, then it will use NULL for the missing part of the pattern. It is similar to outer join in SQL.

    NEW:
    OPTIONAL MATCH (cp1:Concept{name:l.about}) 
    
    OLD:
    MATCH (cp1:Concept{name:l.about}) ",0,65601337
3104,https://stackoverflow.com/a/65601933,How to continue executing a Neo4J Cypher request after MATCH is not matched?,false,"You can maybe replace it with an `IN` predicate ? 

For eg : 

```
WITH {from: &#39;Matt Olg&#39;, about: &#39;Matthew Olg&#39;}
AS l
MATCH (n:Person)
WHERE n.name IN [l.from, l.to]
RETURN n.name

╒══════════╕
│&quot;n.name&quot;  │
╞══════════╡
│&quot;Matt Olg&quot;│
└──────────┘
```

[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/VJXSC.png",0,65601933
3105,https://stackoverflow.com/a/65603481,How to use the int[] in where IN clause in Cypher Query (using C#),false,"Best is probably to use parameters : 

```
int[] pIds = new int[] {101, 012}; 
var query = _graphClient.Cypher.Read
            .OptionalMatch($&quot;(p: {Labels.PERSON})&quot;)
            .Where($&quot;p.Id IN $pIds&quot;) 
            .Return&lt;Person&gt;(p)
            .WithParam(&quot;pIds&quot;, pIds);
```",0,65603481
3106,https://stackoverflow.com/a/66230888,How to use the int[] in where IN clause in Cypher Query (using C#),true,"I resolved it by getting the int[] into one string seperated by ,

    var param = string.Join(&quot;,&quot;, myIntList); 
    
    var query = _graphClient.Cypher.Read
                .OptionalMatch($&quot;(p: {Labels.PERSON})&quot;)
                .Where($&quot;p.Id IN $param&quot;) 
                .Return&lt;Person&gt;(p)
                .WithParam(&quot;param&quot;, param)",0,66230888
3107,https://stackoverflow.com/a/65601368,How to check if a UNWIND parameter exists in Neo4J Cypher?,false,"Use OPTIONAL MATCH.  If there is no match is found, then it will use NULL for the missing part of the pattern. It is similar to outer join in SQL.

    NEW:
    OPTIONAL MATCH (c:Concept{name:mentionsRelation.name}) 
    
    OLD:
    MATCH (c:Concept{name:mentionsRelation.name})",0,65601368
3108,https://stackoverflow.com/a/65602040,How to check if a UNWIND parameter exists in Neo4J Cypher?,false,"You can maybe use `apoc.do.when` where you can specify a query if the predicate matches and one if it doesn&#39;t, for eg : 

```
WITH [{mentions: [], count:10}, {mentions: []}] AS params
UNWIND params AS parameter
CALL apoc.do.when(parameter.count IS NOT NULL, &#39;RETURN null AS c&#39;, &#39;MATCH (n:Person) RETURN count(n) AS c&#39;)
YIELD value
RETURN value

╒══════════╕
│&quot;value&quot;   │
╞══════════╡
│{&quot;c&quot;:null}│
├──────────┤
│{&quot;c&quot;:10}  │
└──────────┘
```",0,65602040
3109,https://stackoverflow.com/a/65588603,Neo4j: How to return nodes which have a specific node in common?,false,"Using size, you can build your query like this:

```
MATCH (common:Label_A) WHERE size((common)--(:Label_B)--(:Label_C)) &gt; 3
WITH common
MATCH (common)--(:Label_B)--(output:Label_C)
RETURN DISTINCT output
```
where 3 can be replaced with your actual threshold.",0,65588603
3110,https://stackoverflow.com/a/65578544,Remove unnecessary relationships between nodes?,false,"There are potentially several things to fix in the import query:

The year nodes are misleading. I think you should extract the month attribute to a separate node, like this:

```
MERGE (y:Year {year:toInteger(line.YearofJoining))
MERGE (m:Month {month:line.MonthNamofJoining})-[:MONTH_IN_YEAR]-&gt;(y)
```

Also, the modelling seems wrong. Currently, a Location is linked to year (or soon: month in year) via JOINING_YEAR. An age is linked to a location. This does seem to make sense.

You probably want an intermediate node to represent the fact that an employee has a joined a location (given Neo4j doesn&#39;t support relationships between more than 2 nodes).


```
LOAD CSV WITH HEADERS FROM &#39;file:///y.csv&#39; AS line
MERGE (a:Employee {empid:line.EmpID})
   ON CREATE SET a.firstname = line.FirstName, a.lastname = line.LastName
MERGE (ag:Age {age:toInteger(line.AgeinYrs)})
MERGE (a)-[:AGE]-&gt;(ag)

MERGE (y:Year {year:toInteger(line.YearofJoining))
MERGE (m:Month {month:line.MonthNamofJoining})-[:MONTH_IN_YEAR]-&gt;(y)
MERGE (c:Location {city:line.City}) 
   ON CREATE SET c.pincode = line.PinCode,c.county = line.County,c.state = 
line.State,c.region = line.Region
MERGE (j:Join {empid:line.EmpID}) // need a property to merge on

MERGE (a)-[:JOINED]-&gt;(j)
MERGE (j)-[:LOCALITY]-&gt;(c)
MERGE (j)-[:JOINING_MONTH]-&gt;(m)
```

Your read query becomes:

```
MATCH p = (:Location)&lt;-[:LOCALITY]-(:Join)&lt;-[:JOINED]-(a:Employee)-[:AGE]-&gt;(:Age)
WHERE a.empid IN [&#39;840300&#39;,&#39;840967&#39;,&#39;346058&#39;,&#39;320954&#39;]
return p limit 25
```

Unrelated formatting note: 
the recommended case for attribute is camelCase (e.g. empId instead of empid) and for relation types is SNAKE_CASE (e.g. JOINING_YEAR instead of JOININGYEAR). 
By convention, relation types are verbs more often than not.",0,65578544
3111,https://stackoverflow.com/a/65564207,neo4j fulltext index search with special charcters,true,"The analyzer will probably recognise words like `ab.or` differently than `ab.or123` and consider them a single token in the first case and two tokens in the second case.

There is no analyzer that will really fit your needs except than creating your own.

You can however replace the `.` in your query with a simple `AND`, for eg : 

```
CALL db.index.fulltext.queryNodes(&#39;Test&#39;, replace(&quot;*FO41.SI0*&quot;, &quot;.&quot;, &quot; AND &quot;))
```

Will return you the results you&#39;re looking at.

---

Resources for creating your own analyser : 

https://graphaware.com/neo4j/2019/09/06/custom-fulltext-analyzer.html

https://neo4j.com/docs/java-reference/current/extending-neo4j/full-text-analyzer-provider/

",1,65564207
3112,https://stackoverflow.com/a/65567211,Shortest path of multiple shortest pathes,false,"You just need to add the person id in the return statement, so the collect aggregates by person id

    match (p:PERSON)
    with p
    match path = shortestPath( (person)-[*]-(:MOVIE) )
    with person.id as p_id, path ORDER BY length(path)
    return p_id, collect(path)[0]",0,65567211
3113,https://stackoverflow.com/a/65543124,Neo4J Subquery over same property to calculate ratio,true,"It&#39;s because count values are Integers.

For example : 

```
WITH 165392 AS v1, 73693 AS v2
RETURN v1/v2

╒═══════╕
│&quot;v1/v2&quot;│
╞═══════╡
│2      │
└───────┘
```

You can transform them to floats instead : 

```
WITH 165392 AS v1, 73693 AS v2
RETURN v1*1.0f/v2*1.0f

╒══════════════════╕
│&quot;v1*1.0f/v2*1.0f&quot; │
╞══════════════════╡
│2.2443379968246644│
└──────────────────┘
```

Which would give for you : 

```
MATCH (twtEs:Tweet)&lt;-[:HAS_WRITEN]-()-[:HAS_AS_PROFILE_LANGUAGE]-&gt;(:Language{languageCode:&#39;es&#39;})
WITH count(twtEs) AS tweetsEs 
MATCH (twtEn:Tweet)&lt;-[:HAS_WRITEN]-()-[:HAS_AS_PROFILE_LANGUAGE]-&gt;(:Language{languageCode:&#39;en&#39;})
WITH count(twtEn) as tweetsEn, tweetsEs
RETURN tweetsEs*1.0f/tweetsEn*1.0f as RatioTweetsEsvsEn;
```",0,65543124
3114,https://stackoverflow.com/a/65537627,How can I run a multiple-MATCH search without returning null?,true,"You can consider the node in the middle of the path (user or tag) as a generic object, and thus from there use a multi-relationship type pattern matching : 

````
MATCH (u:User {name: &quot;Tim Cook&quot;})
MATCH (u)-[:FOLLOWS]-&gt;(thing)-[:WROTE|TAGGED]-(p:Post)
RETURN p.name

╒════════╕
│&quot;p.name&quot;│
╞════════╡
│&quot;Post 3&quot;│
├────────┤
│&quot;Post 2&quot;│
├────────┤
│&quot;Post 1&quot;│
└────────┘
```

From there, if you want to know if the user is following the author, it&#39;s just plain logic, you return if the node in the middle is of type &#39;User&#39; (which would validate the assumption since the first relationship is FOLLOWS thing)

```
MATCH (u:User {name: &quot;Tim Cook&quot;})
MATCH (u)-[:FOLLOWS]-&gt;(thing)-[:WROTE|TAGGED]-(p:Post)
RETURN p.name, (&#39;User&#39; IN labels(thing)) AS followingAuthor

╒════════╤═════════════════╕
│&quot;p.name&quot;│&quot;followingAuthor&quot;│
╞════════╪═════════════════╡
│&quot;Post 3&quot;│true             │
├────────┼─────────────────┤
│&quot;Post 2&quot;│true             │
├────────┼─────────────────┤
│&quot;Post 1&quot;│false            │
└────────┴─────────────────┘
```


",1,65537627
3115,https://stackoverflow.com/a/65536673,How can i display the all nodes and relationships between two nodes in neo4j?,false,"With this query you can get all the relationship between two nodes
```
MATCH (n1)-[r]-&gt;(n2) 
RETURN {type: type(r), nodes: {n1: n1{.*}, n2: n2{.*}}}

OR

MATCH (n1)-[r]-&gt;(n2) 
RETURN {type: type(r), nodes: {n1: collect(distinct n1{.*}), n2: collect(distinct n2{.*})}}

```

Get employees by common properties:
```
MATCH (e:Employee)-[]-(m:Month) 
return {
  month: m.month, // You can replace it with any property you want to group for example &quot;gender: e.gender&quot;
  employees: collect(distinct e{.*})
} as byMonth
```

**EDIT**

&gt;  How to know other employees similar to the given Employee​ id. for example, I was working for a company (my age, location, year of joining as data) and I want to know the employees in the company who has similar relationships like same age, year of joining, the month of joining, location etc. w.r.t to me

Below query should work

```
match (employee:Employee) where employee.empid= 1
optional match (employee)-[:EMPLOYEE]-(month:Month{month: 10})-[:EMPLOYEE]-(other:Employee) 
optional match (other) where other.monthOfJoining = employee.monthOfJoining or other.yearOfJoining = employee.yearOfJoining or other.age = employee.age
return employee, other
```

**EDIT 2**

Get count of all common nodes related to two or more nodes

```
MATCH (node1:Employee)--&gt;(r)&lt;--(node2:Employee)

with count(r) as maxCountRelation, node1{.*} as e1, node2{.*} as e2

return {commonRelation: maxCountRelation, employees: collect(distinct e1)+collect(distinct e2)} as result order by result.commonRelation desc limit 1
```",0,65536673
3116,https://stackoverflow.com/a/65517002,neo4j cypher - Match node where another specific node of the same type doesn&#39;t exist,true,"You can a match team by name and then make sure only one team is linked to that game by specifying the number of `teamscore` relationships to that game is 1. 

    MATCH(g:game)-[:teamscore]-(t:team) 
    WHERE t.teamname = &quot;TeamA&quot; AND size((g)-[:teamscore]-(:team))=1 
    RETURN g, t",1,65517002
3117,https://stackoverflow.com/a/65518836,neo4j cypher - Match node where another specific node of the same type doesn&#39;t exist,false,"So, if the assumption is correct, there can be more than one (teamA)-[:teamscore]-&gt;(game) for the same game.

If yes, then you can make sure that all connections from game to a team node are to teamA.

Given the following graph : 

```
CREATE (g:Game {id: 1})-[:teamscore]-&gt;(:Team {id: 1, name: &quot;TeamA&quot;})
CREATE (g)-[:teamscore]-&gt;(:Team {id:2, name: &quot;TeamA&quot;})
CREATE (g)-[:teamscore]-&gt;(:Team {id:3, name: &quot;TeamA&quot;})
CREATE (g2:Game {id: 2})-[:teamscore]-&gt;(:Team {name: &quot;TeamA&quot;})
CREATE (g2)-[:teamscore]-&gt;(:Team {name: &quot;TeamB&quot;})
```

You can use pattern comprehensions and the `ALL` predicate : 

```
MATCH (n:Game)
WHERE ALL(x IN [(n)-[:teamscore]-&gt;(t) | t.name] WHERE x = &quot;TeamA&quot;)
RETURN n
```

It will return Game with id 1",0,65518836
3118,https://stackoverflow.com/a/65494609,Neo4j &gt; User-defined stored procedures: Would a stored procedure be faster than many cypher queries called from python?,false,"Well, if you can refactor your code to make one call to a stored procedure, it means you can also refactor to make one Cypher query and handle the result application side.

_Maybe_ a stored procedure will be faster since you can leverage the JVM multithreading.

However, there are some drawbacks to using stored procedures : 

 1. You need to redeploy and restart Neo4j when the code of the stored procedure changes
 2. You need to maintain it and upgrade with new Neo4j versions
 3. It implies you can write them in Java

I have rarely seen the usage of stored procedures for improving performance (it happens but it has some niche use cases).

As you stated, the bottleneck is your loop querying the db, I would try to fix that first.

Secondly, performance in Neo4j is generally handled by three major factors : 

1. Your ability to model your graph well, in order to optimise for querying
2. Your ability to tune your Cypher queries
3. Your index configuration is correct

In 99.99% of the problems you will have during your life with Neo4j will be solved by those 3 points above.",1,65494609
3119,https://stackoverflow.com/a/65483292,Neo4j loading csv for a very long time,false,"I believe you don&#39;t have indexes on both :User(name) and :Movie(movieId).

Perform the two following queries and retry your LOAD CSV command, it should then import it in a couple of seconds : 

```
CREATE CONSTRAINT ON (u:User) ASSERT u.name IS UNIQUE;
CREATE CONSTRAINT ON (m:Movie) ASSERT m.moveId IS UNIQUE;
```

Secondly, I suppose users rate a movie only once, so the MERGE of the relationship is not necessary to happen with the property, you can change your query like this : 

```
LOAD CSV WITH HEADERS FROM &quot;file:///ratings_small.csv&quot; AS line 
WITH line MERGE (u:User{name:line.userId}) 
MERGE (m:Movie {movieId:line.movieId}) 
MERGE (u)-[r:RATED]-&gt;(m)
SET r.rating = line.rating
RETURN u, m, r
```

To avoid Neo4j to try to process the full CSV in one transaction, you can [specify the batch size of transactional operations][1] (to avoid memory issues) like this : 

```
USING PERIODIC COMMIT 2000
LOAD CSV WITH HEADERS FROM &quot;file:///ratings_small.csv&quot; AS line 
WITH line MERGE (u:User{name:line.userId}) 
MERGE (m:Movie {movieId:line.movieId}) 
MERGE (u)-[r:RATED]-&gt;(m)
SET r.rating = line.rating
RETURN u, m, r
```

Lastly, I doubt you have any application or even the Neo4j browser that can visualise everything at once, so I would not return anything from the LOAD CSV query : 

```
USING PERIODIC COMMIT 2000
LOAD CSV WITH HEADERS FROM &quot;file:///ratings_small.csv&quot; AS line 
WITH line MERGE (u:User{name:line.userId}) 
MERGE (m:Movie {movieId:line.movieId}) 
MERGE (u)-[r:RATED]-&gt;(m)
SET r.rating = line.rating
```

  [1]: https://neo4j.com/docs/cypher-manual/current/clauses/load-csv/#load-csv-setting-the-rate-of-periodic-commits",2,65483292
3120,https://stackoverflow.com/a/65478344,Neo4j - Match a pattern with multiple mandetory nodes,true,"You need to collect all the tags for each post and then check if all the required tags are present in that list.

    MATCH (p:Post)-[r:HAS_TAG]-&gt;(t:Tag)  
    WITH p, collect(t.name) as tags 
    WHERE ALL(tag in [&#39;BIKES&#39;, &#39;HONDA&#39;] WHERE tag IN tags)  
    RETURN p

Reference: https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-all",1,65478344
3121,https://stackoverflow.com/a/65457406,Cypher Neo4j - Rank similar entities based on same relationships,true,"Given the following graph : 

```
CREATE (p1:P {id: &#39;p1&#39;})
CREATE (p2:P {id: &#39;p2&#39;})
CREATE (p3:P {id: &#39;p3&#39;})
CREATE (c1:C {id: &#39;c1&#39;})
CREATE (c2:C {id: &#39;c2&#39;})
CREATE (c3:C {id: &#39;c3&#39;})
CREATE (c4:C {id: &#39;c4&#39;})
CREATE (p1)-[:RELA {hasProperty: 1}]-&gt;(c1)
CREATE (p1)-[:RELA]-&gt;(c2)
CREATE (p1)-[:RELA]-&gt;(c3)
CREATE (p1)-[:RELA]-&gt;(c4)
CREATE (p2)-[:RELA {hasProperty: 1}]-&gt;(c1)
CREATE (p2)-[:RELA]-&gt;(c2)
CREATE (p2)-[:RELA]-&gt;(c3)
CREATE (p2)-[:RELA]-&gt;(c4)
CREATE (p3)-[:RELA]-&gt;(c2)
CREATE (p3)-[:RELB]-&gt;(c3)
CREATE (p3)-[:RELA]-&gt;(c4)
```


[![enter image description here][1]][1]

You can return, given p1, for each of p2, p3 two list of booleans, one for same relationship type, one for same hasProperty value : 

```
MATCH (n:P)-[r1]-&gt;(c)&lt;-[r2]-(other)
WHERE n.id = &#39;p1&#39;
WITH other.id AS otherId, 
collect(r1.hasProperty = r2.hasProperty) AS sameHasProperty, 
collect(type(r1) = type(r2)) AS sameType
RETURN *

╒═════════╤═════════════════╤═════════════════════╕
│&quot;otherId&quot;│&quot;sameHasProperty&quot;│&quot;sameType&quot;           │
╞═════════╪═════════════════╪═════════════════════╡
│&quot;p3&quot;     │[]               │[true,false,true]    │
├─────────┼─────────────────┼─────────────────────┤
│&quot;p2&quot;     │[true]           │[true,true,true,true]│
└─────────┴─────────────────┴─────────────────────┘
```

Then, you can give a score for true or false in each collection.

Let&#39;s say similar hasProperty scores 2.0 and similar relationship type scores 1.0 : 


```
MATCH (n:P)-[r1]-&gt;(c)&lt;-[r2]-(other)
WHERE n.id = &#39;p1&#39;
WITH other.id AS otherId, 
collect(r1.hasProperty = r2.hasProperty) AS sameHasProperty, 
collect(type(r1) = type(r2)) AS sameType
RETURN otherId, (size([x IN sameHasProperty WHERE x = true])*2.0 + size([x IN sameType WHERE x = true])*1.0) AS score
ORDER BY score DESC

╒═════════╤═══════╕
│&quot;otherId&quot;│&quot;score&quot;│
╞═════════╪═══════╡
│&quot;p2&quot;     │6.0    │
├─────────┼───────┤
│&quot;p3&quot;     │2.0    │
└─────────┴───────┘
```

  [1]: https://i.stack.imgur.com/VL8tZ.png",0,65457406
3122,https://stackoverflow.com/a/66893679,How to query supplementary relationship in graph?,false,"Consider the following:

```
MATCH (a:City {name: &#39;A&#39;})-[t0:intersects]-&gt;(b:City)
WITH a, collect({x:b, angle:abs(t0.degrees - 45)}) AS a_to_b
MATCH (a)&lt;-[t1:intersects]-(c:City)
WITH a_to_b, collect({x:c, angle:abs(abs(t1.degrees - 180) - 45)}) AS c_to_a
WITH a_to_b + c_to_a AS intersections
UNWIND intersections AS city
RETURN city.x ORDER BY city.angle
```",1,66893679
3123,https://stackoverflow.com/a/65454462,Neo4j get response of nested array of objects from graph,true,"Given the following graph : 

```
CREATE (g:Group {id: 21})
CREATE (p1:Process {id: 1})
CREATE (p2:Process {id: 2})
CREATE (p3:Process {id: 3})
CREATE (p4:Process {id: 4})
CREATE (e:Event {id: 1})
CREATE (g)-[:DID_PROCESS]-&gt;(p1)
CREATE (g)-[:DID_PROCESS]-&gt;(p2)
CREATE (p1)-[:SUB_PROCESS]-&gt;(p3)
CREATE (p1)-[:SUB_PROCESS]-&gt;(p4)
CREATE (p4)-[:HAS_EVENT]-&gt;(e)
```

And using pattern comprehensions ( https://neo4j.com/docs/cypher-manual/current/syntax/lists/#cypher-pattern-comprehension ) :

Retrieving the group and its processes : 

```
MATCH (g:Group {id: 21})
RETURN {
processes: [(g)-[:DID_PROCESS]-&gt;(process) | process{.*}]
}

---

{
  &quot;processes&quot;: [
    {
      &quot;id&quot;: 2
    },
    {
      &quot;id&quot;: 1
    }
  ]
}
```

Extending with the same manner, for processes to include their subprocesses : 

```
MATCH (g:Group {id: 21})
RETURN {
processes: [(g)-[:DID_PROCESS]-&gt;(process) | 
	{
     node: process{.*}, 
     subprocesses: [(process)-[:SUB_PROCESS]-&gt;(sub) | sub{.*}]
    }
  ]
}


---

{
  &quot;processes&quot;: [
    {
      &quot;node&quot;: {
&quot;id&quot;: 2
      },
      &quot;subprocesses&quot;: []
    },
    {
      &quot;node&quot;: {
&quot;id&quot;: 1
      },
      &quot;subprocesses&quot;: [
        {
          &quot;id&quot;: 4
        },
        {
          &quot;id&quot;: 3
        }
      ]
    }
  ]
}
```

And finally, extend it for subprocesses to retrieve their events : 

```
MATCH (g:Group {id: 21})
RETURN {
processes: [(g)-[:DID_PROCESS]-&gt;(process) | 
	{
     node: process{.*}, 
     subprocesses: [(process)-[:SUB_PROCESS]-&gt;(sub) | 
          {node: sub{.*}, events: [(sub)-[:HAS_EVENT]-&gt;(event) | event{.*}]}
       ]
    }
  ]
}

---

{
  &quot;processes&quot;: [
    {
      &quot;node&quot;: {
&quot;id&quot;: 2
      },
      &quot;subprocesses&quot;: []
    },
    {
      &quot;node&quot;: {
&quot;id&quot;: 1
      },
      &quot;subprocesses&quot;: [
        {
          &quot;node&quot;: {
&quot;id&quot;: 4
          },
          &quot;events&quot;: [
            {
              &quot;id&quot;: 1
            }
          ]
        },
        {
          &quot;node&quot;: {
&quot;id&quot;: 3
          },
          &quot;events&quot;: []
        }
      ]
    }
  ]
}
```
",1,65454462
3124,https://stackoverflow.com/a/65478228,CSV data Import into neo4j,false,"You need to get your data into a proper csv format first. That means something like this:
[![proper csv format][1]][1]

Once you have that you can easily do something like

&gt; load csv from &lt;&lt;file uri&gt;&gt; as csv
&gt; merge (n1:Node {name: csv.start})
&gt; merge (n2:Node {name: csv.end})
&gt; merge (n1)-[:CONNECTED_TO]-&gt;(n2);

Maybe you can try that?

  [1]: https://i.stack.imgur.com/AgrSz.png",0,65478228
3125,https://stackoverflow.com/a/65432430,how to calculate a distinct count for nodes,true,"You can use the path pattern to get contributors for each article, and then aggregate by author:

    MATCH (author:Author)-[:WRITES]-&gt;(article:Article)&lt;-[:WRITES]-(coauthor:Author)
    WITH author, 
         size(collect(distinct coauthor)) as numberofcollaborations 
         ORDER BY numberofcollaborations 
         DESC LIMIT 5
    RETURN author.name as author, 
           numberofcollaborations",1,65432430
3126,https://stackoverflow.com/a/65425891,Neo4j Cypher : return nodes with id as a dictionary,true,"It&#39;s not possible with the default Cypher syntax, however if you have the apoc library installed, you can do this : 

```
MATCH (n:A)
RETURN apoc.map.setKey({}, n.id, n{.*})
```",2,65425891
3127,https://stackoverflow.com/a/65421880,Is there a way to preform calculations in a cypher query?,true,"This is pretty easy in Cypher and is for sure documented in a lot of places.

Here a couple of examples : 

Finding users like Bob, based on similar skills, order by sum of skill importance on the skill node : 

```
MATCH (n:User {name: &#39;Bob&#39;})-[:HAS_SKILL]-&gt;(skill)&lt;-[:HAS_SKILL]-(otherUser)
RETURN otherUser.name AS name, sum(skill.score) AS score
ORDER BY score DESC
```

In some graph models, each user can be associated a score to each skill, in which case the score would be on the relationship between the user and the skill, you can then sum up those as well : 

```
MATCH (n:User {name: &#39;Bob&#39;})-[r1:HAS_SKILL]-&gt;(skill)&lt;-[r2:HAS_SKILL]-(otherUser)
RETURN otherUser.name AS name, sum(r1.score + r2.score) AS score
ORDER BY score DESC
```",0,65421880
3128,https://stackoverflow.com/a/65397277,How to delete large amount of relationships in cypher?,true,"Based on [the documentation][1], I think the call should rather be like this:

    CALL apoc.periodic.iterate(&#39;MATCH (:CAR)-[r:REL_NAME]-&gt;() RETURN r&#39;, &#39;DELETE r&#39;, {batchSize:50000})

The first statement is run in batch and produces relationships.
The second statement is applied to every produced relationship.

Note: labels usually follow the PascalCase convention (`CAR` should be `Car`).


  [1]: https://neo4j.com/labs/apoc/4.1/graph-updates/periodic-execution/",1,65397277
3129,https://stackoverflow.com/a/65397113,query to copy a node with relations in neo4j without the clone procedure,true,"The easiest way is to [install the APOC library][1], and call the procedure `apoc.refactor.cloneNodesWithRelationships`, as documented [here][2].

In your case, your query would become:

    MATCH (map:student {name:&#39;test&#39;})
    CALL apoc.refactor.cloneNodesWithRelationships([map])

Note: node labels usually start with an upper letter (`Student` is more common than `student` in Neo4j datasets).


  [1]: https://neo4j.com/labs/apoc/4.2/installation/
  [2]: https://neo4j-contrib.github.io/neo4j-apoc-procedures/3.5/graph-refactoring/clone-nodes/",2,65397113
3130,https://stackoverflow.com/a/65383754,How to take specific char from csv file?,false,"I have copied your CSV content and put it in a `data.csv` file and tried to treat it as a `tsv` format, which didn&#39;t work since probably the separating characters are not tabs.

Loading the file as CSV in the browser output the following as rows : 

```
LOAD CSV FROM &quot;file:///data.csv&quot; AS row
RETURN row

╒══════════════════════╕
│&quot;row&quot;                 │
╞══════════════════════╡
│[&quot;1001   9910248&quot;]    │
├──────────────────────┤
│[&quot;1001   9910268&quot;]    │
├──────────────────────┤
│[&quot;9304045    9204040&quot;]│
├──────────────────────┤
│[&quot;9308122    9203084&quot;]│
├──────────────────────┤
│[&quot;9308122    9204035&quot;]│
├──────────────────────┤
│[&quot;9308122    9205041&quot;]│
└──────────────────────┘
```

Which means that there is only one column.

We can then split the cell elements on a whitespace character : 

```
LOAD CSV FROM &quot;file:///data.csv&quot; AS row
RETURN row[0], split(row[0], &quot; &quot;)

Text
Code
╒════════════════════╤══════════════════════════════╕
│&quot;row[0]&quot;            │&quot;split(row[0], &quot; &quot;)&quot;          │
╞════════════════════╪══════════════════════════════╡
│&quot;1001   9910248&quot;    │[&quot;1001&quot;,&quot;&quot;,&quot;&quot;,&quot;9910248&quot;]      │
├────────────────────┼──────────────────────────────┤
│&quot;1001   9910268&quot;    │[&quot;1001&quot;,&quot;&quot;,&quot;&quot;,&quot;9910268&quot;]      │
├────────────────────┼──────────────────────────────┤
│&quot;9304045    9204040&quot;│[&quot;9304045&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;9204040&quot;]│
├────────────────────┼──────────────────────────────┤
│&quot;9308122    9203084&quot;│[&quot;9308122&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;9203084&quot;]│
├────────────────────┼──────────────────────────────┤
│&quot;9308122    9204035&quot;│[&quot;9308122&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;9204035&quot;]│
├────────────────────┼──────────────────────────────┤
│&quot;9308122    9205041&quot;│[&quot;9308122&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;9205041&quot;]│
└────────────────────┴──────────────────────────────┘
```

As you can see, there is more than one whitespace between the ids in each cell, which results in arrays of elements with different sizes.

The solution is to take the first and last elements of each collection : 

```
LOAD CSV FROM &quot;file:///data.csv&quot; AS row
WITH split(row[0], &quot; &quot;) AS elements
RETURN head(elements) AS article1, last(elements) AS article2

╒══════════╤══════════╕
│&quot;article1&quot;│&quot;article2&quot;│
╞══════════╪══════════╡
│&quot;1001&quot;    │&quot;9910248&quot; │
├──────────┼──────────┤
│&quot;1001&quot;    │&quot;9910268&quot; │
├──────────┼──────────┤
│&quot;9304045&quot; │&quot;9204040&quot; │
├──────────┼──────────┤
│&quot;9308122&quot; │&quot;9203084&quot; │
├──────────┼──────────┤
│&quot;9308122&quot; │&quot;9204035&quot; │
├──────────┼──────────┤
│&quot;9308122&quot; │&quot;9205041&quot; │
└──────────┴──────────┘
```

You can now use these ids to merge articles and the cites relationship : 

```
LOAD CSV FROM &quot;file:///data.csv&quot; AS row
WITH split(row[0], &quot; &quot;) AS elements
WITH head(elements) AS article1, last(elements) AS article2
MERGE (a1:Article {id: article1})
MERGE (a2:Article {id: article2})
MERGE (a1)-[:CITES]-&gt;(a2)
```

[![enter image description here][1]][1]

In case you would like to treat ids as numbers, you need to cast it to integers : 

```
LOAD CSV FROM &quot;file:///data.csv&quot; AS row
WITH split(row[0], &quot; &quot;) AS elements
WITH head(elements) AS article1, last(elements) AS article2
MERGE (a1:Article {id: toInteger(article1)})
MERGE (a2:Article {id: toInteger(article2)})
MERGE (a1)-[:CITES]-&gt;(a2)
```

---

*EDIT* based on the given CSV file on Github

This CSV file could be parsed as TSV, the heap issue is probably because you don&#39;t have an index on `:Article(id)`, so start with that : 

```
CREATE INDEX ON :Article(id)
```

Then you can load as TSV file directly from Github (it completed in 6 seconds on my laptop) : 

```
LOAD CSV FROM &quot;https://raw.githubusercontent.com/anpetsa/neo4j/main/Citations.csv&quot; AS row
WITH split(row[0], &quot; &quot;) AS elements
WITH head(elements) AS article1, last(elements) AS article2
MERGE (a1:Article {id: toInteger(article1)})
MERGE (a2:Article {id: toInteger(article2)})
MERGE (a1)-[:CITES]-&gt;(a2)
```

[![enter image description here][2]][2]


  [1]: https://i.stack.imgur.com/0AEZk.png
  [2]: https://i.stack.imgur.com/D43PZ.png",1,65383754
3131,https://stackoverflow.com/a/65373298,Simple but very long request,true,"First improvement you can do is to create an index on :Alias(name) , you will see already a crazy difference in the query : 

```
CREATE INDEX ON :Alias(name);
```",3,65373298
3132,https://stackoverflow.com/a/65373231,How can I call this APOC procedure selectively? (only on a subset of nodes),true,"The procedure itself does not allow you to pass such filters. There are however two possibilities to circumvent this : 

1. build the virtual graph yourself with vNode and vRelationship
2. set a temporary label after your node selection and group on that

I will focus on option 2 : 

Take the following graph as an example : 

```WITH [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] AS items
UNWIND range(1, 200) AS i
CREATE (n:com)
SET n.timestamp = i, 
n.key = apoc.coll.randomItem(items)
```

And let&#39;s say I have an hypothetical window to use that is `30 to 70`, I can find only the nodes matching my window predicate : 

```
WITH [30, 70] AS window
MATCH (n:com) 
WHERE n.timestamp &gt; window[0] 
AND n.timestamp &lt; window[1]
RETURN count(n)

╒══════════╕
│&quot;count(n)&quot;│
╞══════════╡
│39        │
└──────────┘
```

Before jumping in the grouping query, I just want to show that you can set a label and remove it in the same query, using the predicate.

```
WITH [30, 70] AS window
MATCH (n:com) 
WHERE n.timestamp &gt; window[0] 
AND n.timestamp &lt; window[1]
SET n:temporary
WITH count(n) AS doSomething
MATCH (n:temporary)
REMOVE n:temporary
WITH count(*) AS break, doSomething
RETURN doSomething
```

The last `WITH count(*)` is necessary to not return one row per temporary node.

Now, using this logic, we can : 

1. `MATCH` nodes using the window predicate
2. Assign them a new `temporary` label
3. Use `apoc.nodes.group` on the `temporary` label instead
4. Remove the `temporary` label
5. Return the grouped nodes

```
WITH [30, 70] AS window
MATCH (n:com) WHERE n.timestamp &gt; window[0] AND n.timestamp &lt; window[1]
SET n:temporary
WITH window, count(*) AS x
CALL apoc.nodes.group([&#39;temporary&#39;], [&#39;key&#39;], null, {})
YIELD node, relationship
WITH collect(node) AS elements
MATCH (n:temporary) REMOVE n:temporary
WITH count(*) AS break, elements
UNWIND elements AS element
RETURN element

╒════════════════════════╕
│&quot;element&quot;               │
╞════════════════════════╡
│{&quot;count_*&quot;:6,&quot;key&quot;:&quot;f&quot;} │
├────────────────────────┤
│{&quot;count_*&quot;:6,&quot;key&quot;:&quot;e&quot;} │
├────────────────────────┤
│{&quot;count_*&quot;:12,&quot;key&quot;:&quot;d&quot;}│
├────────────────────────┤
│{&quot;count_*&quot;:1,&quot;key&quot;:&quot;c&quot;} │
├────────────────────────┤
│{&quot;count_*&quot;:5,&quot;key&quot;:&quot;b&quot;} │
├────────────────────────┤
│{&quot;count_*&quot;:9,&quot;key&quot;:&quot;a&quot;} │
└────────────────────────┘
```

[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/A6318.png",0,65373231
3133,https://stackoverflow.com/a/65362602,How connect Result nodes Neo4j,false,"For anyone who falls into the same problem. The answer is a subquery which checks if node ids are in the original set. In the first query you return a list of node ids using the built in ID function, then collect the nodes. In the subquery you unwind the nodes and in the subquery where clause filter the using the list of IDs.

    Match (b:User)
    where b.Verified = &#39;false&#39; and b.followers &gt; 60
    with collect(b) as users, collect(ID(b)) as listUsers
    CALL{
      with users,listUsers
      unwind users as x
      match(x)-[r]-(c:User)
      where ID(c) in listUsers
      return x,r,c
      }
    return x,r,c",0,65362602
3134,https://stackoverflow.com/a/65331781,Checking every relationship of a path triggers way too many dbhits,false,"Not sure this is the correct answer, but I added a WITH statement

    PROFILE 
    MATCH path = (u:user { _id: &#39;ea6b17e0-3b9e-11ea-b206-e7610aa23593&#39; })-[r:accessRole|isMemberOf*1..5]-&gt;(n:PermissionSet { name: &#39;project&#39;})
    WITH path,r
    WHERE all(x IN r WHERE NOT (:PermissionSet)-[x]-&gt;(:user))
    RETURN path

And the dbhits for &quot;(:PermissionSet)-[x]-&gt;(:user)&quot; went down to 2800 hits.

I can guess why it does that, but I&#39;d love some more experts explanations, and is there a better way to do it? (this way is fine with me performance-wise)",0,65331781
3135,https://stackoverflow.com/a/65364845,Forming relationships among Null nodes in neo4j,false,"Before loading you should assign a unique identifier for each node, if they don&#39;t already have a data domain unique identifier.  You should then use that identifier to load the relationships...  

The long answer:  Technically speaking, it may be possible to load null nodes AND in the SAME cypher use the internally assigned identifiers for the nodes to load the relationships.  If and only if this is all completed in the same cypher because there is no way to find the right null node once loaded, right?.  

Neo4j assigns an internal unique identifier to every node, but direct use of the internal ids in any cypher query is strongly discouraged. (for a number of reasons, but in short, because they are not guaranteed to remain fixed)",0,65364845
3136,https://stackoverflow.com/a/65393198,Forming relationships among Null nodes in neo4j,false,"Let&#39;s assume that the values in the cells of the lines are the unique identifiers of the nodes by the &quot;id&quot; property. And so far there are no nodes in the database (then we can use MERGE, but if there are nodes, we can use MATCH).

Then we need to remove empty elements from each line, and iterate over the elements in the line in pairs:

    LOAD CSV FROM &#39;file:///data.csv&#39; AS line

    // Skip line with headers
    WITH line WHERE linenumber() &gt; 1

    // Remove null items from the lines
    WITH [n IN line WHERE n IS NOT NULL] AS line

    // Iterate over all elements of the line except the last
    UNWIND range(0, size(line) - 2) AS i

      // Create or find the first element in a pair
      MERGE (N1 {id: line[i]}) 

      // Create or find the second element in a pair:
      MERGE (N2 {id: line[i + 1]})

      // Creates or finds a relationship between the elements of a pair
      MERGE (N1)-[R:next]-&gt;(N2)

    RETURN N1, R, N2",0,65393198
3137,https://stackoverflow.com/a/65301868,Export data from Neo4j Sandbox,true,"If the data is not consequent ( for eg. the size of the movies database ), you can export to cypher statements to the browser directly by specifying `null` for the `file` option value : 

```
CALL apoc.export.cypher.all(null, {format: &#39;plain&#39;})
YIELD cypherStatements
RETURN cypherStatements
```

Then copy the result ( without the enclosing `&quot;` )

[![enter image description here][1]][1]


And paste it in another Neo4j browser, click on the `Run` button, and it&#39;s done.

[![enter image description here][2]][2]


  [1]: https://i.stack.imgur.com/uhIV2.jpg
  [2]: https://i.stack.imgur.com/KwLHE.png",4,65301868
3138,https://stackoverflow.com/a/65286627,Removing redundant Nodes from the relationship,false,"You should be able to create the relationships at import time.

First trick is to remove the extraneous spaces in the header name for easier import, i.e.:

    CaseID, name, child, parent

should become:

    CaseID,name,child,parent

To make sure the subsequent `MERGE` statements can run fast:

    CREATE INDEX FOR (a:Activity) ON (a.name)

Then the import can become (tailor the `dbms.directories.import` and `dbms.security.allow_csv_import_from_file_urls` settings to your needs):

    LOAD CSV WITH HEADERS FROM &quot;file:///path/to/import.csv&quot; AS row
    MERGE (child:Activity {name: trim(row.child)})
    MERGE (parent:Activity {name: trim(row.parent)})
    MERGE (parent)-[:PRODUCES]-&gt;(child)

However, the way the import is written, it will handle the `null` entries as the string `&quot;null&quot;`. To keep things simple, you can just run an extra query *at the end* just to remove that node and its relationships:

    MATCH (a:Activity {name: &quot;null&quot;}) DETACH DELETE a

The data should now be like you want it.",0,65286627
3139,https://stackoverflow.com/a/65276118,How do I group nodes by a different node property and order by a different one in Neo4j?,true,"How about something like this:

    MATCH (c:Crime)
    WITH c.year AS year, c.offense_code_group AS code, count(c.offense_code_group) AS count
    ORDER BY year, count DESC
    WITH year, COLLECT(code) AS codes, COLLECT(count) AS counts
    RETURN year, codes[0], counts[0]",1,65276118
3140,https://stackoverflow.com/a/65266276,Neo4j query to get a document with no parent,false,"This can be achieved with a simple `WHERE` clause:

    MATCH (d:Document)
    WHERE NOT (d)-[:HAS_PARENT]-&gt;(:Document)
    RETURN d",0,65266276
3141,https://stackoverflow.com/a/65255203,Separating matching nodes in a query result,false,"`MATCH` clauses are more flexible than that. Try this:
```
MATCH (n:Person)-[:Know]-&gt;(m:Person)&lt;-[:Know]-(p:Person)-[:Know]-&gt;(n)
WHERE NOT EXISTS (()-[:Know]-&gt;(p))
    AND NOT EXISTS {
        WITH m, n, p
        MATCH (q:Person)-[:Know]-&gt;(m)
        WHERE q &lt;&gt; n 
            AND q &lt;&gt; p
    }
    AND NOT EXISTS {
        WITH m, n, p
        MATCH (q:Person)-[:Know]-&gt;(n)
        WHERE q &lt;&gt; p
    }
RETURN m, n, p
```
You might have to use a unique ID property, and I&#39;m not sure if the `WITH` clause will work here as I&#39;ve gotten it; but with subqueries, you are generally able to import variables from above using `WITH`. ",0,65255203
3142,https://stackoverflow.com/a/65242752,How to loop throught a list property in each node and see if it appears in other node property?,true,"You can get all articles topics then for each topic, find the corresponding topic node. Create a relationship CONNECTED_TO (or create your own name).


    MATCH (a:ARTICLE)
    UNWIND a.topics as articleTopic
    MATCH (t:TOPICS {topic: articleTopic})
    MERGE p=(a)-[:CONNECTED_TO]-&gt;(t)
    RETURN p

Sample result:
[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/81sD5.png",1,65242752
3143,https://stackoverflow.com/a/65227323,Neo4j Cypher query to fetch posts created by followers,false,"Your [WITH](https://neo4j.com/docs/cypher-manual/current/clauses/with/) clauses are not specifying all the variables that need to be carried forward to the remainder of the query. Also, there has at least one typo (a missing comma).

In fact, your query does not even need any `WITH` clauses. Nor does it need to `COLLECT` a list only to immediately `UNWIND` it.

This query should work better:

    MATCH (user:User{lastName: &quot;mylastname&quot;})-[:FOLLOWS {status: &quot;accepted&quot;}]-&gt;(following)
    OPTIONAL MATCH (post:Post {type: &quot;PRODUCT&quot;})-[r:CREATED_BY]-&gt;(following)
    OPTIONAL MATCH (post)-[:INCLUDES]-&gt;(product:Product)
    RETURN {post:post, datetime: r.datetime, type:&quot;PRODUCT&quot;, product:product, user: following} AS row
    ORDER BY row.datetime DESC
    LIMIT 10
",1,65227323
3144,https://stackoverflow.com/a/65224882,Case insensitive parameter match,true,"Did you try something like:

    MATCH (n:Person) 
    WITH n 
    MATCH (p:Pet)
    WHERE toLower(n.name) = toLower(p.owner)
    RETURN *",2,65224882
3145,https://stackoverflow.com/a/65227595,Case insensitive parameter match,false,"### Option 1 - Convert the relevant strings to lower-case while importing into the DB

This would allow you to keep using the existing query with less processing.

NOTE: the following query is a more concise form of your query. Also, you should consider creating an [index](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/) on `:Pet(owner)` to fully optimize the query.

    MATCH (n:Person), (p:Pet {owner: n.name})
    RETURN *

### Option 2 - Use a case-insensitive regular expression

If you cannot alter the imported strings for some reason, then you can use Cypher&#39;s support for [case-insensitive regular expressions](https://neo4j.com/docs/cypher-manual/current/clauses/where/#case-insensitive-regular-expressions), as in:

    MATCH (n:Person), (p:Pet)
    WHERE n.name =~ &#39;(?i)&#39; + p.owner
    RETURN *

This option would be *significantly* slower than Option 1, since it cannot take advantage of indexing, and requires expensive text processing for *each and every pair* of `Person` and `Pet` nodes.",0,65227595
3146,https://stackoverflow.com/a/65228877,Creating many relationships in one script,false,"By default, Neo4j Browser only allows one Cypher statement to be executed at a time. This can be changed by going to the browser settings on the sidebar (gear icon), and then checking the `Enable multi statement query editor` checkbox. Afterward, you should be able to execute multiple Cypher statements on the query editor.",0,65228877
3147,https://stackoverflow.com/a/65217579,What would be a good query to recommend artists to a user?,false,"Managed to figure it out by myself.

```
MATCH (user:USER)-[:FOLLOWS]-&gt;(followedUser:USER)-[:LIKES]-&gt;(artist:ARTIST)
WHERE NOT (user)-[:LIKES]-&gt;(artist)
RETURN artist",0,65217579
3148,https://stackoverflow.com/a/65201630,Neo4j: how to avoid node to be created again if it is already in the database?,false,"Use `MERGE` instead of `CREATE`. You can use it for both nodes and relationships.
```
MERGE (charlie { name: &#39;Charlie Sheen&#39;, age: 10 })
```
Create a single node with properties where not all properties match any existing node.


```
MATCH (a:Person {name: &quot;Martin&quot;}),
      (b:Person {name: &quot;Marie&quot;})
MERGE (a)-[r:LOVES]-&gt;(b)
```
Finds or creates a relationship between the nodes.
",0,65201630
3149,https://stackoverflow.com/a/65207377,Neo4j: how to avoid node to be created again if it is already in the database?,true,"A [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) clause will **create** its entire pattern if *any* part of it does not already exist. So, for a `MERGE` clause to work reasonably, the pattern used with it must only specify the *minimum* data necessary to uniquely identify a node (or a relationship).

For instance, assuming `ARTICLE` nodes are supposed to have unique `id` properties, then you should replace your `CREATE` clause:

    CREATE (a:ARTICLE {id:$id, title:$title, img_url:$img_url, link:$link, sentence:$sentence, published:$published})

with something like this:

    MERGE (a:ARTICLE {id:$id})
    SET a += {title:$title, img_url:$img_url, link:$link, sentence:$sentence, published:$published}

In the above example, the `SET` clause will always overwrite the non-`id` properties. If you want to set those properties only when the node is created, you can use [ON CREATE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/#merge-merge-with-on-create) before the `SET` clause.",1,65207377
3150,https://stackoverflow.com/a/65199064,How to find the head of a series of connected nodes in Neo4j with Cypher?,false,"Turned out the answer is extremely easy...thanks to @tomasi from the Neo4j Slack Group.

Here in case anyone needs it:

```
MATCH (n:Label)
WHERE NOT ()-[:RELATIONSHIP]-&gt;(n)
RETURN n
```
",0,65199064
3151,https://stackoverflow.com/a/65256921,Export/Dump database in neo4j?,false,"In Neo4j Desktop 1.3.11 you can click on the dot dot dot in the top right (database must be stopped first), and choose the option *Dump* (my test named the file movie-database-neo4j-2020-12-11T184026.dump)
 
[![enter image description here][1]][1]

Note:  You will probably have to search your disk (for *.dump) to find where the files drop, on Macintosh I found them in an unexpected folder location, they were placed with the Project instead of in the database&#39;s dump folder whereI expected them to fall out.

I found my dumps over in here
[![enter image description here][2]][2]

I tried changing the config and created data/dumps/ folder in the database area but it still sends them to the project area.  YMMV


  [1]: https://i.stack.imgur.com/xN8Qh.png
  [2]: https://i.stack.imgur.com/vzXBs.png",0,65256921
3152,https://stackoverflow.com/a/65169945,Cypher path thorugh only list of nodes,true,"I managed to do it with the following query:
```
MATCH (n:START)&lt;-[:PART_OF]-(reg:Region)&lt;-[:DEPENDS_ON]-(nd:END)
WHERE reg.name &lt;&gt; &quot;a&quot; AND reg.name &lt;&gt; &quot;b&quot;
WITH COLLECT(nd) as unaffected
MATCH (affected:END)
WHERE NOT affected in unaffected
RETURN affected
```",1,65169945
3153,https://stackoverflow.com/a/65112855,How optimised is this Cypher query?,false,"I strongly recommend that you come up with a node property that is guaranteed to be the same on all the nodes in a contiguous tree, if you don&#39;t have one already. I&#39;ll call that property `same_prop`. Here&#39;s what I do to run queries like the one you&#39;re running:

 1. Index `same_prop`. If you have different node labels, then you need this index created for each different node label you expect to have in the tree. 
`CREATE INDEX samepropnode FOR (n:your_label) ON (n.same_prop)`
is the kind of thing you need in Neo4j 4+. In Neo4j, indices are cheap, and can sometimes speed up queries quite a bit.

 2. Collect all possible values of `same_prop` and store them in a text file (I use tab-separated values as safer than comma-separated values). 

 3. Use the Python driver, or your language of choice that has a Neo4j driver written (strongly recommend Neo4j-provided drivers, not third-party) to write wrapper code that executes a Cypher query something like this:
```
MATCH (p)--&gt;(c)
USING INDEX p:your_label(same_prop)
WHERE p.same_prop IN [ same_prop_list ]
RETURN DISTINCT
    p.datapiece1 AS `first_parent_datapiece`,
    p.datapiecen AS `nth_parent_datapiece`,
    c.datapiece1 AS `first_child_datapiece`,
    c.datapiecen AS `nth_child_datapiece`
```
It&#39;s not a good idea, in general, to return nodes and relationships unless you&#39;re debugging. 

Then in your Python (for example) code, you&#39;re simply going to read in all your `same_prop` values from the file you got in Step 2, chunk up the values in reasonable size chunks, maybe 1,000 or 10,000, and substitute them in for the `[ same_prop_list ]` in the Cypher query on-the-fly. ",0,65112855
3154,https://stackoverflow.com/a/65113927,Cypher: Correlated variables in Union,true,"Using a UNION:

    // Top 3 cities
    MATCH (t:Store)&lt;-[:HasStore]-(s:Sales)
    RETURN t.StoreCity AS StoreCity, sum(s.StoreSales) AS StoreSales
    ORDER BY sum(s.StoreSales) DESC LIMIT 3
    // All other cities
    UNION
    MATCH (t:Store)&lt;-[:HasStore]-(s:Sales)
    WITH t.StoreCity, sum(s.StoreSales) AS AllStoreSales
    ORDER BY AllStoreSales DESC SKIP 3
    RETURN &quot;Other cities&quot; AS StoreCity, sum(AllStoreSales) AS StoreSales

The UNION runs two distinct queries, so before the UNION we find the top three selling cities and return their names and counts, as you had originally

After the UNION, the same basic query is run again to find the sum of sales by city, ordered by descending sales, then the top three results are skipped. The remaining city&#39;s sales are summed and returned as **Other cities**.

The two parts of the UNION are completely separate, but both queries have to return the same number of columns with the same column names and in the same column order.",1,65113927
3155,https://stackoverflow.com/a/65099541,Union of queries depending on variable in list,false,"I believe what you&#39;re looking at is `UNWIND` : 

```
UNWIND [&#39;Canada&#39;,&#39;Europe&#39;] AS location
&lt;query with location&gt;
RETURN value
```",1,65099541
3156,https://stackoverflow.com/a/65093098,Questions with multiple matches in the same Cypher query,true,"A good approach when chaining more `MATCH` clauses is to use `WITH` statement that separates query parts explicitly, allowing you to declare which variables to carry over to the next part.

In your case:

    MATCH (p:Person)&lt;-[:manages]-(n:Person)
    WHERE n.name = &quot;Michael Scott&quot;
    WITH count(p) AS countP
    MATCH (q:Person)&lt;-[:manages]-(m:Person)
    WHERE m.name = &quot;Jim Halpert&quot;
    RETURN countP &gt; count(q)
",1,65093098
3157,https://stackoverflow.com/a/65095119,Questions with multiple matches in the same Cypher query,false,"The two matches in your query are forming a catrtesian product, returning one **p** for each **q** (1 x 8). If you substitute **Darryl Philbin** for **Jim Halpert** you will appear to get 24 counts for each **p** and **q** (3 x 8).

You will see what&#39;s happening more clearly if you run:

    MATCH (p:Person)&lt;-[:manages]-(n:Person)
    WHERE n.name = &quot;Michael Scott&quot;
    MATCH (q:Person)&lt;-[:manages]-(m:Person)
    WHERE m.name = &quot;Jim Halpert&quot;
    RETURN p.name, q.name

As Lukasmp3 says, introducing a WITH breaks the query into two distinct parts and stops the catresian product from forming, you&#39;ll then get the expected answer.",2,65095119
3158,https://stackoverflow.com/a/65094892,How do I use a python variable value to name a new node created in neo4j,false,"I believe this could help you:

    playername = &#39;Joe&#39;
    username = &#39;Martin&#39;

    tx.run(&quot;CREATE (n:Player) SET n.playername = $playernamePar&quot;, playernamePar=playername)
    tx.run(&quot;CREATE (n:User) SET n.username = $usernamePar&quot;, usernamePar=username)
    tx.run(&quot;MATCH (p:Player),(u:User) 
            WHERE p.playername = $playernamePar 
            AND u.username = $usernamePar 
            CREATE (p)-[:inTeam]-&gt;(u)&quot;,
            playernamePar=playername, usernamePar=username)",1,65094892
3159,https://stackoverflow.com/a/65064647,neo4j shortest path with common relation property,false,"Assuming your property on the relationship is called `filter`, you can define an ALL predicate that will check the all the relationship properties filter in the path have the same value than the first relationship property : 

```
MATCH (p1:Node {value: &quot;a&quot;})
MATCH (p2:Node {value: &quot;b&quot;})
MATCH path=shortestPath((p1)-[r*]-(p2))
WHERE ALL( x IN relationships(path) 
      WHERE x.filter = head(relationships(path)).filter
    )
RETURN path
```",0,65064647
3160,https://stackoverflow.com/a/65071538,neo4j shortest path with common relation property,true,"I found the answer and the answer was:

    Match (a:node)-[r1]-&gt;()
    with collect(r1.property) as m
    MATCH p=shortestPath( (a:node)-[:r1*]-&gt;(e:node) ) 
    
    AND ALL(x in relationships(p) WHERE x.propery in m)
    RETURN p


",0,65071538
3161,https://stackoverflow.com/a/65067725,cypher aggregating common node type between two distinct node types,true,"The way to do this is to do the edge matching into the same line as the API MATCH:

```
MATCH (w1)
MATCH (w1)-[awe:ACCESSES_WORKLOAD]-&gt;(w2 {deleted_time: -1})
OPTIONAL MATCH (w2)-[:CONTAINS_API]-&gt;(a:API)&lt;-[:ACCESSES_API]-(w1)
OPTIONAL MATCH (w1)-[cae:CAUSES_ATTACK]-&gt;(a)
WHERE ID(w1) IN %s
RETURN DISTINCT awe, w1, w2, collect(ID(a)), collect(distinct cae.name)
```",0,65067725
3162,https://stackoverflow.com/a/65006034,neo4j: Get last node in a path,false,"You can use [variable-length relationship patterns][1] such as:

```
MATCH path=(:Days)&lt;-[:prevDay*]-(lastDay:Days)
WITH lastDay
ORDER BY LENGTH(path) DESC
LIMIT 1
RETURN lastDay
```


  [1]: https://neo4j.com/docs/cypher-manual/current/clauses/match/#varlength-rels",0,65006034
3163,https://stackoverflow.com/a/65006275,neo4j: Get last node in a path,true,"I would do something like this:


    MATCH path=(:Days {name:&#39;Day 1&#39;})&lt;-[:prevDay*]-(lastDay:Days)
    WHERE NOT (lastDay)&lt;-[:prevDay]-()
    RETURN lastDay

",2,65006275
3164,https://stackoverflow.com/a/65012824,Neo4j path query / sorting properties in path,true,"You can access the elements of the path and get the attributes one at a time. It is quite tedious but it gets the work done.

elements[index] is starting node; elements[index+1] is relationship and elements[index+2] is the ending node.
ID(node) is the node id and type(node) is the relationship type

    MATCH path=shortestPath((p1:Person)-[*0..15]-(p2:Person)) 
    WHERE toLower(p1.name) = toLower(&#39;Halle Berry&#39;) AND toLower(p2.name) = toLower(&#39;Tom Hanks&#39;) 
    WITH apoc.path.elements(path) AS elements, nodes(path) AS nodes
    UNWIND range(0, size(elements)-2) AS index
    WITH nodes, elements, index WHERE index %2 = 0
    WITH nodes, ID(elements[index]) AS start, ID(elements[index+1]) AS identity, ID(elements[index+2]) AS end, type(elements[index+1]) as type, elements[index+1] as roles
    UNWIND roles as role
    WITH nodes, start, end, identity, type, apoc.coll.sort(role.roles) as roles
    RETURN collect({start: start, end: end, identity: identity, type: type, properties: {roles: roles}}) as relationships, nodes

    RESULT:
    ╒══════════════════════════════════════════════════════════════════════╤══════════════════════════════════════════════════════════════════════╕
    │&quot;relationships&quot;                                                       │&quot;nodes&quot;                                                               │
    ╞══════════════════════════════════════════════════════════════════════╪══════════════════════════════════════════════════════════════════════╡
    │[{&quot;identity&quot;:139,&quot;start&quot;:106,&quot;end&quot;:105,&quot;type&quot;:&quot;ACTED_IN&quot;,&quot;properties&quot;:│[{&quot;name&quot;:&quot;Halle Berry&quot;,&quot;born&quot;:1966},{&quot;title&quot;:&quot;Cloud Atlas&quot;,&quot;tagline&quot;:&quot;│
    │{&quot;roles&quot;:[&quot;Jocasta Ayrs&quot;,&quot;Luisa Rey&quot;,&quot;Meronym&quot;,&quot;Ovid&quot;]}},{&quot;identity&quot;:1│Everything is connected&quot;,&quot;released&quot;:2012},{&quot;name&quot;:&quot;Tom Hanks&quot;,&quot;born&quot;:1│
    │37,&quot;start&quot;:105,&quot;end&quot;:71,&quot;type&quot;:&quot;ACTED_IN&quot;,&quot;properties&quot;:{&quot;roles&quot;:[&quot;Derm│956}]                                                                 │
    │ot Hoggins&quot;,&quot;Dr. Henry Goose&quot;,&quot;Isaac Sachs&quot;,&quot;Zachry&quot;]}}]              │                                                                      │
    └──────────────────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────────────────────┘

====EDITED===
You can UNWIND the roles then sort it.  Lastly, collect them again as a list of dictionaries.

    MATCH path=shortestPath((p1:Person)-[*0..15]-(p2:Person)) 
    WHERE toLower(p1.name) = toLower(&#39;Halle Berry&#39;) AND toLower(p2.name) = toLower(&#39;Tom Hanks&#39;) 
    WITH relationships(path) AS relationships, nodes(path) AS nodes
    UNWIND relationships as role
    WITH apoc.coll.sort(role.roles) as roles, nodes 
    RETURN collect({roles: roles}) as relationships, nodes

    RESULT:
    ╒══════════════════════════════════════════════════════════════════════╤══════════════════════════════════════════════════════════════════════╕
    │&quot;relationships&quot;                                                       │&quot;nodes&quot;                                                               │
    ╞══════════════════════════════════════════════════════════════════════╪══════════════════════════════════════════════════════════════════════╡
    │[{&quot;roles&quot;:[&quot;Jocasta Ayrs&quot;,&quot;Luisa Rey&quot;,&quot;Meronym&quot;,&quot;Ovid&quot;]},{&quot;roles&quot;:[&quot;De│[{&quot;name&quot;:&quot;Halle Berry&quot;,&quot;born&quot;:1966},{&quot;title&quot;:&quot;Cloud Atlas&quot;,&quot;tagline&quot;:&quot;│
    │rmot Hoggins&quot;,&quot;Dr. Henry Goose&quot;,&quot;Isaac Sachs&quot;,&quot;Zachry&quot;]}]             │Everything is connected&quot;,&quot;released&quot;:2012},{&quot;name&quot;:&quot;Tom Hanks&quot;,&quot;born&quot;:1│
    │                                                                      │956}]                                                                 │
    └──────────────────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────────────────────┘",1,65012824
3165,https://stackoverflow.com/a/64962551,Is it possible to query relations from two node which the number of relation greater than a certain value,false,"to return nodes who have more then 2 relationship between them you need to check the size of the collected rels.  something like

    MATCH (x:Person)-[r:INVITE]-(:Party)
    WITH x, size(collect(r)) as inviteCount
    WHERE inviteCount &gt; 2
    RETURN x",0,64962551
3166,https://stackoverflow.com/a/64962682,Is it possible to query relations from two node which the number of relation greater than a certain value,false,"[Aggregating functions](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) like `COLLECT` and `COUNT` use non-aggregating terms in the same `WITH` (or `RETURN`) clause as &quot;grouping keys&quot;.

So, here is one way to get pairs of nodes that have more than 2 `INVITE` relationships (in a specific direction) between them:

    MATCH (from)-[r:INVITE]-&gt;(to)
    WITH from, to, COUNT(r) AS ref
    WHERE ref &gt; 2
    RETURN from, to

*NOTE: Ideally (for clarity and efficiency), your nodes would have specific [labels](https://neo4j.com/docs/getting-started/3.5/graphdb-concepts/#graphdb-labels) and the `MATCH` pattern would specify those labels.*",0,64962682
3167,https://stackoverflow.com/a/64954565,Query Neo4j for many date ranges,false,"Since you can have multiple relationships of the same type between any two given nodes, you can create a `:HAS_NAME` relationship for each period. And just match using (assuming you provide `queryStart` and `queryEnd` as parameters)

    MATCH (n)-[r:HAS_NAMe]-&gt;(m)
    WHERE ($queryEnd &gt; r.start AND $queryStart &lt; r.end) 

to retrieve the relationships.
",1,64954565
3168,https://stackoverflow.com/a/64951923,Search paths where all nodes are in a relationship with same node,true,"How about something like

    match (c:Country)
    with c
    MATCH (kid:Person)-[:IS_SON]-(par:Person)
    WITH c,kid, collect(distinct par) as parents
    match (kid)
    where all(x in parents WHERE  (x)-[:WAS_BORN]-(c))
    return c, collect(kid) as kids

this should return a list or records each containing a person whos all of his parents were born in the USA",1,64951923
3169,https://stackoverflow.com/a/64970857,Nested UNWIND not returning from higher UNWIND in Cypher query,false,"You can change your `UNWIND` for a `FOREACH` by using a `MERGE` instead of a `MATCH` in the second batch.

That would then solve the issue for the second unwind breaking your results in case of nulls

```
UNWIND $towns as town
MERGE (a:area:Town {Name: town.name, uuid: town.uuid}) with a, town
MATCH (p:parish{Name: town.parish}) with a, p, town
MERGE (a)-[:in]-(p) with a, town
FOREACH (category IN town.categories |
  MERGE (c:LocationCategory {uuid: category}) 
  MERGE (a)-[:category]-(c)
)
RETURN a
``` ",0,64970857
3170,https://stackoverflow.com/a/64952492,Fetch nodes according to parents and two way relations,false,"ok this is hands down ugly :)  basically we ensure that all items required ( up the tree from the item we want to use ) and all the items that enable the item we want to user ( also up the tree ) are available within the list of items we have.    is the count is zero then we can not use this item.

hope if this is not your exact solution then it gets you some new ideas :)

( on a side note this is something i much rather not solve in cypher but in Java as a procedure ( my 2 cents anyway  ) )  

    match (i:Item)
    where i.name in [&#39;Item A&#39;,&#39;Item B&#39;,&#39;Item C&#39;]
    with collect (distinct i) as myItems

    match (canIUseThis:Item{name:&#39;Item E&#39;})
    WITH myItems, canIUseThis

    match (canIUseThis)&lt;-[:Enables *1..]-(x)
    WITH myItems, canIUseThis, COLLECT(DISTINCT x) as enablers
    
    match (canIUseThis)-[:Requires *1..]-&gt;(y)
    WITH myItems, canIUseThis, enablers, COLLECT(DISTINCT y) as reqs
    
    match (canIUseThis)
    where all(x in reqs where x in myItems)  and all (x in enablers where x in myItems)
    return count(*) ",0,64952492
3171,https://stackoverflow.com/a/64937519,Neo4j ORDER BY custom sorting?,true,"You can sort on the fly but as stated in the comments, it will be expensive compared to splitting the data in the model.

Using the Movies dataset as example, here is a way to sort it based on last name. 
Split the name separated by space into a list then [-1] means sort by the last item of that list.

    MATCH (n:Person) 
    WITH n ORDER by split(n.name, &#39; &#39;)[-1]
    RETURN n.name

    result:

     ════════════════════════╕
    │&quot;n.name&quot;                │
    ╞════════════════════════╡
    │&quot;Stefan Arndt&quot;          │
    ├────────────────────────┤
    │&quot;Kevin Bacon&quot;           │
    ├────────────────────────┤
    │&quot;Christian Bale&quot;        │
    ├────────────────────────┤
    │&quot;Marshall Bell&quot;         │
    ├────────────────────────┤
    │&quot;Halle Berry&quot;           │",1,64937519
3172,https://stackoverflow.com/a/64940093,Setting multiple porerties using paramters- neo4j cypher,false,Update: The issue was not with the Query statement. An await keyword was missing in the API associated with it. Thank you for all your responses.,0,64940093
3173,https://stackoverflow.com/a/64939178,Cypher paged-listing query optimization,false,"The Cypher planner probably determined (using the server&#39;s DB statistics) that it was generally more efficient to execute your last query by looking up the `User` node (hopefully you have an `:User(id)` index to help with that), getting its related `Post` nodes, and then sorting.

If you were successful at forcing the planner to use your `:Post(sort_order)` index instead, then the execution would probably be *much less* efficient. That is because the query would still have to get and evaluate the related `User` nodes for (presumably almost) every `Post`.",0,64939178
3174,https://stackoverflow.com/a/64904135,Return nodes which do not have a property value in another node set,true,"This should work:

    MATCH (r:Rocks)
    WITH COLLECT(DISTINCT r.color) AS excludeColors
    MATCH (b:Bicycles)
    WHERE NOT b.colour IN excludeColors
    RETURN DISTINCT b.colour

",0,64904135
3175,https://stackoverflow.com/a/64904338,Adding a Relationship Property to a return node using C# neo4j client?,false,"This query uses Cypher&#39;s [map projection](https://neo4j.com/docs/cypher-manual/current/syntax/maps/#cypher-map-projection) syntax to combine the properties of the 2 maps the way you want:

    MATCH (:MyObject)-[r:SOME_RELATIONSHIP]-&gt;(n1:MyObject)
    RETURN n1{.*, newProp: r.value_from_relationship}",0,64904338
3176,https://stackoverflow.com/a/64895043,How to count the number of common nodes in Neo4j - query,true,"To get all the word(count)s for your `:Person` nodes
 

    MATCH (p:Person) 
    WITH COLLECT(p) AS persons
    UNWIND persons AS p1
    UNWIND persons AS p2
    WITH p1,p2
    WHERE id(p1) &gt; id(p2)
    
    
    MATCH (p1)-[:WORD]-&gt;(w:Word)&lt;-[:WORD]-(p2)
    RETURN p1.name AS p1Name,
           p2.name AS p2Name,
           COUNT(DISTINCT w) AS sharedWordCount,
           COLLECT(DISTINCT w.string) AS sharedWords
       
",1,64895043
3177,https://stackoverflow.com/a/64904618,Neo4j delete swapped duplicates in results,false,"If you enforce a specific ordering of the `Method` nodes&#39; native IDs, that will produce distinct `Method` name pairs (assuming method names are unique):

    MATCH
      (c:Class)-[:DECLARES]-&gt;(m1:Method),
      (c)-[:DECLARES]-(m2:Method),
      (c)-[:DECLARES]-(f:Field),
      (m1)-[:WRITES|READS]-&gt;(f),
      (m2)-[:WRITES|READS]-&gt;(f)
    WHERE ID(m1) &lt; ID(m2)
    RETURN m1.name, m2.name, f.name",0,64904618
3178,https://stackoverflow.com/a/64887164,depth in nodes of the same label in custom query,false,"To return the `Company` with the specified `name` if it is connected by a path of 1 to 2 `COLLECTS_FROM` relationships to descendant `Company` nodes:

    @Query(&quot;MATCH p=(c:Company {name:$name})-[:COLLECTS_FROM*..2]-&gt;(:Company) WHERE ALL(n IN NODES(p) WHERE &#39;Company&#39; IN LABELS(n)) RETURN c&quot;)
    Company customerWithCustomDepth(String name);

I assume that you do not want to get a result if there are no such descendants, which is why the [variable-length relationship](https://neo4j.com/docs/developer-manual/3.4/cypher/clauses/match/#varlength-rels) pattern does not use `*0..2`.

*Note: If you want to test for paths of exactly length 2, change `..2` to just `2`.*

The corresponding query for paths of *any* length can be obtained by just changing `..2` to `..`. However, variable-length relationship pattern with no upper bound are not recommended, since they can take &quot;forever&quot; to run or run out of memory.",1,64887164
3179,https://stackoverflow.com/a/64850433,Cypher query to recursively traverse family tree?,false,"What you want is to match [variable length relationships](https://neo4j.com/docs/cypher-manual/current/clauses/match/#varlength-rels)

    MATCH (p:Person)&lt;-[r:Related*1..]-(p2:Person)
    WHERE id(p)=4 AND id(p) &lt;&gt; id(p2)
    RETURN id(p), p, collect(r.relationship), collect(id(p2)) ",0,64850433
3180,https://stackoverflow.com/a/64864251,Cypher query to recursively traverse family tree?,false,"There are a number of ways to print trees, most of which rely on variable-length traversals like @Vivick described. If you want to print every relationship and intermediate/leaf node on its own row, you can do something like:
```
MATCH (p:Person)&lt;-[r:Related*]-(p2:Person)
WHERE id(p)=4
WITH collect(r) AS rels, collect(p2) AS nodes
UNWIND rels AS rel UNWIND nodes 
AS node RETURN rel, node
```

You might also want to use a traversal algorithm to accomplish this. In RedisGraph, this task could be succinctly performed with `algo.BFS`; most graph databases have similar implementations.",1,64864251
3181,https://stackoverflow.com/a/64947161,Cypher query to recursively traverse family tree?,true,"Ended up doing it by getting all connected to my target, then gathering relationship information with an `optional match`:

```
match (p:Person)&lt;-[*0..]-(p2) 
where id(p)=0
optional match (p2)&lt;-[r]-(p3)
return id(p2), p2.name, collect(r.relationship), collect(id(p3))
```

This query will (I think... still figuring this out):

 1. Get all nodes connected at any distance
 2. to my target node.
 3. Optionally look for relationships on each of those
 4. and return the node&#39;s id, name, and a collection of relationships and a collection of those relationship targets

This gives me a nice result with only one row per node, with all the info I need about that node and that nodes relationships to other nodes.

[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/kf6l8.png",0,64947161
3182,https://stackoverflow.com/a/64838712,"Return actors and movies, which where not directed by a specific director, but have worked together with this director in other movies. Cypher (neo4j)",false,"Eventually seems, just by passing the m variable, then it can be used again to sort the RETURN.

```
MATCH (actor:Person)-[:ACTED_IN]-&gt;(m:Movie)&lt;-[:DIRECTED]-(lana:Person {name:  &#39;Lana Wachowski&#39;}),
(actor:Person)-[:ACTED_IN]-&gt;(other:Movie)
WITH actor, m, other
WHERE NOT EXISTS((lana)-[:DIRECTED]-&gt;(other:Movie)&lt;-[:ACTED_IN]-(actor))
RETURN actor.name , other.title, COUNT(m)
ORDER BY COUNT(m) desc
LIMIT 10
```

HOWEVER if i try to run the query below I have duplicates in the collection lists.
```
MATCH (actor:Person)-[:ACTED_IN]-&gt;(m:Movie)&lt;-[:DIRECTED]-(lana:Person {name:  &#39;Lana Wachowski&#39;}),
(actor:Person)-[:ACTED_IN]-&gt;(other:Movie)
WITH actor, m, other
WHERE NOT EXISTS((lana)-[:DIRECTED]-&gt;(other:Movie)&lt;-[:ACTED_IN]-(actor))
RETURN DISTINCT actor.name , collect(other.title), COUNT(m)
ORDER BY COUNT(m) desc
LIMIT 10
```
",0,64838712
3183,https://stackoverflow.com/a/64937972,"Return actors and movies, which where not directed by a specific director, but have worked together with this director in other movies. Cypher (neo4j)",false,"You can collect the actors that acted in a movie directed by Lana.
Then for each actor, get the movies and collect the directors.
Check that the set of directors does not have lana in it.
Then collect the titles of these movies and sort by most number of movies.

So all actors who were directed by Lana and has other movies not directed by Lana are Tom Hanks (Cloud Atlas), Keanu (Matrix), Ben Miles (Speed Racer), Hugo (Cloud Atlas and Matrix) and Rain (Speed Racer)

    WITH [(a:Person)-[:ACTED_IN]-&gt;(:Movie)&lt;-[:DIRECTED]-(:Person {name: &#39;Lana Wachowski&#39;})|a] as actors
    UNWIND actors as actor
    MATCH (actor)-[:ACTED_IN]-&gt;(m:Movie)&lt;-[:DIRECTED]-(p:Person)
    WITH actor, m, collect(p) as directors WHERE NOT ANY (d in directors WHERE d.name = &#39;Lana Wachowski&#39;)
    RETURN actor.name , collect(m.title), COUNT(m)
    ORDER BY COUNT(m) desc
    LIMIT 10

REsult:

    ╒══════════════╤══════════════════════════════════════════════════════════════════════╤══════════╕
    │&quot;actor.name&quot;  │&quot;collect(m.title)&quot;                                                    │&quot;COUNT(m)&quot;│
    ╞══════════════╪══════════════════════════════════════════════════════════════════════╪══════════╡
    │&quot;Tom Hanks&quot;   │[&quot;Apollo 13&quot;,&quot;You&#39;ve Got Mail&quot;,&quot;A League of Their Own&quot;,&quot;Joe Versus the│11        │
    │              │ Volcano&quot;,&quot;That Thing You Do&quot;,&quot;The Da Vinci Code&quot;,&quot;Cast Away&quot;,&quot;The Gre│          │
    │              │en Mile&quot;,&quot;Sleepless in Seattle&quot;,&quot;The Polar Express&quot;,&quot;Charlie Wilson&#39;s │          │
    │              │War&quot;]                                                                 │          │
    ├──────────────┼──────────────────────────────────────────────────────────────────────┼──────────┤
    │&quot;Keanu Reeves&quot;│[&quot;Something&#39;s Gotta Give&quot;,&quot;The Replacements&quot;,&quot;Johnny Mnemonic&quot;,&quot;The De│4         │
    │              │vil&#39;s Advocate&quot;]                                                      │          │
    ├──────────────┼──────────────────────────────────────────────────────────────────────┼──────────┤
    │&quot;Ben Miles&quot;   │[&quot;Ninja Assassin&quot;,&quot;V for Vendetta&quot;]                                   │2         │
    ├──────────────┼──────────────────────────────────────────────────────────────────────┼──────────┤
    │&quot;Hugo Weaving&quot;│[&quot;V for Vendetta&quot;]                                                    │1         │
    ├──────────────┼──────────────────────────────────────────────────────────────────────┼──────────┤
    │&quot;Rain&quot;        │[&quot;Ninja Assassin&quot;]                                                    │1         │
    └──────────────┴──────────────────────────────────────────────────────────────────────┴──────────┘

 ",0,64937972
3184,https://stackoverflow.com/a/64875651,Unable to connect to neo4j from nodejs using neo4j driver,true,The issue actually got resolved when I switched from wsl 2 to windows powershell.,1,64875651
3185,https://stackoverflow.com/a/64826534,Why duplicated results query with cypher neo4j,false,"This is because you are matching

    MATCH (m:Movie)&lt;-[r]-(p:Person)

So the movie title will be returned for each person in the movie, so if there are 4 people in the movie, you will get four movie titles back. You can remove duplicates by matching only the movie

    MATCH (m:Movie)
",1,64826534
3186,https://stackoverflow.com/a/64826635,Why duplicated results query with cypher neo4j,false,"As Tomaz said, it is returning a row for every :Person that has a relationship to :Movie. If you concluded your query with just `RETURN m` and viewed the results, you probably would only see non-duplicated nodes appear. Otherwise, you can conclude the query with `RETURN DISTINCT m` to ensure that non-duplicated results are returned.

 ",1,64826635
3187,https://stackoverflow.com/a/64826649,Neo4j persistent named graph,true,"You could give every node in the same &quot;named graph&quot; the same [label](https://neo4j.com/docs/getting-started/current/graphdb-concepts/#graphdb-labels). Since a node can have multiple labels, this does not prevent you from using other labels for other purposes as well.",0,64826649
3188,https://stackoverflow.com/a/64827739,Neo4j/Cypher optionally create a Node and relationship based on whether a JSON object is empty or not,false,"You can use the APOC procedure [apoc.do.when](https://neo4j.com/labs/apoc/4.1/overview/apoc.do/apoc.do.when/) to perform if-then-else processing that can write to the DB ([apoc.when](https://neo4j.com/labs/apoc/4.1/overview/apoc/apoc.when/) can be used for read-only processing).

For example, your last snippet can be done this way:

    ...
    CALL apoc.do.when(
      $imageReference IS NOT NULL,
      &#39; CREATE (ir:ImageReference {
          id: apoc.create.uuid(), 
          name: ref.name, 
          downloadURL: ref.downloadURL,
          createdAt: datetime(),
          updatedAt: datetime()
        })
        CREATE (p)-[:HAS_ATTACHMENT]-&gt;(ir)
        RETURN ir&#39;,
      &#39;&#39;,
      {ref: $imageReference, p: p}
    ) YIELD value
    WITH p, value.ir AS ir
    ...",0,64827739
3189,https://stackoverflow.com/a/64816403,Neo4J CSV into Props,false,"Try this

    LOAD CSV WITH HEADERS FROM &#39;&lt;yourFilePath&gt;&#39; AS row
    CREATE (n:node)
    SET n+= row",0,64816403
3190,https://stackoverflow.com/a/64828411,Neo4J CSV into Props,false,"In Cypher, variables that start with &quot;$&quot; must be passed to the query as [parameters](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/). Your Cypher code is locally binding values to the `ROW` variable (and not passing a parameter), so change `$ROW` to `ROW`.

In addition, if you want to make sure that you do not generate duplicate nodes, you should consider using [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) instead of `CREATE`. But before you do so, you must carefully read the documentation on `MERGE` to understand how to use it properly.",0,64828411
3191,https://stackoverflow.com/a/64809519,Query to write hops and return all the properties from the middle nodes or a better way to do it and skip hops?,false,"Try this

    // in case there is always A,C and E, you can look for
    // paths with length 3 to 6
    MATCH path=(A)-[*3..6]-(E)
    
    // return the name of each node in the same order
    RETURN [n IN nodes(path) | n.name] AS nodeNames 


",0,64809519
3192,https://stackoverflow.com/a/64814638,Query to write hops and return all the properties from the middle nodes or a better way to do it and skip hops?,false,"Assuming `A` through `E` are node [labels](https://neo4j.com/docs/getting-started/3.5/graphdb-concepts/#graphdb-labels), this query should get all paths that match your pattern (with 0 to 7 `B` nodes between the `A` and `C` nodes), and return distinct lists of node `Name` values:

    MATCH p=(:A)-[*..8]-(:C)--(:D)--(:E)
    WHERE ALL(n IN NODES(p)[1..-3] WHERE &#39;B&#39; IN LABELS(n))
    RETURN DISTINCT [m IN NODES(p) | m.Name] AS names

In general, the query would be more efficient if you could also specify the relationship types and their directionality.",0,64814638
3193,https://stackoverflow.com/a/64812808,CYPHER query based on sum relationship property array,false,"I think this will do what you want

MATCH p=(n1:Node)-[:RELATIONSHIP*2..2]-&gt;(n2:Node)
with n1 as head, n2 as tail, REDUCE(totalScore = 0.0, r in relationships(p) | totalScore + toFloat(r.score)) as score
where score&gt;1.99
return head.name, tail.name, score

Notes:
In my example I&#39;m specifying a fixed path length of 2, so that I could check the total scores easily...
If you graph has bidirectional relationships or loops, know that head=tail is possible... 
",0,64812808
3194,https://stackoverflow.com/a/64814849,CYPHER query based on sum relationship property array,true,"This should work for you:

    MATCH (:Node)-[r:RELATIONSHIP]-&gt;(tail:Node)
    WHERE REDUCE(s = 0, v IN r.list | s + v) &gt; 0
    RETURN tail",1,64814849
3195,https://stackoverflow.com/a/65492284,Error in Import Shape file of neo4j using cypher query,false,"Looks like you have also posted the question in Neo4j community. I have answered there, but going to answer here also.

Not sure, if this is resolved, but I was able to import the shapefile into the database.
My Configuration -&gt; 
Neo4j 3.5.20
Java Version 9
neo4j-spatial-0.26.2
Source of the shapefile -&gt; https://www2.census.gov/geo/tiger/GENZ2019/shp/ ( i guess you are also using the same file). Make sure all the file like prj, dbf are on the same directory. (Its bin of neo4j)


Can you check if whitelisted and unrestricted spatial.* plugins in your configuration.
```
dbms.security.procedures.unrestricted=algo.*,apoc.*,spatial.*
dbms.security.procedures.whitelist=algo.*,apoc.*,spatial.*
```
 
```
&gt; Directories in use:
&gt;   home:         /root/neo4j-enterprise-3.5.20
&gt;   config:       /root/neo4j-enterprise-3.5.20/conf
&gt;   logs:         /root/neo4j-enterprise-3.5.20/logs
&gt;   plugins:      /root/neo4j-enterprise-3.5.20/plugins
&gt;   import:       /root/neo4j-enterprise-3.5.20/import
&gt;   data:         /root/neo4j-enterprise-3.5.20/data
&gt;   certificates: /root/neo4j-enterprise-3.5.20/certificates
&gt;   run:          /root/neo4j-enterprise-3.5.20/run
&gt; Starting Neo4j.
&gt; WARNING: Max 1024 open files allowed, minimum of 40000 recommended. See the Neo4j manual.
&gt; 2020-12-29 12:13:14.593+0000 INFO  ======== Neo4j 3.5.20 ========
&gt; 2020-12-29 12:13:14.603+0000 INFO  Starting...
&gt; 2020-12-29 12:13:15.666+0000 INFO  Initiating metrics...
&gt; 2020-12-29 12:13:15.667+0000 WARN  Exporting tool have been configured to report values to but no metrics were enabled. Disabling kernel metrics extension.
&gt; 2020-12-29 12:13:30.513+0000 INFO  Bolt enabled on 0.0.0.0:7687.
&gt; 2020-12-29 12:13:33.455+0000 INFO  Started.
&gt; 2020-12-29 12:13:33.619+0000 INFO  Mounted REST API at: /db/manage
&gt; 2020-12-29 12:13:33.679+0000 INFO  Loaded server plugin &quot;SpatialPlugin&quot;
&gt; 2020-12-29 12:13:33.681+0000 INFO    GraphDatabaseService.addSimplePointLayer: add a new layer specialized at storing simple point location data
&gt; 2020-12-29 12:13:33.681+0000 INFO    GraphDatabaseService.addNodesToLayer: adds many geometry nodes (about 10k-50k) to a layer, as long as the nodes contain the geometry information appropriate to this layer.
&gt; 2020-12-29 12:13:33.681+0000 INFO    GraphDatabaseService.findClosestGeometries: search a layer for the closest geometries and return them.
&gt; 2020-12-29 12:13:33.681+0000 INFO    GraphDatabaseService.addGeometryWKTToLayer: add a geometry specified in WKT format to a layer, encoding in the specified layers encoding schemea.
&gt; 2020-12-29 12:13:33.682+0000 INFO    GraphDatabaseService.findGeometriesWithinDistance: search a layer for geometries within a distance of a point. To achieve more complex CQL searches, pre-define the dynamic layer with addCQLDynamicLayer.
&gt; 2020-12-29 12:13:33.682+0000 INFO    GraphDatabaseService.addEditableLayer: add a new layer specialized at storing generic geometry data in WKB
&gt; 2020-12-29 12:13:33.682+0000 INFO    GraphDatabaseService.addNodeToLayer: add a geometry node to a layer, as long as the node contains the geometry information appropriate to this layer.
&gt; 2020-12-29 12:13:33.682+0000 INFO    GraphDatabaseService.addCQLDynamicLayer: add a new dynamic layer exposing a filtered view of an existing layer
&gt; 2020-12-29 12:13:33.682+0000 INFO    GraphDatabaseService.getLayer: find an existing layer
&gt; 2020-12-29 12:13:33.682+0000 INFO    GraphDatabaseService.findGeometriesInBBox: search a layer for geometries in a bounding box. To achieve more complex CQL searches, pre-define the dynamic layer with addCQLDynamicLayer.
&gt; 2020-12-29 12:13:33.682+0000 INFO    GraphDatabaseService.findGeometriesIntersectingBBox: search a layer for geometries intersecting a bounding box. To achieve more complex CQL searches, pre-define the dynamic layer with addCQLDynamicLayer.
&gt; 2020-12-29 12:13:35.085+0000 INFO  Remote interface available at http://localhost:7474/
**&gt; info | inserted geometries: 56**
**&gt; info | elapsed time in seconds: 0.329**
```

**&gt; info | inserted geometries: 56**
**&gt; info | elapsed time in seconds: 0.329**


```
&gt; neo4j&gt; match (n) return count(n);
&gt; +----------+
&gt; | count(n) |
&gt; +----------+
&gt; | 0        |
&gt; +----------+
&gt; 
&gt; 1 row available after 152 ms, consumed after another 0 ms
&gt; neo4j&gt;
&gt; neo4j&gt; call spatial.importShapefile(&quot;cb_2019_us_state_500k.shp&quot;);
&gt; info | inserted geometries: 56
&gt; info | elapsed time in seconds: 0.338
&gt; +-------+
&gt; | count |
&gt; +-------+
&gt; | 56    |
&gt; +-------+
&gt; 
&gt; 1 row available after 978 ms, consumed after another 0 ms
&gt; neo4j&gt; match (n) return count(n);
&gt; +----------+
&gt; | count(n) |
&gt; +----------+
&gt; | 60       |
&gt; +----------+
&gt; 
&gt; 1 row available after 27 ms, consumed after another 1 ms

neo4j&gt; call db.labels();
+-----------------+
| label           |
+-----------------+
| &quot;ReferenceNode&quot; |
+-----------------+


match (n) return (n) limit 2;
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| (:ReferenceNode {name: &quot;spatial_root&quot;})                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| ({index_class: &quot;org.neo4j.gis.spatial.index.LayerRTreeIndex&quot;, gtype: 6, layercrs: &quot;GEOGCS[\&quot;GCS_North_American_1983\&quot;,
  DATUM[\&quot;D_North_American_1983\&quot;,
    SPHEROID[\&quot;GRS_1980\&quot;, 6378137.0, 298.257222101]],
  PRIMEM[\&quot;Greenwich\&quot;, 0.0],
  UNIT[\&quot;degree\&quot;, 0.017453292519943295],
  AXIS[\&quot;Longitude\&quot;, EAST],
  AXIS[\&quot;Latitude\&quot;, NORTH]]&quot;, ctime: 1609244499209, layerprops: [&quot;ID&quot;, &quot;STATEFP&quot;, &quot;STATENS&quot;, &quot;AFFGEOID&quot;, &quot;GEOID&quot;, &quot;STUSPS&quot;, &quot;NAME&quot;, &quot;LSAD&quot;, &quot;ALAND&quot;, &quot;AWATER&quot;], geomencoder: &quot;org.neo4j.gis.spatial.WKBGeometryEncoder&quot;, layer_class: &quot;org.neo4j.gis.spatial.EditableLayerImpl&quot;, layer: &quot;cb_2019_us_state_500k&quot;}) |
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


```


Let me or the community forums group know if you need further more assistance.",0,65492284
3196,https://stackoverflow.com/a/64828178,Substitute one chain of nodes into anoter chain of nodes in graphdb ? like string substitution,false,"I hope I&#39;ve understood your question correctly


```
MATCH ({uid:333})-[]-&gt;(s {uid:102})-[e0]-&gt;({uid:155})-[e1]-&gt;()
CREATE (s)-[:R]-&gt;({uid:255})-[:R]-&gt;({uid:107})
DELETE e0, e1
```

MATCH will find the chain you would like to modify.

CREATE will introduce the new sub-chain.

DELETE will disconnect the original sub-chain that&#39;s being replaced, depending on your use-case you might want to delete the replaced nodes instead of the edges.
",2,64828178
3197,https://stackoverflow.com/a/64828033,Redis Graph : Searching for n-consecutive nodes with moded-property?,false,"You might want to consider constructing your query dynamically from the user input list.

```
q = &quot;MATCH (n0 {uid:list[0]})&quot;
for id in list[1:]:
    q += &quot;--&gt;({uid:%d})&quot; % id
q += &quot; RETURN n0&quot;
```

Note code wasn&#39;t tested!",1,64828033
3198,https://stackoverflow.com/a/64796113,Neo4j and Cypher: Reversing Only One Arrow,true,"I think I have a method of doing this. Each node has a unique numerical `id` which I can leverage as follows:
```
MATCH(x)--&gt;(y)
WHERE NOT EXISTS(()--&gt;(x))
    AND NOT EXISTS(x.visit_type_name)
WITH MIN(y.id) AS min_y_id, x
MATCH(x)-[r]-&gt;(min_y)
WHERE min_y.id = min_y_id
DELETE r
MERGE(min_y)--&gt;(x)
```
This essentially picks out the minimum `id` and only reverses the arrow for the corresponding node.",0,64796113
3199,https://stackoverflow.com/a/64776606,Unwinding and merging the results with dynamic labels in Neo4J Client for C#,false,"[EDITED]

The main issue is that `Merge(&quot;(n)&quot;)` matches any arbitrary node that already exists.

You have not shown the data structure for each element of `itemList`, so this answer will assume it looks like this:

    {Name: &#39;SomeLabel&#39;, id: 123, Props: {foo: &#39;xyz&#39;, bar: true}}

With above data structure, this should work:

    public async void CreateBatchItems(List&lt;TToDataBase&gt; itemList)
    {
        await Client.Cypher
          .Unwind(itemList, &quot;row&quot;)
          .Call(&quot;apoc.merge.node([row.ObjectId], row.id)&quot;).Yield(&quot;node&quot;)
          .Set(&quot;node += row.Props&quot;)
          .ExecuteWithoutResultsAsync();
    }

[UPDATE]

The data structure you added to your question is very different than what I had imagined. Since neither of the properties in a `row` is a map, `.Set(&quot;node += row.Props&quot;)` would generate an error.

Using your data structure for each row, this might work:

    public async void CreateBatchItems(List&lt;TToDataBase&gt; itemList)
    {
        await Client.Cypher
          .Unwind(itemList, &quot;row&quot;)
          .Merge(&quot;(n:Foo {id: row.ObjectId})&quot;)
          .Set(&quot;n += row.Name&quot;)
          .ExecuteWithoutResultsAsync();
    }

This code assigns the node label `Foo` to all the generated nodes. A node should always have a label, which improves clarity and also tends to improve efficiency -- especially if you also create [indexes](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/). For example, an index on `:Foo(id)` would make the above query more efficient.

This code also assumes that the `id` property is supposed to contain a unique `Foo` node identifier.",0,64776606
3200,https://stackoverflow.com/a/64773076,Why code sample from neo4j python drive official documentation does not work?,false,"In my experience, it&#39;s a lot cleaner to create your nodes first, and then your relationships after. So here&#39;s what I would recommend:
```
CREATE(:Person{name:$name});
CREATE(:Person{name:$friend});

MATCH(a:Person{name:$name})
WITH a
MATCH(f:Person{name:$friend})
CREATE(a)-[:KNOWS]-&gt;(f);
```
Finally, if you&#39;re doing a query, you could do something like this:
```
MATCH(a:Person{name:$name})-[:KNOWS]-&gt;(f:Person{name:$friend})
RETURN f.name AS `friend`
```
I&#39;ve not tested this out, and there may be syntax errors, particularly with the `$name` and `$friend` variables, but this overall structure would, I think, work better for you.",0,64773076
3201,https://stackoverflow.com/a/64762835,Neo4j Cypher Aggregating Value Counts,false,"Cypher does not have way to &quot;pivot&quot; data (as discussed [here](https://stackoverflow.com/a/63160792/974731)). That is in part because it does not support *dynamically* generating the names of return values (e.g., &quot;Cold&quot;) -- and it is these names that appear as &quot;column&quot; headers in the `Text` and `Table` visualizations provided by the neo4j Browser.

However, if you know that you only have, say, 3 possible &quot;weather&quot; names, you can use a query like this, which hardcodes those names in the `RETURN` clause:

    MATCH (c:City)-[:HAS_WEATHER]-&gt;(w:Weather)
    WITH c, {weather: w.weather, count: COUNT(*)} AS weatherCount
    WITH c, REDUCE(s = {Cold: 0, Warm: 0, Hot: 0}, x IN COLLECT(weatherCount) | apoc.map.setKey(s, x.weather, x.count)) AS counts
    MATCH (p:Person)-[:LIVES_IN]-&gt;(c)
    RETURN p.name AS pName, c.name AS cName, counts.Cold AS Cold, counts.Warm AS Warm, counts.Hot AS Hot

The above query efficiently gets the weather data for a city *once* (for all people in that city), instead of once per person.

The APOC function [apoc.map.setKey](https://neo4j.com/labs/apoc/4.1/overview/apoc.map/apoc.map.setKey/) is a convenient way to get a map with an updated key value.",0,64762835
3202,https://stackoverflow.com/a/64757493,Property as a list or array in neo4j,true,"You can use the [`ON CREATE and ON MATCH](https://neo4j.com/docs/cypher-manual/current/clauses/merge/#query-merge-on-create-on-match) subclauses of [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) to either create or append to a list property, like this:

    LOAD CSV FROM &#39;file:///data.csv&#39; AS line
    MERGE (f:Foo {id: line.id})
    ON CREATE SET f.bar = [line.prop]
    ON MATCH SET f.bar = f.bar + line.prop

",0,64757493
3203,https://stackoverflow.com/a/64720783,Deleting duplicate relationships in neo4j - is this correct?,true,"First of all, let me (strictly) define the term: &quot;duplicate relationships&quot;. Two relationships are duplicates if they:

  1. Connect the same pair of nodes (call them `a` and `b`)
  2. Have the same relationship type
  3. Have exactly the same set of properties (both names and values)
  4. Have the same directionality between `a` and `b` (iff directionality is significant for use case)

Your query only considers #1 and #4, so it generally could delete non-duplicate relationships as well.

Here is a query that will take all of the above into consideration (assuming #4 should be included):

    MATCH (a)-[r1]-&gt;(b)&lt;-[r2]-(a)
    WHERE TYPE(r1) = TYPE(r2) AND PROPERTIES(r1) = PROPERTIES(r2)
    WITH a, b, apoc.coll.union(COLLECT(r1), COLLECT(r2))[1..] AS rs
    UNWIND rs as r
    DELETE r

[Aggregating functions](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) (like `COLLECT`) use non-aggregated terms as `grouping keys`, so there is no need for the query to perform a separate redundant `DISTINCT a,b` test.

The APOC function [apoc.coll.union](https://neo4j.com/labs/apoc/4.1/overview/apoc.coll/apoc.coll.union/) returns the distinct union of its 2 input lists.",1,64720783
3204,https://stackoverflow.com/a/64720898,Mutual followers cypher script - neo4j,false,"Try the following query:

    MATCH (user:User)-[:FOLLOWS {status: &#39;accepted&#39;}]-&gt;(:User {ID:$ID})
    WITH collect(user) as followers
    UNWIND followers as follower
    MATCH (follower)-[:FOLLOWS {status: &#39;accepted&#39;}]-&gt;(node)
    WHERE node in followers
    RETURN follower",0,64720898
3205,https://stackoverflow.com/a/64727214,Mutual followers cypher script - neo4j,false,"You can find the triangles like this. You can get the followers of one of your own followers without specifying the followerID.

       MATCH (me:User {ID:$ID})&lt;-[:FOLLOWS {status: &#39;accepted&#39;}]-(mutualFollower:User),
             (mutualFollower)-[:FOLLOWS {status: &#39;accepted&#39;}]-&gt;(myFollower:User),
             (myFollower)-[:FOLLOWS {status: &#39;accepted&#39;}]-&gt;(me)

       // return the list of your followers, with for each the list of followers that you have in common.    
       RETURN myFollower.ID AS myFollower, 
              COLLECT(DISTINCT mutualFollower.ID) AS mutualFollowers",0,64727214
3206,https://stackoverflow.com/a/64717848,Neo4j Cypher - How to display graph of all nodes of a certain type with a common node?,true,"Try to return the paths

    MATCH p=(a)-[r*]-&gt;(b)
    WHERE a.name=&quot;Immunodeficiency&quot; AND 
    b.name=&quot;autosomal recessive&quot;
    return p",1,64717848
3207,https://stackoverflow.com/a/64702015,Neo4J: adding number rankings to an ordered output,true,"You can use `COLLECT` and `UNWIND` to implement the same.



    MATCH(r: Restaurant)
    WITH r ORDER BY r.restaurantFoodRating DESC
    WITH COLLECT(r) as rs
    UNWIND range(1, size(rs)) as rank
    WITH rs[rank-1] AS r, rank
    RETURN r.restaurantName AS `Restaurant name`, r.restaurantFoodRating AS `Restaurant food rating`, rank

Here we have ordered restaurants using `WITH`, `COLLECT` will create a ordered list. `UNWIND` will loop on a range 1 to the size of the list, you can use this index to get restaurant node from the list by order and return the same with restaurant details.",0,64702015
3208,https://stackoverflow.com/a/64683149,Neo4j How to find a node connected somehow to another given node,false,"I think you&#39;re nearly there, but you need to limit the path length. Try this:
```
match path=((n:node1)-[*0..15]-(:Root{name:&quot;XYZ&quot;})) return n
```
You don&#39;t need to name the `:Root` node, since you&#39;re not returning anything about it. And you need to get rid of naming the relationship, since it conflicts with the variable name you gave the `:Root`, though perhaps that is moot if you leave that out.",0,64683149
3209,https://stackoverflow.com/a/64679490,Neo4j: matching nodes with 2 more properties in common,true,"This should do it:

    // get all hotels
    MATCH (h:Hotel)
    
    // create hotel pairs, avoiding duplicates
    WITH COLLECT(h) AS hotels
    UNWIND hotels AS h1
    UNWIND hotels AS h2
    WITH h1,h2 
    WHERE id(h1)&gt;id(h2)
    
    //loop through keys and count same values 
    WITH h1, h2,
         REDUCE(i=0, key in keys(h1)  |
                i
                + CASE WHEN h1[key] = h2[key] THEN 1 ELSE 0 END
         )  AS sameCount

    // set your limit
    WHERE sameCount &gt;=3 
    
    RETURN h1.hotelName, h2.hotelName , sameCount",0,64679490
3210,https://stackoverflow.com/a/64679526,Neo4j: ordering output by values in a collection,false,"You have two options:

-  get the values that you sort on separately before you do the COLLECT.
-  using apoc.coll.sort or apoc.coll.sortMaps   to sort after you have COLLECTed",0,64679526
3211,https://stackoverflow.com/a/64687295,Neo4j: ordering output by values in a collection,true,"You can sort the data before you `COLLECT` it: 

    MATCH (s1: Station), (s2: Station)
    WHERE s1 &lt;&gt; s2
    WITH
      s1.stationName AS Station, s2.stationName AS sn2,
      round(distance(
        point({longitude: s1.stationLong, latitude: s1.stationLat}),
        point({longitude: s2.stationLong, latitude: s2.stationLat}))) AS dist
    ORDER BY dist
    RETURN Station, COLLECT([sn2, dist]) AS `Distance to all other stations`

",0,64687295
3212,https://stackoverflow.com/a/64669040,Neo4j: using distance() function to determine distance between houses,true,"This should give you the distances, ordered by `house` values:

    MATCH (h1: House), (h2: House)
    WHERE h1 &lt;&gt; h2
    RETURN
      h1, h2,
      round(distance(
        point({longitude: h1.houseLong, latitude: h1.houseLat}),
        point({longitude: h2.houseLong, latitude: h2.houseLat}))) AS dist
    ORDER BY h1.house, h2.house

NOTE: Every pair of houses will be represented twice (in reverse order), which is apparently what you wanted.",0,64669040
3213,https://stackoverflow.com/a/64654525,Difference between Cypher Queries. (neo4j movie db),true,"The first query finds `Person`s who `PRODUCED` the `Movie m`, but did not direct **any** movie. The second query finds `Person`s who `PRODUCED` the `Movie m` but did not direct that **particular** `Movie m`. You know this because in the second query, the bound variable `m` is used in the `WHERE` clause, whereas in the first query, only the label `:Movie` is used in the `WHERE` clause.

Incidentally, the `path =` part of the first query does nothing.",0,64654525
3214,https://stackoverflow.com/a/64641734,Neo4J: query based on partial values of a node key [SOLVED],false,"Here

    MERGE (o:Opening {openingTimes: openingTimes, openingDays: openingDays})

you create nodes with label  `Opening` instead of `OpeningHours`

",0,64641734
3215,https://stackoverflow.com/a/64614399,Cypher: what is the use of YIELD?,true,"You should read the [documentation](https://neo4j.com/docs/cypher-manual/current/clauses/call/#query-call-introduction) for `CALL` and `YIELD`.

Here are a couple of snippets from the docs:

&gt; Most procedures return a stream of records with a fixed set of result
&gt; fields, similar to how running a Cypher query returns a stream of
&gt; records. The `YIELD` sub-clause is used to explicitly select which of
&gt; the available result fields are returned as newly-bound variables from
&gt; the procedure call to the user or for further processing by the
&gt; remaining query. Thus, in order to be able to use `YIELD`, the names
&gt; (and types) of the output parameters need be known in advance. Each
&gt; yielded result field may optionally be renamed using aliasing (i.e.
&gt; resultFieldName `AS` newName). All new variables bound by a procedure
&gt; call are added to the set of variables already bound in the current
&gt; scope. It is an error if a procedure call tries to rebind a previously
&gt; bound variable (i.e. a procedure call cannot shadow a variable that
&gt; was previously bound in the current scope).

&gt; Inside a larger query, the records returned from a procedure call with
&gt; an explicit YIELD may be further filtered using a `WHERE` sub-clause
&gt; followed by a predicate (similar to `WITH` …​ `WHERE` …​).
&gt; 
&gt; If the called procedure declares at least one result field, `YIELD` may
&gt; generally not be omitted. However `YIELD` may always be omitted in a
&gt; standalone procedure call. In this case, all result fields are yielded
&gt; as newly-bound variables from the procedure call to the user.",2,64614399
3216,https://stackoverflow.com/a/64608500,neo4j Cypher - Match query pulling data no within set parameters,true,"Looks like you&#39;re storing numerical information as text - at which point the &gt; and &lt; comparison operators don&#39;t do what you think they do. Neo4j also won&#39;t do a type conversion for you - which is why when you try comparing to the number 10 rather than the string 10 you get no results at all (it just rejects all nodes because the datatype doesn&#39;t match what you&#39;re asking for).

For example:

```
WITH &quot;5&quot; as a, &quot;10&quot; as b
RETURN a &gt; b

╒═══════╕
│&quot;a &gt; b&quot;│
╞═══════╡
│true   │
└───────┘
```

As I understand it, Cypher&#39;ll do a character-by-character comparison when you ask it &#39;which string is bigger?&#39;. So in your case, it&#39;ll look at 5 and 10 and say

&gt; Is the first character of the string &#39;5&#39; greater than the first character of the string &#39;10&#39;? Well in ASCII 5 &gt; 1, so yes - return true

You either need to store numerical information as actual numbers in the node properties (at which point comparisons will work as you expect), or convert the node property to a number before doing the comparison. The second option may be a little slower, because the conversion has to happen on each node and you can&#39;t add a useful index to help out.

Still, given:

```
CREATE (a: Node { prop: &quot;5&quot; }), (b: Node { prop: &quot;10&quot; })
```

Then

```
MATCH (n:Node) WHERE n.prop &gt;= 10
RETURN n
```

returns no results as you are seeing. But:

```
MATCH (n:Node) WHERE toInteger(n.prop) &gt;= 10
RETURN n
```

Returns the node you&#39;re after.

As mentioned though, I&#39;d strongly recommend updating your nodes to store the score property as a number instead of a string if it&#39;s genuinely numerical information.",1,64608500
3217,https://stackoverflow.com/a/64606147,How to fetch all the paths from root to leaf (DFS way) in Neo4j and return the result containing nodes and relationships,true,"A list of all available paths could be obtained as follows.

    MATCH p=(root {id: &#39;start&#39;})-[*]-&gt;(leaf)  
    // limit the match to the ones that end at a leaf
    WHERE NOT (leaf)--&gt;()
    
    
    RETURN DISTINCT REDUCE (s=&#39;&#39;, r in RELATIONSHIPS(p) | 
                   s+
                   CASE WHEN s=&#39;&#39; THEN &#39;(&#39;+startNode(r).name + &#39;)-[:&#39;+ type(r)+&#39;]-&gt;(&#39;+ endNode(r).name+&#39;)&#39;
                        ELSE &#39;-[:&#39;+ type(r)+&#39;]-&gt;(&#39;+ endNode(r).name+&#39;)&#39;
                   END
           ) AS path",2,64606147
3218,https://stackoverflow.com/a/64620808,neo4j-graphql-js: satisfy type using @cypher without returning a concrete node,true,"The problem is that according to the `Person` definition, there must be an object at the query output. So try this query

    WITH [[&quot;foo&quot;, 42], [&quot;bar&quot;, 43]] AS x UNWIND x AS y
    RETURN { name: y[0], age: y[1] } as Person",2,64620808
3219,https://stackoverflow.com/a/64584782,Is it possible not to output relation column when using APOC.export?,true,"You can use the APOC function [apoc.text.replace](https://neo4j.com/labs/apoc/4.1/misc/text-functions/) to modify the CSV string to remove the unwanted rows:

    MATCH (c:computer)
    WITH COLLECT(DISTINCT c) AS cs
    CALL apoc.export.csv.data(cs, [], null, {stream:true, batchSize:100}) YIELD data
    WITH apoc.text.replace(data, &#39;(?:,&quot;_start&quot;,&quot;_end&quot;,&quot;_type&quot;|,,,)(?=\n)&#39;, &quot;&quot;) AS newData
    ... // use newData, which does not have the last 3 columns

Since the 3 columns you don&#39;t want are at the end of each row, the regular expression `(?:,&quot;_start&quot;,&quot;_end&quot;,&quot;_type&quot;|,,,)(?=\n)` matches the unwanted text at the end of each row (whether the header row or a data row).

[UPDATE]

With respect to the `ADDITIONS` issues: a [WITH](https://neo4j.com/docs/cypher-manual/current/clauses/with/) clause will drop any variables not specified by the clause, so `N` was not being carried forward. Also, you had other issues. This should fix up all the issues:

    MATCH (m:SportsTeam)-[r:hasMember]-(n)
    WITH COLLECT(DISTINCT m) AS M, COLLECT(DISTINCT n) AS N, COLLECT(r) as R
    CALL apoc.export.csv.data( M, [], null, {stream:true}) YIELD data
    WITH apoc.text.replace(data, &#39;(?:,&quot;_start&quot;,&quot;_end&quot;,&quot;_type&quot;|,,,)(?=\n)&#39;, &#39;&#39;) AS mdata, N, R
    CALL apoc.export.csv.data( N, [], null, {stream:true}) YIELD data
    WITH apoc.text.replace(data, &#39;(?:,&quot;_start&quot;,&quot;_end&quot;,&quot;_type&quot;|,,,)(?=\n)&#39;, &#39;&#39;) AS ndata, mdata, R
    CALL apoc.export.csv.data( [], R, null, {stream:true}) YIELD data AS rdata
    RETURN mdata, ndata, rdata

",1,64584782
3220,https://stackoverflow.com/a/64571522,Why so many db hit in neo4j?,false,"It&#39;s probably the `*` in the relationship part of your query that&#39;s doing it.

While you&#39;ve got only one Category node and two Template nodes, you&#39;ve asked Neo4j to hop through any number of relationships to get from one to the other and not given it any help to narrow down the search besides specifying the starting node.

For example, if your Category was connected to 100,000 other nodes (of any label, not just Template) you&#39;ve forced Neo4j to jump through every single one of them looking to see if there&#39;s a path to a Template node - and if those nodes have their own connections then they all need to be explored too, because the depth of the traversal isn&#39;t constrained.

If you know how Category and Template nodes can be connected in ways you&#39;re interested in (for example, if there&#39;s only every some specific set of relationships you want to traverse) then you&#39;ll radically improve the performance of the query. Equally, reducing the maximum length of the path will help.",0,64571522
3221,https://stackoverflow.com/a/64556825,How to create a Hash in Neo4j from given string?,false,"Have it - i used []

CREATE (p:person { FirstName:&quot;M&quot;, LastName: &quot;H&quot; , Language: &quot;de&quot;, hash: apoc.util.sha512(**[**&quot;1234567&quot;,&quot;salt&quot;**]**)});",0,64556825
3222,https://stackoverflow.com/a/64552293,"How can I define a variable in FOREACH clause in neo4j, How to find the number of common properties for two nodes",false,"The issue is not the FOREACH, but because the `count` variable is initialized wrongly before : 

```
MATCH(p1:Place), (p2:Place)
WHERE p1.placeId &lt;&gt; p2.placeId
WITH count = 0
...
```

should become

```
MATCH(p1:Place), (p2:Place)
WHERE p1.placeId &lt;&gt; p2.placeId
WITH p1, p2, 0 AS count
...
```",0,64552293
3223,https://stackoverflow.com/a/64558444,"How can I define a variable in FOREACH clause in neo4j, How to find the number of common properties for two nodes",true,"You should use [REDUCE](https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-reduce) instead of [FOREACH](https://neo4j.com/docs/cypher-manual/current/clauses/foreach/).

For example:

    MATCH(p1:Place), (p2:Place)
    WHERE p1.placeId &lt; p2.placeId
    WITH
      p1, p2,
      REDUCE(
        s = 0,
        k IN [
          &#39;isFranchise&#39;, &#39;parkingArrangements&#39;, &#39;placeAccessibility&#39;,
          &#39;placeAlcohol&#39;, &#39;placeArea&#39;, &#39;placeDressCode&#39;, &#39;placeOtherServices&#39;,
          &#39;placePrice&#39;, &#39;placeSmoking&#39;] |
        CASE WHEN p1[k] = p2[k] THEN s + 1 ELSE s END
        ) AS count
    WHERE count &gt; 3
    RETURN p1, p2

The `p1.placeId &lt; p2.placeId` test uses the `&lt;` operator instead of `&lt;&gt;`, to avoid evaluating the same pair of nodes twice (in reverse order).

*NOTE: The `MATCH` clause causes a cartesian product with O(N^2) complexity, so this is an expensive query.* ",1,64558444
3224,https://stackoverflow.com/a/64552344,How to select the node with the highest number of incoming relationships?,true,"You can rewrite the query like this : 

```
MATCH (e:Entity)-[r:PART_OF]-&gt;(s:Solution)
WITH e, s, size((s)&lt;--()) AS incomingCount
ORDER BY incomingCountDesc
RETURN s
LIMIT 1
```",0,64552344
3225,https://stackoverflow.com/a/64558710,How to select the node with the highest number of incoming relationships?,false,"To efficiently get the `Solution` node with the largest number of incoming relationships:

    MATCH (s:Solution)
    RETURN s, SIZE((s)&lt;--()) AS cnt
    ORDER BY cnt DESC
    LIMIT 1

The `SIZE((s)&lt;--())` syntax causes the Cypher planner to generate a very efficient [GetDegree](https://neo4j.com/developer/kb/how-do-i-improve-the-performance-of-counting-number-of-relationships-on-a-node/) operation, which does not require any DB hits. ",0,64558710
3226,https://stackoverflow.com/a/64543131,Neo4J right way of writing a cypher query,true,"With respect to performance, your specific `MATCH` pattern probably does not need to be split up. However, for better (human) readability, you may want to split it up anyway -- the Cypher parser would generally produce the same execution plan either way.

As an example, your query could start with a shorter `MATCH` pattern that is easier to understand and is more closely tied to the `WHERE` clause:

    MATCH (a2:ACCOUNT)&lt;-[:has_corporate_account]-(:CORPORATION)-[:incorporated_in]-&gt;(c:COUNTRY)
    WHERE c.IS_TAX_HAVEN = 1
    MATCH
      (a1:ACCOUNT)-[:transfer_origin]-&gt;(:TRANSFER)&lt;-[:transfer_destination]-(a2),
      (co1:CORPORATION)&lt;-[:is_employee_of]-(:PERSON)-[:has_personal_account]-&gt;(a1)
    RETURN DISTINCT co1

Note that this query returns `DISTINCT co1`, to ensure that the same corporation is not returned more than once.",1,64543131
3227,https://stackoverflow.com/a/64536255,Neo4j Cypher query: Find node by input path,true,"This is the shortest way I could think of.


    WITH [&quot;Root&quot;, &quot;src&quot;, &quot;main&quot;, &quot;java&quot;] AS inputPath     
    MATCH path=(mainRoot)&lt;-[:hasParent*]-(child)
    WHERE LENGTH(path) = SIZE(inputPath)-1
    AND [n IN nodes(path) | n.name] = inputPath
    RETURN path",1,64536255
3228,https://stackoverflow.com/a/64526388,How to add to a string value of a property instead of rewriting it in Cypher Neo4J?,true,"Try this:

    MATCH (c:Context{name:&#39;lisaksa&#39;}) 
    SET c.name = left(c.name,size(c.name)-1) + &#39;o&#39;+&#39;_new&#39;

",1,64526388
3229,https://stackoverflow.com/a/64505623,"Neo4j compare two Arrays, Cypher Query",true,"1. For your use case, it would be much more efficient to update `amenities` to contain a *list* of strings instead of a single comma-delimited string. That way, your query would not need to use `SPLIT` at all. In the following examples, I will continue to use `SPLIT(e.amenities,&quot;,&quot;)`, but ideally that should be replaced by `e.amenities`.

2. If you want to test whether `amenities` contains *all* of the values in a list, you can use the [ALL](https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-all) function:

       MATCH (e:Estate)
       WHERE ALL(a IN [&quot;Laundry&quot;,&quot;Dryer&quot;] WHERE a IN SPLIT(e.amenities,&quot;,&quot;))
       RETURN e

3. If you want to test whether `amenities` contains *any* of the values in a list, you can use the [ANY](https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-all) function:

       MATCH (e:Estate)
       WHERE ANY(a IN [&quot;Laundry&quot;,&quot;Dryer&quot;] WHERE a IN SPLIT(e.amenities,&quot;,&quot;))
       RETURN e
",1,64505623
3230,https://stackoverflow.com/a/64486558,Neo4j/Cypher FOREACH square brackets and use of &quot;THEN [1]&quot;,true,"It&#39;s a bit of a hack to support conditional execution of a statement. Essentially, it&#39;s equivalent to the following pseudocode:

```
IF (rel IS NOT NULL) THEN {
   DELETE rel CREATE (newest)-[:NEXT_SUB_REPLY]-&gt;(prevNewest))
}
```

`FOREACH` will iterate over a collection and execute some operation for each element of the collection. If there are no elements in the collection, the operation won&#39;t run. If there&#39;s one element in the collection, it&#39;ll run once.

As for why it&#39;s `[1]` in the query, it actually doesn&#39;t matter and it&#39;s basically just convention and down to personal taste. It would work the same way with any one-element collection - for example `[true]` or `[null]` should both suffice. The important thing is that truthy leg of the `CASE` statement returns a one-element array, and otherwise a zero-element array.

[The docs](https://neo4j.com/developer/kb/conditional-cypher-execution/) have more information, as well as (arguably) less unreadable alternatives if you&#39;re willing to take a dependency on the APOC library.",1,64486558
3231,https://stackoverflow.com/a/64488537,Assign match result to a second variable and perform filter,true,"You can use a `CASE` clause to generate the `child` variable.

For example:

    MATCH
        (target:Vertex { id : &#39;59255ad6-0397-4b2d-9e69-6999131cea16&#39;})
        &lt;-[:PARENT*]-
        (a:Account {id : &#39;3edcfba7-e95b-4d22-9793-e5f983ebde33&#39;})
    OPTIONAL MATCH
        p=
            (new_parent:Vertex {id : &#39;3a63f643-f437-4415-b046-b324aa697f42&#39;})
            &lt;-[:PARENT*]-
            (a)
    RETURN
        p
        , target
        , CASE WHEN NONE(x IN NODES(p) WHERE x = target) THEN p END AS child

The `CASE` clause will generate `NULL` if none of the `WHEN` clauses apply and there is no `ELSE` clause.",1,64488537
3232,https://stackoverflow.com/a/64474105,How to create random relationships between nodes?,true,"The following query uses [apoc.coll.randomItems](https://neo4j.com/labs/apoc/4.1/data-structures/collection-list-functions/) to get 200 different random accounts at one time (which is much faster than getting one random account 200 times):

    MATCH (ba:BankAccount)
    WITH apoc.coll.randomItems(COLLECT(ba), 200) AS accts
    WHERE SIZE(accts) &gt; 1 
    UNWIND RANGE(0, SIZE(accts)/2*2-1, 2) AS i
    WITH accts[i] AS sender, accts[i+1] AS receiver
    CREATE (sender)-[:TRANSFERED_TO {time: datetime()}]-&gt;(receiver)

Notes:

1. This query uses `CREATE` instead of `MERGE` because it is unlikely that a `TRANSFERED_TO `relationship already exists with the current time as the `time` value. (You can choose to use `MERGE` anyway, if duplication is still possible.)
2. The `WHERE SIZE(accts) &gt; 1` test avoids errors when there are not at least 2 accounts.
3. `SIZE(accts)/2*2-1` calculation prevents the [RANGE](https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-range) function from generating a list index (`i`) that exceeds the last valid index for a `sender` account.",0,64474105
3233,https://stackoverflow.com/a/64462863,fetching a tree for a particular node in neo4j,false,"What about something like this::

    MATCH path=(fromNode:Part{partNumber:&quot;100&quot;})-[:HAS_BOM_PROPERTY]-&gt;(BomNode:BomProperties)-[*]-&gt;(toNode:Part)
    // get all the relationships
    UNWIND relationships(path) AS rel
    // remove duplicates
    WITH DISTINCT rel
    RETURN startNode(rel) AS fromNode,endNode(rel) AS toNode


",1,64462863
3234,https://stackoverflow.com/a/64456185,Spring data neo4j custom @QueryResult doesn&#39;t recognize enums,true,"Below are my entity classes and repository which perfectly works fine.

    @Data
    @QueryResult
    public class PersonResponse {
        private Long id;
        private String name;
        private int age;
        private City livesAt;
        private Test test;
        private List&lt;Person&gt; friends;
    }
    public enum Test {
        A, B
    }

Repository method

 

     @Query(&quot;MATCH (pr:Person) where ID(pr)=$id return ID(pr) as id, pr.test as test, pr.name as name, pr.age as age&quot;)
        public PersonResponse getPerson(Long id);

Result:

    {
      &quot;id&quot;: 68,
      &quot;name&quot;: &quot;Alex&quot;,
      &quot;age&quot;: 24,
      &quot;test&quot;: &quot;A&quot;,
      
    }


",1,64456185
3235,https://stackoverflow.com/a/64453697,Neo4j real-time recommendation performance,true,"If you want to do real-time recommendations using some sort of cosine distance metric on tens of thousands of nodes or more, it is probably best to store the precomputed values as relationships.

As for making the graph dense, you can limit the `SIMILAR` relationship to top K similar nodes and also define the similarity cutoff threshold, which can make your graph as sparse as you would like to. You can only store relevant results. So, for example, in a graph of 10 thousand nodes, if every item has a connection to the top 10 other nodes, this is not a really dense graph. If you also remove duplicate relationships that point from one node to another and back, you could remove them even more. So if there are 10k*10k (divided by two if you are treating the relationships as undirected) relationships possible, you won&#39;t have a billion possible relationships, but only 100k at most.

The [Graph Data Science library][1] supports two algorithms for calculating cosine distance:

The [first naive version][2] calculates the distance between all pairs and can be tuned with `topK` and `similarityCutoff` parameters.

Just recently, the [optimized implementation][3] of the kNN algorithm was added in the GDS 1.4 pre-release. It uses the implementation described in this article: https://dl.acm.org/doi/abs/10.1145/1963405.1963487

However, for real-time calculation of similarity between 10k+ nodes, it might still take more than 100ms you would max the real-time response, so going with the pre-computed similarity relationships makes sense.


  [1]: https://neo4j.com/docs/graph-data-science/current/
  [2]: https://neo4j.com/docs/graph-data-science/current/alpha-algorithms/cosine/
  [3]: https://neo4j.com/docs/graph-data-science/1.4-preview/algorithms/knn/",2,64453697
3236,https://stackoverflow.com/a/64487588,Neo4j real-time recommendation performance,false,"Aside from @TomažBratanič&#39;s great suggestions, your existing query can be made more efficient. It is performing mathematical calculations for every `p1/p2` pair, even for pairs that are later filtered out because the number of shared movies does not exceed 10. Instead, you should try filtering out unwanted `p1/p2` pairs *before* you do the calculations.

For example:

    MATCH
        (p1:User {name: &quot;Cynthia Freeman&quot;})-[x:RATED]-&gt;(m:Movie)&lt;-[y:RATED]-(p2:User)
    WITH
        COLLECT({xr: x.rating, yr: y.rating}) AS data
        p1, p2
    WHERE
        SIZE(data) &gt; 10
    WITH
        REDUCE(s = 0, d IN data | s + d.xr * d.yr) AS xyDotProduct,
        SQRT(REDUCE(xDot = 0.0, a IN data | xDot + a.xr^2)) AS xLength,
        SQRT(REDUCE(yDot = 0.0, b IN data | yDot + b.yr^2)) AS yLength,
        p1, p2
    RETURN 
        p1.name, p2.name, xyDotProduct / (xLength * yLength) AS sim
    ORDER BY sim DESC
    LIMIT 100;",1,64487588
3237,https://stackoverflow.com/a/64443613,Neo4j 4 and .NET Core Identity Framework,false,"&gt;I want to use .NET Core Identity Framework with the new Neo4j version 4 in ASP.net Core but any implementation I looked for, does not support the new Neo4j.

As you mentioned, most of existing example and github demo are built on older version .NET Core and Neo4j, which might not work well with the application built on the latest SDK.

If you do want to implement ASP.NET Core Identity with the new Neo4j, you can refer to the following doc to create a customized storage provider for ASP.NET Core Identity. 

https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity-custom-storage-providers?view=aspnetcore-3.1

 ",1,64443613
3238,https://stackoverflow.com/a/64418190,Find max depth with bidiretional graph,true,"I guess you could solve it by only considering paths in which each node only appears once. Neo4j&#39;s apoc library offers a function for that:

    MATCH p=(u:User)-[:Amico*]-&gt;(f:User)
    WHERE NOT apoc.coll.containsDuplicates(nodes(p))
    RETURN p, length(p) order by length(p) desc limit 1",1,64418190
3239,https://stackoverflow.com/a/64395603,How do I get a list of Neo4j nodes in a directed graph starting from a subnode?,true,"Something like this should get all the nodes in the `B` subtree (including the `B` node).

    MATCH p=(:Foo {label: &#39;B&#39;})-[*0..]-&gt;(n)
    RETURN n

*Warning: [Variable length relationships](https://neo4j.com/docs/developer-manual/3.4/cypher/clauses/match/#varlength-rels) without a reasonable upper bound can run for a very long time and/or run out of memory.*",1,64395603
3240,https://stackoverflow.com/a/64393107,Neo4j Cypher query for a linked list to conditionally create a NEWEST_REPLY vs modifying NEWEST_REPLY to NEXT_REPLY,false,"You can do this to delete any existing `[:NEWEST_REPLY]` rels:

    MATCH (p:Post {id: $postId})
    OPTIONAL MATCH (p)-[rel:NEWEST_REPLY]-&gt;(previousNewestReply:Reply)
    WITH p,previousNewestReply,
    // create a collection of size 1 or 0
         CASE WHEN NOT rel IS NULL THEN [rel] ELSE [] END AS toBeDeleted

    // loop through the collection
    FOREACH( tbd IN toBeDeleted | DELETE tbd )


    WITH p,previousNewestReply
    .....

",0,64393107
3241,https://stackoverflow.com/a/64395505,Neo4j Cypher query for a linked list to conditionally create a NEWEST_REPLY vs modifying NEWEST_REPLY to NEXT_REPLY,true,"[UPDATED]

This query should work for you:

    MATCH (p:Post), (u:User)
    WHERE p.id = $postId AND u.id = $userId
    OPTIONAL MATCH (p)-[rel:NEWEST_REPLY]-&gt;(prevNewest:Reply)
    CREATE (u)-[:WROTE]-&gt;(r:Reply {id: apoc.create.uuid(), body: &quot;foo&quot;, createdAt: datetime(), updatedAt: datetime()})&lt;-[:NEWEST_REPLY]-(p)
    FOREACH(_ IN CASE WHEN rel IS NOT NULL THEN [1] END | DELETE rel CREATE (r)-[:NEXT_REPLY]-&gt;(prevNewest))

I asssume `postId` and `userId` are passed as [parameters](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/). Also, you should create [indexes](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/) on `:Post(di)` and `:User(id)` to speed up the query.",1,64395505
3242,https://stackoverflow.com/a/64381095,Neo4j get the biggest node whose property is smaller than a specific value,true,"Assuming all `Node`s with the same `NodeID` are in a `type` path rooted at the `Current` node with the same `NodeID`, then the following query should be logically equivalent but faster:

    MATCH (m:Node)
    WHERE m.NodeID = $id AND m.Level &lt; $n
    RETURN m
    ORDER BY m.Level DESC
    LIMIT 1

This query assumes `id` and `n` are query [parameters](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/).",0,64381095
3243,https://stackoverflow.com/a/64395656,Cypher: Group by community id,true,"`(a:ARTICLE)-[:SIMILAR]-(a:ARTICLE)` incorrectly requires both nodes to be the same (since both use the `a` variable).

In any case, there is no need to even match the relationship.

This should work:

    MATCH (a:ARTICLE)
    RETURN a.community as id, COLLECT(a) AS articles

",1,64395656
3244,https://stackoverflow.com/a/64388179,Is there a simple way to &quot;unpack&quot; a list in Neo4j?,true,"Easiest to use the apoc library for that.
Depending on what you would like as an outcome:


A collection

    WITH &quot;[1,1,3,10]&quot; AS string
    UNWIND apoc.convert.fromJsonList(string) AS elements
    RETURN elements

or a map

    WITH &quot;[1,1,3,10]&quot; AS string
    WITH apoc.convert.fromJsonList(string) AS collection
    RETURN apoc.map.fromPairs(
             REDUCE(arr=[],i IN collection | 
                    arr
                    +[[&#39;elem&#39;+toString(size(arr)),i]]
             )
         ) AS map


",1,64388179
3245,https://stackoverflow.com/a/64363062,Neo4J Movie-Graph - actors with same age,true,"1. It is bad practice to add redundant data (eg, relationships that duplicate information you can already get from the DB in other ways) unless there is a really good reason for it (eg, you cannot meet a strict performance requirement otherwise).

   It is easy to get all actors born in the same year without a relationship. For example:

       MATCH (p:Person)
       RETURN p.born AS year, COLLECT(p) AS actors

   So, unless you have a critical need to get the same information a little faster, you should just use the above kind of query instead of storing redundant relationships.


2. However, if you *really* do need to add the relationships, you can do something like this:

       MATCH (p:Person)
       WITH p.born AS year, COLLECT(p) AS ps
       UNWIND apoc.coll.combinations(ps, 2) AS pair
       WITH pair[0] AS p1, pair[1] AS p2
       MERGE (p1)-[:HAS_SAME_AGE]-(p2)
 
    The APOC function [apoc.coll.combinations](https://neo4j.com/labs/apoc/4.1/overview/apoc.coll/apoc.coll.combinations/) is used to generate distinct pairs of actors born in the same year.

",0,64363062
3246,https://stackoverflow.com/a/64359002,Neo4j Cypher - Changing datetime to epoch timestamp,true,"Temporal instants (like `DateTime`) support many [properties](https://neo4j.com/docs/cypher-manual/current/syntax/temporal/#cypher-temporal-accessing-components-temporal-instants), and among them are `epochMillis` (and `epochSeconds`).

For example:

    RETURN datetime({epochMillis: 1571518672541}).epochMillis

will return `1571518672541`.",2,64359002
3247,https://stackoverflow.com/a/64359292,Why there is link between parent node and child node in neo4j,false,"The query you used to generate your visualization apparently only returned `TweetLeaf` nodes, so the neo4j Browser only showed those nodes.

Instead, try using this query (which returns all paths of length 0 or 1 involving a `TweetLeaf` node):

    MATCH p=(:TweetLeaf)-[*0..1]-()
    RETURN p

*A path of length 0 would have no relationship, in case there are standalone `TweetLeaf` nodes. If you do not care about that edge case, then you can just use `p=(:TweetLeaf)--()` instead.*",0,64359292
3248,https://stackoverflow.com/a/64359750,How to know if timeout occurred in cypher query?,false,"An [APOC enhancement request](https://github.com/neo4j-contrib/neo4j-apoc-procedures/issues/1233) was created for this in 2019.

And there were a couple of commits addressing this, but they have not been merged for some reason. You may want to add comments to that request.",1,64359750
3249,https://stackoverflow.com/a/64359991,Combine two cypher queries into single query and single result,true,"Something like this may work for you:

    MATCH (calc)&lt;-[:SOME]-(p:People)-[:LOCATED_IN]-&gt;(a1:Address)
    WITH a1.country AS name,
         COUNT(*) AS count,
         AVG(calc.value) AS value,
         COLLECT(DISTINCT p) AS pList
    UNWIND pList AS p1
    OPTIONAL MATCH (p1)-[:FRIEND_WITH]-&gt;(:Person)-[:LOCATED_IN]-&gt;(a2:Address)
    WHERE name &lt;&gt; a2.country
    RETURN name, count, value, COLLECT(DISTINCT a2.country) AS knowsAlso",1,64359991
3250,https://stackoverflow.com/a/64345767,Neo4J Cypher - subtract duration from timestamp,true,"*Yes, the temporal values and functions are pretty complex, and the documentation is scattered and dense.*

The [timestamp](https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-timestamp) function returns an integer. But a [Duration](https://neo4j.com/docs/cypher-manual/current/syntax/temporal/#cypher-temporal-durations) (which can be constructed using the [duration](https://neo4j.com/docs/cypher-manual/current/functions/temporal/duration/) function) can only be subtracted from a [temporal instant](https://neo4j.com/docs/cypher-manual/current/syntax/temporal/#cypher-temporal-instants) (for example, a `DateTime`, which can be constructed using the [datetime](https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/#functions-datetime) function).

So, for simplicity, the `first_submitted` property value should be something like a `DateTime` (which represents a date and time) instead of an integer. For example:

    CREATE (:data {id: 123, first_submitted: datetime()})

Assuming that is true, your query could look like this:

    WITH datetime()-duration(&#39;P14D&#39;) AS threshold
    MATCH (u:data)
    WHERE u.first_submitted &gt; threshold
    RETURN u.first_submitted LIMIT 10

Note: it is not necessary to test that the stored DateTime is *before* the current DateTime, since presumably all `first_submitted` values are in the past.

Also, you may want to create an [index](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/) on `:data(first_submitted)` to improve performance.",1,64345767
3251,https://stackoverflow.com/a/64342952,How to improve query efficiency in Neo4j?,false,"Your query is putting each `Author` into `export_nodes` multiple times, and each `CO_AUTHORSHIP` relationship into `export_rels` multiple times. This should be faster and use less memory:

    MATCH path = (a:Author)-[r:CO_AUTHORSHIP]-()
    WITH COLLECT(DISTINCT a) AS export_nodes, COLLECT(DISTINCT r) AS export_rels
    CALL apoc.export.cypher.data(
      export_nodes, export_rels, &#39;/tmp/export.cypher&#39;, 
      {format:&#39;cypher-shell&#39;, cypherFormat: &#39;updateAll&#39;}) YIELD nodes, relationships, time
    RETURN nodes, relationships, time",0,64342952
3252,https://stackoverflow.com/a/64334443,Neo4J Unicity wonders : singleton or aggregation issue,false,"You have to change your query to first MERGE your nodes and then MERGE the relationships:

    MERGE (a:Person {name:&#39;Alice&#39;})
    MERGE (b:Person {name:&#39;Bob&#39;})
    MERGE (a)-[x:KNOWS {since:1999}]-&gt;(b)",0,64334443
3253,https://stackoverflow.com/a/64333603,Cypher query with group by inside aggregation,true,"You can solve this with a `CASE` statement:

    Match (people:People)-[:LOCATED_IN]-&gt;(address:Address), (people)-[:SOME]-&gt;(calc)
    RETURN CASE WHEN address.country in [&#39;PL&#39;,&#39;UK&#39;] THEN &#39;Custom&#39; ELSE address.country END as name, 
      count(*) as count, avg(calc.value) as value",1,64333603
3254,https://stackoverflow.com/a/64339914,Cypher query with group by inside aggregation,false,"You could use a custom name map and the [COALESCE](https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-coalesce) function. You could even pass the (possibly empty) map as a [parameter](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/) (instead of defining it statically) if the custom name mapping can change.

    WITH {PL: &#39;Custom&#39;, UK: &#39;Custom&#39;} AS cMap
    MATCH (calc)&lt;-[:SOME]-(people:People)-[:LOCATED_IN]-&gt;(address:Address)
    RETURN
      COALESCE(cMap[address.country], address.country) as name, 
      COUNT(*) AS count,
      AVG(calc.value) AS value

",1,64339914
3255,https://stackoverflow.com/a/64362919,neo4j: Shortest path that includes specific relationship,false,"If the center of universe is HAS_SKILL, I&#39;d suggest looking into anchoring on that relationship, and then path find from the relationships start/end nodes.  Something like this

match (p:Person)-[:HAS_SKILL]-&gt;(s:Skill)

Then perhaps determine the shortest path from the specific person to those p, then take just the s skill&#39;s those shortest paths p point to and then shortest path find from those s to the specific skill.

I don&#39;t know if there is more we could suggest without knowing more about the actual model and challenge.",0,64362919
3256,https://stackoverflow.com/a/64323645,how to create tree structure in neo4j with multiple relationships?,true,"1. None of the `TweetLeaf` nodes have a &quot;retweet_id&quot; property. And, although some *do* have the &quot;retweet_to&quot; property (which may be a typo), none of the corresponding values is &quot;123&quot;. So, either way, your query can never succeed.

2. Also, you should use [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) to avoid creating duplicate nodes. This query may work better (once you have fixed above issue #1):

       MATCH (c:TweetLeaf), (parent:Node {id: c.reply_to}), (retweet:Node {id: c.retweet_id})
       MERGE (c)-[:reply_to]-&gt;(parent)
       MERGE (c)-[:retweet]-&gt;(retweet)

",1,64323645
3257,https://stackoverflow.com/a/64309484,Cypher - finding most common user + storing it,false," 1. Your query is actually incorrect correct. It should have been:

    MATCH (u:User)
    RETURN u
    ORDER BY u.upvotes DESC
    LIMIT 1

 2. I assume that you are following the example in [this log post](https://neo4j.com/blog/import-10m-stack-overflow-questions/). To also *efficiently* get the number of outgoing `POSTED` relationships made by the user with the most upvotes:

        MATCH (u:User)
        WITH u
        ORDER BY u.upvotes DESC
        LIMIT 1
        RETURN u, SIZE((u)-[:POSTED]-&gt;()) AS nPosts",0,64309484
3258,https://stackoverflow.com/a/64283267,Neo4j/GraphQL - get the last node in a linked list in order to continue the linked list with newly created nodes,false,"So, some confusion on my part. Someone else created the schema with FIRST_POST being the most recently created post rather than the first post created. Renaming it to NEWEST_POST, I can no do this:
```
MATCH (u:User {id: $userId})-[:MEMBER_OF]-&gt;(g:Group)-[rel:NEWEST_POST]-&gt;(previousNewestPost:Post)
DELETE rel
CREATE (p:Post { id: apoc.create.uuid(), body: &#39;test new post&#39;, createdAt: datetime(), updatedAt: datetime() }) 
WITH p, g, previousNewestPost
MATCH (u:User)
WHERE u.id = $userId 
CREATE (p)&lt;-[:WROTE]-(u)
CREATE (p)&lt;-[:NEWEST_POST]-(g)
CREATE (p)-[:NEXT_POST]-&gt;(previousNewestPost)
RETURN u, p
```
to create a new post and update the relationships accordingly. ",0,64283267
3259,https://stackoverflow.com/a/64272337,"problem with Neo4j query, calling foreach for the previous match results",false,"Since `$fNames` is already a list, `[$fNames]` would enclose that list within another list -- which is not what you intended. You should just use `$fNames` as-is:

    MATCH (user:User {name: $name}), (friend:User)
    WHERE friend.name IN $fNames
    CREATE (user)-[f:FRIEND]-&gt;(friend)
    RETURN f

Also, to speed up this query, you should consider creating an [index](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/) on `:User(name)`.
",1,64272337
3260,https://stackoverflow.com/a/64268094,Neo4j match a random single node of a certain type of nodes,true,"You can use the apoc function [apoc.coll.randomItem](https://neo4j-contrib.github.io/neo4j-apoc-procedures/3.5/utilities/collection-list-functions/) to pick out a random node from a collection of all the `Group` nodes:

    MATCH (x:Group)
    WITH datetime() AS dt, apoc.coll.randomItem(COLLECT(x)) AS g
    CREATE (u:User {
      id: apoc.create.uuid(), 
      firstName: $firstName, 
      username: $username, 
      phoneNumber: $phoneNumber, 
      createdAt: dt,
      updatedAt: dt,
      role: &#39;USER&#39;
    })-[:MEMBER_OF]-&gt;(g)
    RETURN u",1,64268094
3261,https://stackoverflow.com/a/64267714,Neo4j forming json array,true," 1. Since [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) will create the entire pattern if any part of it does not already exist, you should use it with a node pattern that contains only properties that uniquely identify the node. You can use `ON CREATE` afterwards to set any other properties  that need to be set if the node needs to be created.

 2. A list (`[...]`) cannot contain property names. You proably want to use a map (`{a: ..., b: ...}`) instead.

 3. Property names that are numeric (or contain special characters) cannot be referenced normally. You can use other syntaxes; for example `event[&#39;123&#39;]`

This might work better for tyou this:

    ...
    MERGE (n:item {id: event.id})
    ON CREATE SET n.description = {x:event[&#39;123&#39;], y:event[&#39;456&#39;], z:event[&#39;789&#39;]}


",0,64267714
3262,https://stackoverflow.com/a/64254037,How to create histogram output using neo4j Cypher query?,true,"Here is an example of how to get the number of `Entity` nodes whose `create_time` values fall within the last N M-day windows:

    WITH timestamp() AS now
    MATCH (e:Entity)
    WHERE e.create_time &gt; now - ($nPeriods * $periodMillis)
    RETURN (now - e.create_time)/$periodMillis AS period, COUNT(*) AS cnt
    ORDER BY period

The query assumes that you pass `M` and `N` via the `periodMillis` and `nPeriods` [query parameters](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/). For example, if you want each period to be 30 days, and to see the counts for the last 5 periods, you can can pass `30*24*60*60*1000` as `periodMillis` and 5 as `nPeriods`.

To speed up this query, you should also create an [index](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/) on `:Entity(create_time)`.

Here is a sample result (using the above sample numbers):

    ╒════════╤═════╕
    │&quot;period&quot;│&quot;cnt&quot;│
    ╞════════╪═════╡
    │0       │22   │
    ├────────┼─────┤
    │1       │20   │
    ├────────┼─────┤
    │2       │101  │
    ├────────┼─────┤
    │3       │62   │
    ├────────┼─────┤
    │4       │44   │
    └────────┴─────┘
    
Period 0 is for the last 30 days (the period ends &quot;now&quot;, not at midnight), period 1 is for the 30 days before that, and so forth. *Using midnight as the boundary is more complicated and would probably require you to specify a timezone and use temporal functions (like [these](https://neo4j.com/docs/cypher-manual/current/syntax/temporal/)).*

[UPDATE]

If your period is a month, you can use the neo4j [temporal values and functions](https://neo4j.com/docs/cypher-manual/current/syntax/temporal/#cypher-temporal) to perform calculations that respect the actual number of days in a month.

For example, if the parameter `nMonths` provides the maximum number of monthly periods:

    WITH date() AS today
    MATCH (e:Entity)
    WITH duration.inMonths(e.create_time, today).months AS period
    WHERE period &lt; $nMonths
    RETURN period, COUNT(*) AS cnt
    ORDER BY period

",0,64254037
3263,https://stackoverflow.com/a/64218588,How do I choose to create a node based on whether it exists in the database in neo4j?,true,"That error was caused by a missing `|` in each of your [FOREACH](https://neo4j.com/docs/cypher-manual/current/clauses/foreach/) clauses. For example, this would fix that syntax error:

    FOREACH (a in ( CASE WHEN NOT m IN known_place THEN [1] ELSE [] END ) | CREATE (n)-[:present_at] -&gt;(m))
    FOREACH (a in ( CASE WHEN NOT o IN known_thing THEN [1] ELSE [] END ) | CREATE (m)-[:is] -&gt;(o))

However, your query would still have numerous other syntax errors.

In fact, the entire query could be refactored to be simpler and more efficient:

    WITH {id: 123} AS abc, {id: 234} as def, {id: 345} AS abcd

    MERGE (n:Person{id: abc.id}) 
    MERGE (m:Place{place: def.id}) 
    MERGE (o:Thing{id: abcd.id})
    FOREACH (a in ( CASE WHEN NOT EXISTS((n)–[:present_at]-&gt;(m)) THEN [1] END ) | CREATE (n)-[:present_at]-&gt;(m))
    FOREACH (a in ( CASE WHEN NOT EXISTS((m)–[:is]-&gt;(o)) THEN [1] END ) | CREATE (m)-[:is]-&gt;(o))

",0,64218588
3264,https://stackoverflow.com/a/64218385,Neo4J Cypher query equivalent to select for update,true,"You can use one of the APOC [atomic property update](https://neo4j.com/labs/apoc/4.1/graph-updates/atomic-updates/) procedures to update the `sentData` property *atomically*.

For example, even if there is a race condition (such that both transactions see a false `sentData`), this query should ensure that only one transaction will return `n`:

&lt;!-- language-all: lang-Cypher --&gt;

    MATCH (n:Foo)
    WHERE NOT n.sentData
    CALL apoc.atomic.update(n, &#39;sentData&#39;, &#39;true&#39;, 5) YIELD oldValue, newValue
    WHERE apoc.convert.toBoolean(newValue) AND NOT apoc.convert.toBoolean(oldValue)
    RETURN n",1,64218385
3265,https://stackoverflow.com/a/64208608,Neo4j: Count the number of neighbours with a specific label for each node,true,"a general approach could be along these lines, finding any node with label `:LabelA`  that has not exactly two neighbours (regardless of direction of the relationship) with label `LabelB`

    MATCH (n:LabelA)
    WITH n,
         SIZE([(n)--(m:LabelB) | m ])  AS nodeCountLabelB
    WHERE nodeCountLabelB &lt;&gt; 2
    RETURN n
       
",1,64208608
3266,https://stackoverflow.com/a/64218698,Neo4j: Count the number of neighbours with a specific label for each node,false,"Here is one way to get the id of each `parent` node that has the wrong number of child nodes, along with a (possibly empty) list of its existing child ids:

    MATCH (parent:parent_name)
    WITH parent.id AS parentId, [(parent)--&gt;(child:child_name) | child.id] AS childIds
    WHERE SIZE(childIds) &lt;&gt; 2
    RETURN parentId, childIds

",1,64218698
3267,https://stackoverflow.com/a/64205665,how to extract the properties from a neo4j cypher collection from the query result,true,"When you want to retrieve properties from a set of relationships, you could do this:

    MATCH (n)-[r]-&gt;(m)
    WHERE   // your WHERE clause

    // return a list of maps with keys `id` and `properties`
    RETURN {id:id(r),properties:properties(r)}) AS Shipper
    

OR
    
    // return just the properties as a map
    RETURN properties(r) AS propertiesMap

OR

    // return a collection of maps
    RETURN COLLECT(properties(r)) AS listOfPropertyMaps


",2,64205665
3268,https://stackoverflow.com/a/64193768,Neo4j ver. 4.1.1 Cypher Syntax Error &quot;USING PERIODIC COMMIT&quot;,false,"did you try

    DELETE n,r 

on line 3?

Btw purging a store could also be done like this, which is probably faster.

    MATCH (n)
    DETACH DELETE n",0,64193768
3269,https://stackoverflow.com/a/64191650,How to merge multiple filed which contain null value,false,"To avoid duplications of tweets, you do not have to include all properties in the MERGE. Just the id that uniquely identifies the tweet.

    MERGE (t:Tweets {id:value.id})
    SET t.prop1= value.prop1,
            t.prop2= value.prop2

 should do it, and you do not have to worry about nulls.

Make sure you have an index / constraint set on Tweets.id

",1,64191650
3270,https://stackoverflow.com/a/64199336,How to merge multiple filed which contain null value,true,"When you [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) a node, you should only specify the properties that *uniquely identify* that node. That way, if the node already existed but some *non-identifying* properties have different values, the `MERGE` will not create a new node.

I will assume that in your data model the `id` property value uniquely identifies a `Tweet` node (renamed from `Tweets`, since each node represents just one tweet).

Also, I will assume that you want to set to the non-identifying properties only when a `Tweet` node is `first created`. To ensure that, the query below uses [ON CREATE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/#merge-merge-with-on-create).

    CALL apoc.load.json(&quot;file:///tweets.json&quot;) YIELD value
    MERGE (t:Tweet {id: value.id})
    ON CREATE SET t += value{
      .created_at, .text, .user_id, .retweet_id, .retweet_user_id,
      .user_mentions, .replyto_id, .replyto_user_id}

",0,64199336
3271,https://stackoverflow.com/a/64183820,delete and update properties of neo4j nodes,true,"The cypher you use would set `username` to `null` in case `userrname` does not exist.

So you have to limit your MATCH to the nodes where `userrname` exists

    MATCH (u:User) 
    WHERE EXISTS(u.userrname)
    
    SET u.username = u.userrname 
    REMOVE u.userrname",1,64183820
3272,https://stackoverflow.com/a/64170284,&quot;Query Optimization&quot; : Neo4j Query builds a cartesian product between disconnected patterns -,false,"If you are looking for to avoid the cartesian product issue with the given query

    WITH [&quot;1258311979208519680&quot;,&quot;3294971891&quot;,&quot;1176078684270333952&quot;,”117607868427845”] as ids 
        MATCH (n1:Target),(n2:Target) WHERE n1.id in ids and n2.id in ids and n1.id&lt;&gt;n2.id and n1.uid=103 and n2.uid=103 
        MATCH p = ((n1)-[*..3]-(n2)) RETURN p limit 30

I suggest to use this one below

    MATCH (node1:Target) WHERE node1.id IN [&quot;1258311979208519680&quot;,&quot;3294971891&quot;,&quot;1176078684270333952&quot;]
    MATCH (node2:Target) WHERE node2.id IN [&quot;1258311979208519680&quot;,&quot;3294971891&quot;,&quot;1176078684270333952&quot;]
    and node1.id &lt;&gt; node2.id
    MATCH p=(node1)-[*..2]-(node2) 
    RETURN p

It will remove the cartesian product issue. 
Try this..",0,64170284
3273,https://stackoverflow.com/a/64163216,RegEx that matches &quot;variable&quot; strings/sequences? + backtracking?,false,"I don’t understand your question, but this regex could be the answer:

    &lt;prefix&gt;.*?\b

Where `&lt;prefix&gt;` is `w` or `whe` etc.

This will match all words in the input that start with the prefix.

In whatever language you’re using, there should be a way to loop over all matches found for a given input.",0,64163216
3274,https://stackoverflow.com/a/64154630,Improve performance of neo4j query with multiple OPTIONAL MATCH,true,"Instead of traversing the whole graph, you will want to move the filtering part of the cypher queries sooner in the query.

    MATCH (s:Source),
    (s)-[:SourceContext]-&gt;(c:Context),
    (c)-[:ContextFunction]-&gt;(f:Function)
    WHERE s.id = 16
    OPTIONAL MATCH (c)&lt;-[*1..2]-(e:Entity)
    WHERE e.id = 16260 or e.id is null
    OPTIONAL MATCH (c)&lt;-[*1..2]-(au:Author)
    OPTIONAL MATCH (c)&lt;-[*1..2]-(p:Period)
    OPTIONAL MATCH (c)&lt;-[*1..2]-(u:Unit)
    OPTIONAL MATCH (c)&lt;-[*1..2]-(a:AttributeSet)
    WHERE a.id = 0 or a.id is NULL
    OPTIONAL MATCH (c)&lt;-[*1..2]-(t:Timeseries)
    WHERE t.id = 3450 or t.id is null
    WITH e,t,p,u,s,a,f,au
    return {SourceID: s.id, EntityID: e.id, TimeSeriesID: t.id, PeriodID: p.id, UnitID: u.id, FunctionID: f.id, AttributeSetID: a.id}

This should greatly improve the query performance as you will be starting from only a single Source node instead of traversing all the source nodes in your graph.

It would also help if your graph model supports adding relationship types to the `OPTIONAL MATCH`es.

For example:

    OPTIONAL MATCH (c)&lt;-[:HAS_AUTHOR*1..2]-(au:Author)

This way you avoid traversing all the relationship types in each `OPTIONAL MATCH`.
If not, there are still some improvements you could make.
You could run the 

```
OPTIONAL MATCH (c)&lt;-[*1..2]-(node)
```

And then filter the results based on node type:

```
CASE WHEN node:Author THEN ... ELSE ... END
```
",1,64154630
3275,https://stackoverflow.com/a/64154758,"Neo4j CQL: For each node, return oldest related node X",true,"Try the following query:

    MATCH (p:Post)-[:USED_EMAIL]-&gt;(e:Email)
    WITH p, e.address as email
      ORDER BY p.createdAt ASC
    WITH email, collect(p.createdAt)[0] as first_post
    RETURN email, first_post, duration.inMonths(datetime(collection[0]), datetime()).months AS durationMonths",0,64154758
3276,https://stackoverflow.com/a/64162851,How to fetch indirect relations through another node recursively in Neo4j?,false,"just a note &#39;virtual&#39; relationships are not involved in this as far as I can tell, I think you mean to say variable/unspecified relationships?

It is possible to return any length path from Tom Hanks you were on the right path, just drop the relationship type, and if you drop the &lt;&gt; the search is undirected paths, in any direction like this.  I don&#39;t think this is what you want, if left unbounded it would return the entire graph

    match p=(p1:Person {name:&#39;Tom Hanks&#39;})-[*]-()
    return p
    LIMIT 10

Note: I added the LIMIT 10 just to be safe, it is good practice, at least until you are sure the query does what you want.

Can you give an example of a query result that you expect to see?  how far down do you want to recurse (you can specify depth e.g. *..2), and through every relationship type?


",0,64162851
3277,https://stackoverflow.com/a/64136270,neo4j - cypher query to find nodes which properties match object parameter,true,"it is doable with apoc, basically by matching the `obj` with a submap of the properties, containing only the keys that are also present in `obj`


    WITH { first : &quot;first&quot; } AS obj
    MATCH (c)
    WHERE apoc.map.submap(properties(c),keys(obj),[],false)= obj
    RETURN c",2,64136270
3278,https://stackoverflow.com/a/64126130,Getting counts of a specific list of labels from a Neo4j result set,false,"What about

     WITH u
     RETURN 
     SIZE ( [(u)-[:PARENT_OF]-(l:featureCount0) | l]) AS feature0


and so on? ",0,64126130
3279,https://stackoverflow.com/a/64126421,Getting counts of a specific list of labels from a Neo4j result set,true,"The [aggregating function](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) `COUNT` does not care if the value it is counting happens to be a boolean `true` or `false` -- it will happily count all values.

This query may work for you. It minimizes the number of DB hits by looking up the nodes of interest once.

    MATCH (u:bar)-[:PARENT_OF]-&gt;(l:foo)
    WHERE ID(u) = 927646 // Target bar ID for testing
    WITH COLLECT(l) AS foos
    UNWIND RANGE(0, 5) AS i
    RETURN i, REDUCE(s = 0, x IN foos | CASE WHEN &#39;featureCount&#39;+i IN LABELS(x) THEN s + 1 ELSE s END) AS count

The result will look like this (with some made-up counts):

    ╒═══╤═══════╕
    │&quot;i&quot;│&quot;count&quot;│
    ╞═══╪═══════╡
    │0  │52     │
    ├───┼───────┤
    │1  │50     │
    ├───┼───────┤
    │2  │47     │
    ├───┼───────┤
    │3  │41     │
    ├───┼───────┤
    │4  │33     │
    ├───┼───────┤
    │5  │9      │
    └───┴───────┘",1,64126421
3280,https://stackoverflow.com/a/64107517,count the number of nodes after shortest path neo4j,false,"Use [nodes][1] function in conjunction with [UNWIND][2]:
```
MATCH (FooB:Actor { name: &#39;Foob&#39; }),(AnnaH:Actor { name: &#39;Anna Hathaway&#39; }), p = shortestPath((Foob)-[act:ACTED_IN*]-(AnnaH))
UNWIND nodes(p) AS n
WITH n AS n
WHERE n.chocolate
RETURN COUNT(*)
```


  [1]: https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-nodes
  [2]: https://neo4j.com/docs/cypher-manual/current/clauses/unwind/",1,64107517
3281,https://stackoverflow.com/a/64108433,count the number of nodes after shortest path neo4j,true,"This should do it

    RETURN SIZE([n IN nodes(p) WHERE n:chocolate]) AS count",2,64108433
3282,https://stackoverflow.com/a/64091009,Neo4j (cypher): How do I find all nodes with a specific relationship?,false,"# I think I found an answer, but please provide a better solution if you find flaws

```MATCH (n)-[r:ARTICLE_OF]-&gt;(k) RETURN n, r, k``` 

Did the trick, I think",0,64091009
3283,https://stackoverflow.com/a/64109388,Neo4j (cypher): How do I find all nodes with a specific relationship?,true,"Since your question uses the `neo4j-browser` tag, I assume you are using the Neo4j Browser.

The Neo4j Browser has a quick way to display (up to 25) instances of a relationship type. In the Browser&#39;s left-hand sidebar, you&#39;ll see a `Relationship Types` section. If you click on one of the relationship types in that section, the Browser will execute a query to get the relationships of that type (limited to 25). You can adjust the query (e.g., by increasing or removing the `LIMIT`) as you wish.

Here is an example of a generated query:

    MATCH p=()-[r:ARTICLE_OF]-&gt;() RETURN p LIMIT 25

*NOTE: The `r` variable can be omitted, as it is never used.*",1,64109388
3284,https://stackoverflow.com/a/64049481,Return data if relationship doesn&#39;t exists between the two nodes Neo4j,true,"You could use the following two queries:

 1. query:

    Match (order:Order)
    WHERE (order)-[:HAS_STATUS]-(:Status{code:&quot;COMPLETED&quot;})
    return order{.*}

 2. query:


    Match (order:Order)
    WHERE NOT (order)-[:HAS_STATUS]-(:Status{code:&quot;COMPLETED&quot;})
    return order{.*}",1,64049481
3285,https://stackoverflow.com/a/64038241,Neo4J apoc.create.vRelationship unique relationsip,true,"You can use `WITH DISTINCT p, c` to filter out duplicate `p` and `c` pairs, so that there will only be a single virtual relationship between each pair:

    MATCH (p:part)&lt;-[:SUPPLIES]-(:supplier)-[:LOCATED_IN]-&gt;(c:country)
    WITH DISTINCT p, c
    RETURN p, c, apoc.create.vRelationship(p, &#39;IS_IN&#39;, {}, c) as rel

",1,64038241
3286,https://stackoverflow.com/a/64025123,Cypher Connect nodes in a path returned by gds.alpha.kShortestPaths.stream,true,"You can do this programmatically with:

    YIELD index, path
    WITH index, nodes(path) as nodes
    WITH index, nodes, size(nodes) as number_of_nodes
    UNWIND range(0,number_of_nodes - 2) as start
    WITH index, nodes[start] as start_node, nodes[start + 1] as end_node
    MATCH (start_node)-[r:NEXT]-&gt;(end_node)
    RETURN index, start_node,r, end_node",1,64025123
3287,https://stackoverflow.com/a/64016650,How to create constraint on multiple properties in Neo4j,true,"Are you sure all `TimeGender` nodes have all 3 properties?

You can execute this query will to check. It will return any `TimeGender` nodes that are missing some of those properties.

    MATCH (tg:TimeGender)
    WHERE tg.date IS NULL OR tg.time IS NULL OR tg.sex IS NULL
    RETURN tg",0,64016650
3288,https://stackoverflow.com/a/64016549,How can I create a node and use to this node in query at the same time in Neo4j?,true,"As the error states, you need to specify a [WITH](https://neo4j.com/docs/cypher-manual/current/clauses/with/) clause between a `SET` and a `CALL`.

So, just do this:

    MERGE (temp:Temp)
    SET temp = {tid: &#39;blabla&#39;, title_ids: [], pid: &#39;blabla&#39;}
    WITH temp
    CALL apoc.periodic.commit(
    ...

and near the bottom of your query, you can remove the `MATCH (temp:Temp)` clause.

With respect to query tuning, you should read the [documentation](https://neo4j.com/docs/cypher-manual/current/query-tuning/). There are also many related questions in Stackoverflow.

",2,64016549
3289,https://stackoverflow.com/a/64014273,Neo4j if a node has no outgoing edges delete that node otherwise return its next nodes,true,"[UPDATED]

The following query uses a `FOREACH` hack to conditionally delete `m`, and returns either the found `n` nodes, or `NULL` if there were none.

    OPTIONAL MATCH (m:Node {...Properties...})-[:type]-&gt;(n:Node)
    FOREACH(x IN CASE WHEN n IS NULL THEN [1] END | DETACH DELETE m)
    RETURN n

You could also use the APOC procedure [apoc.do.when](https://neo4j.com/labs/apoc/4.1/cypher-execution/conditionals/) instead of the `FOREACH` hack:

    OPTIONAL MATCH (m:Node {...Properties...})-[:type]-&gt;(n:Node)
    CALL apoc.do.when(n IS NULL, &#39;DETACH DELETE m&#39;, &#39;&#39;, {m: m}) YIELD value
    RETURN n",0,64014273
3290,https://stackoverflow.com/a/64014441,Neo4J / Cypher: How to filter for the path with the latest date in the relationship?,true,"*For simplicity, I will assume that you will first change the `date` property to be easily ordered (e.g., you use a [date](https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/#functions-date-calendar) value,  or you use the format &#39;2009-09-14&#39;).*

You can use `ORDER BY` and `LIMIT` to get the single latest result:

    MATCH (p:Person)-[e:Evaluated {rating:3, characteristic: &quot;quality of kitchen&quot;}]-&gt;(h:House {address: &#39;123 Main St&#39;})
    RETURN p, e, h
    ORDER BY e.date DESC
    LIMIT 1

",0,64014441
3291,https://stackoverflow.com/a/64006169,Graph generation in Neo4j for GDS computations,true,"Judging by your import query, your relationships only exists between nodes A and B. There are no relationships between nodes labeled A. In general, only relationships that have both the source node and the target node described in the Node Projection part are loaded. In your case, there are no relationships that have both the source and the target node with a label A. If you load both labels A and B, then the GDS should load all the relationships.

    CALL gds.graph.create(&#39;mySampleGraph&#39;,[&#39;A&#39;, &#39;B&#39;],[&#39;HAS_SENT&#39;])

Btw... is there any specific reason to have two labels instead of one?",0,64006169
3292,https://stackoverflow.com/a/63996619,Iterate through Neo4j graph matching on node properties,false,"This should work:

    // put the searchstring in a variable
    WITH &#39;,841,&#39; AS searchstring
    
    // look up start end endnode
    MATCH (startNode: .... {...}), (endNode:  .... {...})
    
    // look for paths of variable length
    // that have your search string in all nodes, 
    // except the first and the last one

    WITH searchstring,startNode,endNode
    MATCH path=(startnode)-[:BELONG_TO|IS_CONNECTED*]-(endnode)
    WHERE ALL(i IN nodes(path)[1..-1] WHERE i.VlanList CONTAINS searchstring)
    RETURN path

You can also look at https://neo4j.com/labs/apoc/4.1/graph-querying/path-expander/ for more ideas about how you can limit the pathfinding.",0,63996619
3293,https://stackoverflow.com/a/64000888,Iterate through Neo4j graph matching on node properties,false,"This query should work for you (assuming that the relationship directions I chose are correct):

    MATCH p = (sNode:StartNode)-[:BELONG_TO]-&gt;(i1:Interface)-[:IS_CONNECTED]-&gt;(i2:Interface)-[:BELONG_TO]-&gt;(n1)-[:BELONG_TO|IS_CONNECTED*0..]-&gt;(eNode:Node)
    WHERE sNode.name = &quot;device name&quot; AND eNode.name = &quot;foo&quot; AND LENGTH(p)%3 = 0
    WITH p, i1, i2, n1, eNode, RELATIONSHIPS(p) AS rels, NODES(p) AS ns
    WHERE n1 = eNode OR (
      ALL(j IN RANGE(3, SIZE(rels)-3, 3) WHERE
        &#39;BELONG_TO&#39; = TYPE(rels[j]) = TYPE(rels[j+2]) AND
        &#39;IS_CONNECTED&#39; = TYPE(rels[j+1])) AND
      ALL(x IN ([i1, i2] + REDUCE(s = [], i IN RANGE(3, SIZE(ns)-2, 3) | CASE WHEN i%3 = 0 THEN s ELSE s +ns[i] END))
          WHERE x:Interface AND x.VlanList CONTAINS $substring)
      )
    RETURN p

It checks that the returned paths have the required pattern of node labels, node property value, and relationship types. It takes advantage of the [variable length relationship](https://neo4j.com/docs/developer-manual/3.4/cypher/clauses/match/#varlength-rels) syntax, using [zero as the lower bound](https://neo4j.com/docs/developer-manual/3.4/cypher/clauses/match/#zero-length-paths). Since there is no upper bound, the variable length relationship query query can take &quot;forever&quot; to finish (and in such a situation, you should use a reasonable upper bound).
",0,64000888
3294,https://stackoverflow.com/a/63975819,How can I get Spring Data Neo4j (SDN) to initialise and optional relationships collection with an empty list in Kotlin?,false,"This *can* be solved by setting a value to the field upon construction like this:
```kotlin
var children: List&lt;Child&gt; = emptyList() // Default value used when there&#39;s no children
```

I far prefer the `lateinit var` approach, though, so if there&#39;s a way to make it work I&#39;d like to know what it is.",0,63975819
3295,https://stackoverflow.com/a/63970221,How to convert a node to multiple relationships in Neo4j,false,"**TL;TR:**
```cypher
MATCH (a1:Author)-[:HAS_WRITTEN]-(:Article)-[:HAS_WRITTEN]-(a2:Author) MERGE (a1)-[:CO_AUTHOR]-(a2)
```
 1. Fetch all author pairs connected through at least one article: `MATCH (a1:Author)-[:HAS_WRITTEN]-(:Article)-[:HAS_WRITTEN]-(a2:Author)`
 2. Add CO_AUTHOR relations. You could use CREATE clause, but you would end up with duplicated relations. MERGE will ensure each relation is added only once: `MERGE (a1)-[:CO_AUTHOR]-(a2)`. See [MERGE][1]

Bare in mind that directions of the MERGE relations will be pretty arbitrary and should be ignored in queries. For example, to get all co-authors of the author &quot;author1&quot;:
```
MATCH (a1:Author {name: &quot;author1&quot;})-[:CO_AUTHOR]-(a2) RETURN a2
```

  [1]: https://neo4j.com/docs/cypher-manual/current/clauses/merge/",2,63970221
3296,https://stackoverflow.com/a/63970444,How to convert a node to multiple relationships in Neo4j,false,"    // get articles with authors
    // compare ids to remove duplicates
    MATCH (auth1:Author)-[:HAS_WRITTEN]-&gt;(article:Article)&lt;-[:HAS_WRITTEN]-(auth2:Author)
    WHERE id(auth1) &gt; id(auth2)

    // delete the article node
    DETACH DELETE article

    // MERGE co_author relationship
    MERGE (auth1)-[:CO_AUTHOR]-&gt;(auth2)",2,63970444
3297,https://stackoverflow.com/a/63973757,How to convert a node to multiple relationships in Neo4j,false,"Although this query looks long, it should do what you want efficiently:

    MATCH (author:Author)-[r:HAS_WRITTEN]-&gt;(article:Article)
    DELETE r
    WITH article, COLLECT(author) AS authors
    DELETE article
    WITH authors
    UNWIND RANGE(0, SIZE(authors)-2) AS i
    WITH authors, i
    UNWIND RANGE(i+1, SIZE(authors)-1) AS j
    WITH authors[i] AS a1, authors[j] AS a2
    CREATE (a1)-[:CO_AUTHOR]-&gt;(a2)

It first finds all the `HAS_WRITTEN` relationships and deletes them. Then it  [aggregates](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) the `authors` for each `article` and deletes the article. And then it creates a `CO_AUTHOR` relationship between every pair of co-authors (there is no need to check for existing relationships, assuming none of the relationships existed before running the query).

[CORRECTION]

The above query has a flaw, as pointed out in the comments. If the same pair of authors co-author multiple articles, then they would end up being connected by multiple `CO-AUTHOR` relationships. So, this would be a corrected solution:

    MATCH (author:Author)-[r:HAS_WRITTEN]-&gt;(article:Article)
    DELETE r
    WITH article, COLLECT(author) AS authors
    DELETE article
    WITH authors
    UNWIND RANGE(0, SIZE(authors)-2) AS i
    WITH authors, i
    UNWIND RANGE(i+1, SIZE(authors)-1) AS j
    WITH authors[i] AS a1, authors[j] AS a2
    MERGE (a1)-[:CO_AUTHOR]-(a2)

It first finds all the `HAS_WRITTEN` relationships and deletes them. Then it  [aggregates](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) the `authors` for each `article` and deletes the article. And then it uses [MERGE with an undirected relationship](https://neo4j.com/docs/cypher-manual/current/clauses/merge/#merge-merge-on-an-undirected-relationship) to ensure there is a single `CO_AUTHOR` relationship between every pair of co-authors. The `UNWIND` clauses are used to avoid obvious relationship duplications.",2,63973757
3298,https://stackoverflow.com/a/63965998,Neo4J: Return latest data node for each value of a given key,true,"Assuming you put your data in a parameter, you could do

    // back to rows
    UNWIND $data AS row

    // order by timestamp
    WITH row.component AS component,
         row.timestamp AS timestamp,
         row.value AS value
    ORDER BY timestamp DESC

    // get first item in the sorted collection
    WITH component,
         COLLECT({timestamp:timestamp,value:value})[0] AS tsval

    // construct the array
    RETURN COLLECT({timestamp:tsval.timestamp,component:component,value:tsval.value}) AS result

or just 

    RETURN component,tsval.value AS value ",0,63965998
3299,https://stackoverflow.com/a/63973441,Neo4J: Return latest data node for each value of a given key,false,"Assuming the list is passed to the query as the `data` [parameter](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/), this query uses [aggregating function](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) `COLLECT`:

    UNWIND $data AS d
    WITH d
    ORDER BY d.timestamp DESC
    RETURN d.component AS component, COLLECT(d.value)[0] AS value

to produce a result that looks like this:

    ╒═══════════╤═══════╕
    │&quot;component&quot;│&quot;value&quot;│
    ╞═══════════╪═══════╡
    │&quot;b&quot;        │&quot;11&quot;   │
    ├───────────┼───────┤
    │&quot;a&quot;        │&quot;2&quot;    │
    └───────────┴───────┘",0,63973441
3300,https://stackoverflow.com/a/63955933,get the root parent node using neo4j,false,"As far as I understand, you have a pattern

    (:ColumnName)-[:iscolumnof]-&gt;(:TableName)-[:istableof]-&gt;(:DatabaseName)-[:isdatabaseof ]-&gt;(:SystemName)


If you want to test whether a certain :ColumnName belongs to a :DatabaseName

    WITH &#39;nop&#39; AS columnName, &#39;db2&#39; AS databaseName
    MATCH (col:ColumnName {ColumnName:columnName}),(db:DatabaseName 
    {DatabaseName:databaseName})
    RETURN EXISTS((col)-[:iscolumnof]-&gt;(:TableName)-[:istableof]-&gt;(db)) AS result
    
If you want all the columns of db2

    WITH &#39;db2&#39; AS databaseName
    MATCH (c:ColumnName)-[:iscolumnof]-&gt;(:TableName)-[:istableof]-&gt;(:DatabaseName {DatabaseName:databaseName}) 
    RETURN c.ColumnName AS column
",0,63955933
3301,https://stackoverflow.com/a/63961113,Neo4j Cannot merge node using null property value,true,"If you pass a non-integer to the `TOINTEGER()` function, it will return `NULL`.

In your data file, neither `product_id` nor `product_category` has an integer value, so do not use the `TOINTEGER()` function in your last 2 `MERGE` clauses.



",0,63961113
3302,https://stackoverflow.com/a/63956759,Why does a modest MATCH and CREATE query spin in Neo4j browser?,true,"Instead of preprocessing the data to be in cypher format like:

    match (a1:link {description:&quot;www.samplelink.com/example1&quot;})
    match (a2:link {description:&quot;www.samplelink.com/example2&quot;})
    match (a3:link {description:&quot;www.samplelink.com/example3&quot;})
    ...x6,000
    
    create (a1)-[:REF]-&gt;(a3)
    create (a1)-[:REF]-&gt;(a47)
    create (a5832)-[:REF]-&gt;(a9)
    ...x5,000

You want to preprocess your data into a CSV file like for example:

    link_from, link_to
    samplelink1,samplelink2

And then use the `LOAD CSV` statement to import the data:

    LOAD CSV WITH HEADER FROM &quot;file:///yourfile.csv&quot; as row
    MERGE (from:link{description:row.link_from})
    MERGE (to:link{description:row.link_to})
    MERGE (from)-[:REF]-&gt;(to)

With the proper index setup, the import should take like a second.

",0,63956759
3303,https://stackoverflow.com/a/63961292,Why does a modest MATCH and CREATE query spin in Neo4j browser?,false,"**Problem 1**: You should pass a list of all the `description` values in a [parameter](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/) to the query. And the query can just use `UNWIND` to get the elements from that list. The query will be very small and execute quicker (and also avoid Cypher injection attacks).

For example (if the list is passed in a `descriptions` parameter):

    UNWIND $descriptions AS desc
    CREATE (a1:link {description: desc})

You may want to break up very large lists into smaller chunks, but 6500 is not very large.

**Problem 2**: You can use @TomažBratanič&#39;s approach, or you can use an approach similar to my approach for Problem 1. That is, you could pass a list of *pairs* of `description` values to your query.

For example, if each element of the `descriptionPairs` parameter is a list of 2 `description` values:

    UNWIND $descriptionPairs AS descPair
    MATCH (a1:link {description: descPair[0]})
    MATCH (a2:link {description: descPair[1]})
    CREATE (a1)-[:REF]-&gt;(a2)

And, to make this query *really fast*, you should also create an [index](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/) on `:link(description)`.

NOTE: If you want to avoid creating duplicate nodes or relationships, you should use [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) instead of `CREATE` for both of my approaches. You should carefully read the documentation for [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) so that you understand how to use it properly, but the above queries are simple enough that replacing `CREATE` with `MERGE` is safe.",1,63961292
3304,https://stackoverflow.com/a/63943233,Neo4j create ranking by region by vendor based on similarity,false,"You can use the `UNION` statement to join the results of two queries. You have to be careful that both queries return the same columns. You can also do post-UNION processing. Here is an example from the [documentation][1]:

    MATCH (m:Movie {title:&#39;The Matrix&#39;})
    CALL {
        WITH m
        MATCH (m)&lt;-[:ACTED_IN]-(p)
        RETURN p
        UNION
        WITH m
        MATCH (m)&lt;-[:DIRECTED]-(p)
        RETURN p
    }
    RETURN p.name as name
    ORDER BY name ASC

This syntax will only work in Neo4j 4.0 and forward.



  [1]: https://neo4j.com/developer/kb/post-union-processing/",0,63943233
3305,https://stackoverflow.com/a/63961060,Neo4j create ranking by region by vendor based on similarity,false,"This may work for you:

    MATCH (eid:eid)-[:BOUGHT]-&gt;(:material)&lt;-[:BOUGHT]-(otherEid:eid)
    WHERE eid.id = &#39;104&#39; AND eid &lt;&gt; otherEid
    WITH DISTINCT eid, otherEid
    MATCH (otherEid)-[:BOUGHT]-&gt;(m:material)
    WHERE NOT (eid)-[:BOUGHT]-&gt;(m)
    WITH eid, m, COUNT(*) AS timessold
    MATCH (n:bookdb), (ecl:ecountry), (ven:vendor), (vloc:vlocation) 
    WHERE n.mat = m.id AND ecl.id = n.eloc AND ven.id = n.ven AND vloc.id = n.vloc
    RETURN eid, m, timessold, ecl, ven, vloc
    ORDER BY timessold DESC, m",0,63961060
3306,https://stackoverflow.com/a/63943137,"In Neo4j how to group by one return key, instead of all non aggregate keys in return?",true,"This is not possible in Cypher as it does implicit group by as you have learned from the documentation. It is quite similar to SQL, except there you have to explicitly add the `GROUP BY` clause.

What you can do is use [subqueries][1], or split the query into two parts, where you first aggregate the data and then iterate over each node again in the second part.


  [1]: https://neo4j.com/developer/cypher/subqueries/",1,63943137
3307,https://stackoverflow.com/a/63934467,Match relationships if a certain parameter exists,true,"You can use the `NOT` operator together with the predicate function `exists()` for this problem:
```
MATCH (r) WHERE NOT exists(r.verified) RETURN r
```",1,63934467
3308,https://stackoverflow.com/a/63930359,Cypher : representing nested graphs?,false,"Probably the simplest and most concise way for a node to reference an entire subgraph of any size and complexity would be to store in that node a `cypher` property whose value is a Cypher query string that would produce the desired subgraph.

As an example, here&#39;s how you might represent the assertion that a specific `subgraph1` contains a given `subgraph2`:

    CREATE
      (subgraph1:Graph {cypher: &#39;MATCH p=(f:Foo)-[:HAS]-&gt;(:Bar) WHERE f.id = 123 RETURN p&#39;}),
      (subgraph2:Graph {cypher: &#39;MATCH (f:Foo) WHERE f.id = 123 RETURN f&#39;}),
      (subgraph1)-[:CONTAINS]-&gt;(subgraph2)

If the actual subgraph represented by `subgraph1` consisted of several billion nodes and relationships, there may be no other practical way to represent the subgraph.",0,63930359
3309,https://stackoverflow.com/a/63919464,Neo4j cypher query poor performance,false,"In your MATCH you have a bi-directional pattern.

    (t:Tag)&lt;-[:BELONG_TO]-&gt;(th)

Do you have set an index or constraint on :User(user_id) ? ",0,63919464
3310,https://stackoverflow.com/a/63913234,Cypher merge query creates new nodes instead of merging,true,"The second MERGE query is trying to match using the whole pattern.

Once the query is executed again for the second entry on your list of components, it is not just matching to `(: Component {Id: &quot;111&quot;})`, but to `(: Component {Id: &quot;333&quot;})&lt;-[:DEPENDS_ON]-(: Component {Id: &quot;111&quot;})` instead. Since the said pattern does not exist yet, the node for 111 is created again.

For 111 to not be created again, you need to add a MERGE query for that node alone.

```
UNWIND $components AS component
MERGE (dependency:Component {Id: component.dependencyId })
MERGE (target:Component {Id: component.targetId })
MERGE (dependency)&lt;-[:DEPENDS_ON]-(target)
RETURN dependency, target
```",1,63913234
3311,https://stackoverflow.com/a/63910065,Is it possible to import multiple node types in the same csv in neo4j?,true,"You can use the APOC procedure [apoc.merge.node](https://neo4j.com/labs/apoc/4.1/graph-updates/data-creation/) to do the equivalent of `MERGE` for nodes with dynamically-assigned labels:

    LOAD CSV WITH HEADERS FROM &quot;file:///nodes.csv&quot; as row
    WITH row WHERE row.Id IS NOT NULL
    CALL apoc.merge.node([row.NodeType], {id: row.Id, name: row.Name}) YIELD node
    RETURN node",0,63910065
3312,https://stackoverflow.com/a/63976690,"use match statement when using neo4j driver, the returned result.record is nil",false,"Initially, the `result.record` field points to a position before the first record, so it is `nil`. You need to call `record.Next()` to move it to the first record. Usually it&#39;s done in a loop:
```go
for result.Next() {
	log.Printf(&quot;The current record is: %+v&quot;, result.Record())
}
```
See [parsing result values][1]


  [1]: https://github.com/neo4j/neo4j-go-driver/tree/1.7/#parsing-result-values",1,63976690
3313,https://stackoverflow.com/a/63908994,Create relationship between each two nodes for a set of nodes,false,"Your query is causing a [cartesian product](https://neo4j.com/developer/kb/cross-product-cypher-queries-will-not-perform-well/), and the Cypher planner does not use indexes to optimize node lookups involving node property comparisons.

A query like this (instead of your `USER_EDGE` query) may be faster, as it does not cause a cartesian product:

    MATCH (a:Main_table)
    WITH a.USER_ID AS id, COLLECT(a) AS mains
    UNWIND mains AS a
    UNWIND mains AS b
    WITH a, b
    WHERE ID(a) &lt; ID(b)
    MERGE (a)-[:USER_EDGE]-&gt;(b)

This query uses the [aggregating function](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) `COLLECT` to collect the nodes that have the same `USER_ID` value, and uses the `ID(a) &lt; ID(b)` test to ensure that `a` and `b` are not the same nodes and to also prevent duplicate relationships (in opposite directions).",0,63908994
3314,https://stackoverflow.com/a/63912296,Unable to load CSV in neo4j due to periodic commit error,true,"Recent versions of the neo4j browser require that you use the `:auto` browser command to initiate the `USING PERIODIC COMMIT` option. 

For example:

    :auto USING PERIODIC COMMIT
    LOAD CSV WITH HEADERS FROM &#39;file:///bs140513_032310.csv&#39; AS line
    WITH line,
      SPLIT(line.customer, &quot;&#39;&quot;) AS customerID,
      SPLIT(line.age, &quot;&#39;&quot;) AS customerAge,
      SPLIT(line.gender, &quot;&#39;&quot;) AS customerGender,
      SPLIT(line.zipcodeOri, &quot;&#39;&quot;) AS customerZip,
      SPLIT(line.merchant, &quot;&#39;&quot;) AS merchantID,
      SPLIT(line.zipMerchant, &quot;&#39;&quot;) AS merchantZip,
      SPLIT(line.category, &quot;&#39;&quot;) AS transCategory

You can get a little more info on `:auto` in the browser by entering this browser command:

    :help auto",1,63912296
3315,https://stackoverflow.com/a/63884511,Neo4J cypher:recommend products using NOT clause or any,true,"Here is how I would approach the problem.

Assuming the following graph (based on the scenario you have given):

[![enter image description here][1]][1]

To recommend materials for user b:
```
MATCH (user:EndUser{name:&#39;b&#39;})-[:BOUGHT]-&gt;(:Material)&lt;-[:BOUGHT]-(someOtherUser:EndUser)-[:BOUGHT]-&gt;(m:Material)
WHERE
	NOT((user)-[:BOUGHT]-&gt;(m))
	AND user &lt;&gt; someOtherUser
RETURN m
```

Which would get the result:

[![enter image description here][2]][2]

And similarly, should we try with USER-C we would get:
```
MATCH (user:EndUser{name:&#39;c&#39;})-[:BOUGHT]-&gt;(:Material)&lt;-[:BOUGHT]-(someOtherUser:EndUser)-[:BOUGHT]-&gt;(m:Material)
WHERE
	NOT((user)-[:BOUGHT]-&gt;(m))
	AND user &lt;&gt; someOtherUser
RETURN m
```

We get an empty result as expected:

[![enter image description here][3]][3]


**Some Explanation on the cypher:**

`(user:EndUser{name:&#39;b&#39;})-[:BOUGHT]-&gt;(:Material)&lt;-[:BOUGHT]-(someOtherUser:EndUser)-[:BOUGHT]-&gt;(m:Material)` part first matches the user we are trying to recommend a `:Material` to and the goto the materials he/she has bought, then for each material we are trying to find another `:EndUser` who has also `:BOUGHT` the material. Then for each of them we go-to through their `:BOUGHT` relationships as well and call these materials we find as `m`.

Then `NOT((user)-[:BOUGHT]-&gt;(m))` tries to make sure that the user (we trying to recommend to) has not bought the item directly and `user &lt;&gt; someOtherUser` section checks the user and the other `:User` node we have found during processing are not the same nodes (though loops for instance).

**How to use it inside your code:**

You typically would use [parameters][4] for the values needed (`name` in this example).

simple example in python:
```python
. . .

@staticmethod
def _create_recommendation_transaction(tx, name):
    result = tx.run(
    &quot;&quot;&quot;
    MATCH (user:EndUser{name: $name })-[:BOUGHT]-&gt;(:Material)&lt;-[:BOUGHT]-(someOtherUser:EndUser)-[:BOUGHT]-&gt;(m:Material)
    WHERE
       NOT((user)-[:BOUGHT]-&gt;(m))
       AND user &lt;&gt; someOtherUser
    RETURN m
    &quot;&quot;&quot;, name=name)
 
. . .
```


  [1]: https://i.stack.imgur.com/tpWBX.png
  [2]: https://i.stack.imgur.com/VYGbU.png
  [3]: https://i.stack.imgur.com/ent6f.png
  [4]: https://neo4j.com/docs/cypher-manual/current/syntax/parameters/#cypher-parameters-string-literal",4,63884511
3316,https://stackoverflow.com/a/63874840,Path that contains specific nodes in the middle?,false,"You can add to the where clause

    AND ANY(x IN nodes(path)[1..-1] WHERE x.val =5)

to get paths through at least one node that has val=5",2,63874840
3317,https://stackoverflow.com/a/63857994,How to merge nodes of the same community with Cypher in Neo4j?,true,"I am not quite sure why APOC is not merging the relationships in your example. However, here is a Cypher query to get you started:

```
MATCH (n:User)-[r]-&gt;(v:User)
WHERE n.communityId &lt;&gt; v.communityId  // discard self loop
WITH n.communityId as comId1, v.communityId as comId2, sum(r.weight) as w
MERGE (su1:SuperUser {communityId: comId1})  // create or get merged node for n.communityId
MERGE (su2:SuperUser {communityId: comId2})  // create or get node for v.communityId
MERGE (su1)-[r:SUPER_LINK]-&gt;(su2)
ON CREATE SET r.weight = w  // set relationship weight when it is created
RETURN su1, su2, r
```

which creates the following nodes and relationship:

[![Super node and super link][1]][1]


  [1]: https://i.stack.imgur.com/JhJTH.png",0,63857994
3318,https://stackoverflow.com/a/63851488,Cypher - Match node by properties of its connected nodes?,true,"Assuming you use the `HAS` relationship type, and you pass a `props` [parameter](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/) containing a list of the desired label/value pairs in the following sample format: `[[&#39;foo&#39;, 123], [&#39;bar&#39;, true], [&#39;foo&#39;, 234], [&#39;baba&#39;, &#39;black sheep&#39;]]`, this query should work:

    MATCH (e:Entity)
    WHERE ALL(p IN $props WHERE SIZE([(e)-[:HAS]-&gt;(a:Attrib) WHERE a[p[0]] = p[1] | 1]) &gt; 0)
    RETURN e

[UPDATE]

The returned `e` nodes must have related `Attrib` node(s) containing all the property name and value pairs that are in the `props` parameter.

A [pattern comprehension](https://neo4j.com/docs/developer-manual/3.4/cypher/syntax/lists/#cypher-pattern-comprehension) must specify a projection, so this query just uses 1 as the projection since we don&#39;t care about the contents of the generated list. We only care about the testing size of the list.

To test the above query with the sample `props` parameter value, first create some suitable nodes and relationships. For example:

    CREATE (e:Entity {id: 1}),
      (e)-[:HAS]-&gt;(:Attrib {id: 22, foo: 123, bar: true}),
      (e)-[:HAS]-&gt;(:Attrib {id: 33, baba: &#39;black sheep&#39;}),
      (e)-[:HAS]-&gt;(:Attrib {id: 44, foo: 234})",0,63851488
3319,https://stackoverflow.com/a/63888470,Cypher - Match node by properties of its connected nodes?,false,"So I ended up creating the following attributes:

    :params {props: [[&quot;name&quot;, &quot;Athanase&quot;], [&quot;age&quot;, 22], [&quot;color&quot;, &quot;blue&quot;]]}

I then updated the query as such:

    MATCH (e:Entity) WHERE ALL(p IN $props WHERE SIZE ([(e)-[:HAS]-&gt;(a:Attrib) WHERE (a.label = p[0] AND a.value = p[1]) | 1]) &gt; 0) RETURN e;

Looks like it is working fine.",0,63888470
3320,https://stackoverflow.com/a/63852046,Neo4j subgraph of different nodes with different labels and relationship if any,false,"The following query will return each `point` node, along with a list of all its related `equip` nodes, and another list of all its related `meter` nodes.

    MATCH (p:point)
    RETURN p, [(p)--(e:equip) | e] AS es, [(p)--(m:meter) | m] AS ms",0,63852046
3321,https://stackoverflow.com/a/63852611,Neo4j subgraph of different nodes with different labels and relationship if any,false,"For this specific subset example:  

```
MATCH (p:point)--(e:equip)
RETURN p,e
```

If you are displaying a graph in the Neo4j Client it will show the output I think you want to see with a simple query like this (many variations on this will work just as well)

```
MATCH (a:ACTOR), (m:MOVIE)
OPTIONAL MATCH p=(a)--(m)
return a, m, relationships(p)
```
Translated to your dataset, something like this?

```
MATCH (p:point), (e:equip)
OPTIONAL MATCH t=(p)--(e)
return p, e, relationships(t)
```

run this in the neo4j browser and look at the table output, and you&#39;ll see the client is simplifying out extra return data as it create the display view (removing nulls, and duplicates)

If your goal is to minimize and restructure the returned data, the best approach may depend on what language you are calling from and how you need/want it formatted, but here is a quick example query using neo4j browser / desktop client that might give you some ideas and help with restructuring what comes back from a cypher query.

```
MATCH (a:ACTOR), (m:MOVIE)
OPTIONAL MATCH t=(a:ACTOR)--(m:MOVIE)
with collect(distinct a) + collect(distinct m) + collect(relationships(t)) as output
return output
```
Translated to your dataset, something like this?

```
MATCH (p:point), (e:equip)
OPTIONAL MATCH t=(p:point)--(e:equip)
with collect(distinct p) + collect(distinct e) + collect(relationships(t)) as output
return output
```
(compare the table output in neo4j client to the previous query)

[Reference article][1]


  [1]: https://community.neo4j.com/t/avoid-cartesian-product-when-create-relationships/13624/7",0,63852611
3322,https://stackoverflow.com/a/63846902,Cypher: Loop over distinct nodes in multiple paths,true,"What about this?

    WITH COLLECT(DISTINCT ops) AS distinctOps
    MATCH paths = (end:Operation)-[DEPENDS_ON*]-&gt;(start:Operation )
           WHERE id(start) = 304
           AND end.final = true 
    
    UNWIND nodes(paths) AS ops
    WITH COLLECT(DISTINCT ops) AS distinctOps
    FOREACH (op IN distinctOps |
      SET op.flag = op.flag + 1
    )

",1,63846902
3323,https://stackoverflow.com/a/63872794,Neo4j handling date time values as different nodes,true,"A better approach would be to parse the DateTime values and store them as properties to a Node. 

    LOAD CSV with headers FROM &#39;file:///filename.csv&#39; as row
    WITH apoc.date.fields(LEFT(row.Created_Date, 10), &#39;yyyy-MM-dd&#39;) AS val
    MERGE (d:Date {year: val.years, month: val.months, day: val.days})",0,63872794
3324,https://stackoverflow.com/a/63839555,Neo4j cypher query - How to return path nodes but not include the nodes with identical specific properties,true,"This query uses the [aggregating function](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) `COLLECT` to generate a list of all the paths that share each distinct pair of `property2/property3` values, and assigns the first path from each list to the `path` variable. Therefore, the returned `path` values will all have a distinct pair of `property2/property3` values.

    MATCH p = (:x)-[y:y]-&gt;(f:f)
    WITH y.property2 AS p2, f.property3 AS p3, COLLECT(p)[0] AS path
    RETURN path",0,63839555
3325,https://stackoverflow.com/a/63828723,How to load csv with header value that contains a cypher keyword in Neo4j,false,"there seems to be an error in your Cypher

    row.description,}

should be

    row.description}


=======

put backticks ?  

\`INTENT\` 

That works for us if we have keys like  

\`$mykey\`,\`key:ar\`,\`#somekey\`

",0,63828723
3326,https://stackoverflow.com/a/63817869,How to explain the execution path of this Cypher query?,false,"This is because the Person with id 1 has five neighbors.

In your query you start with:

    MATCH(p:Person {id:1})

This produces a single row, where it finds the node you are looking for.
The next step is:

    MATCH (p)-[:KNOWS]-(s)

This statement found 5 neighbors, so your cardinality or number of rows increases to five. And then you run a create statement for each row, which in turn creates five Places. You could for example lower the cardinality back to 1 before doing the `CREATE` and you&#39;ll create only a single place:

    MATCH(p:Person {id:1})
    MATCH (p)-[:KNOWS]-(s)
    // aggregation reduces cardinality to 1
    WITH p, collect(s) as neighbors
    CREATE (p)-[:LIVE_IN]-&gt;(:Place {name: &#39;Some Place&#39;})

When doing cypher query, always have in mind the cardinality you are operating. ",0,63817869
3327,https://stackoverflow.com/a/63817898,How can I use the `with` statement with `call.apoc.do.when` in Neo4j?,true,"Looking at the [documentation][1], you can add a third parameter that includes parameters for inners statements:

    MATCH (t1:Title)-[r:TO]-&gt;(t2:Title)
    WHERE t1.tid = &#39;123abc&#39;
    AND NOT exists((t2)&lt;-[:LIKE|:DISLIKE|:LOVE]-(:User {pid: &#39;456def&#39;}))
    WITH COLLECT(r) AS rels
    LIMIT 1
    
    WITH rels
    CALL apoc.do.when(
        SIZE(rels) &gt; 0,
        &#39;RETURN REDUCE(total = 0, x IN rels | total + x.weight) AS result&#39;,
        &#39;RETURN 0 AS result&#39;,
        {rels:rels}
    ) YIELD value
    RETURN value.result


  [1]: https://neo4j.com/labs/apoc/4.1/cypher-execution/conditionals/",1,63817898
3328,https://stackoverflow.com/a/63820565,How can I use the `with` statement with `call.apoc.do.when` in Neo4j?,false,"The sum can be directly obtained using the [aggregation function](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) `SUM`:

    MATCH (t1:Title)-[r:TO]-&gt;(t2:Title)
    WHERE t1.tid = &#39;123abc&#39; AND NOT EXISTS((t2)&lt;-[:LIKE|:DISLIKE|:LOVE]-(:User {pid: &#39;456def&#39;}))
    RETURN SUM(r.weight) AS result",1,63820565
3329,https://stackoverflow.com/a/63820770,why I use this cql import csv data failed?,true,"A few things to try:

 1. Simplify (and speed up) the query. There is no need to unwind and then re-collect the distinct elements of the list. And there is no need to create temporary lists or to append to lists unless really necessary.

        USING PERIODIC COMMIT 500 LOAD CSV WITH HEADERS FROM &#39;http://127.0.0.1:88/static/relations/261.csv&#39; AS line  
        MATCH (a:user{value: line.userId}), (b:device{value: line.deviceId})  
        MERGE (a)-[rel:myrelname]-&gt;(b)
        SET
          rel.business_name=&#39;data-test&#39;,
          rel.eventOccurTime = CASE
            WHEN rel.eventOccurTime IS NULL THEN [line.eventOccurTime]
            WHEN line.eventOccurTime IN rel.eventOccurTime THEN rel.eventOccurTime
            ELSE rel.eventOccurTime + line.eventOccurTime END

 2. You may want to improve performance by creating [indexes](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/) on:

    - `:user(value)`
    - `:device(value)`

 3. Use [PROFILE](https://neo4j.com/docs/developer-manual/3.4/cypher/query-tuning/how-do-i-profile-a-query/) to analyze the execution plan generated from your Cypher.",1,63820770
3330,https://stackoverflow.com/a/63798474,Move relationship between nodes and avoid duplicates,true,"I see two things, looking at your graphs:

 - The first graph has 8 Entitlements, the desired end result has 6. So
   there is no &quot;duplication&quot;. You just keep the nodes you already had
   :)
- What your query is doing, is exactly what you say it should do , namely moving entitlements from one node to the other.


What is missing in my opinion, is the de-duplication step, which you could do like this (not tested)

    // get all the patterns where you have &gt; 1 entitlement of the same &quot;type&quot; (see or execute)
    MATCH (n:Role)--&gt;(e:Entitlement)--&gt;(m:Role)
    WITH n,m,e.type AS EntitlementType,
         COLLECT(e) AS Entitlements    
    WHERE size(Entitlements) &gt; 1
    
    // delete all entitlements, except the first one
    FOREACH (e IN tail(Entitlements) |
         DETACH DELETE e
    )",0,63798474
3331,https://stackoverflow.com/a/63818915,Move relationship between nodes and avoid duplicates,false,"This query creates only non-duplicate `Entitlement` nodes:

    MATCH (m1:Role), (x:Role)-[:CAN]-&gt;(e:Entitlement)-[o:ON]-&gt;(j1:Role)
    WHERE m1.id = &#39;m1&#39; AND j1.id = &#39;j1&#39;
    CALL apoc.do.when(
      NOT EXISTS((x)-[:CAN]-&gt;({type: e.type})-[:ON]-&gt;(m1)),
      &#39;CREATE (e)-[o2:ON]-&gt;(m1) SET o2 = o&#39;,
      &#39;&#39;,
      {e: e, m1: m1, o: o}) YIELD value
    DELETE o

The APOC function [apoc.do.when](https://neo4j.com/labs/apoc/4.0/cypher-execution/conditionals/#conditionals-when) is used to optionally perform the `CREATE` and `SET` clauses.

[UPDATE]

If you cannot use APOC, you can use a [FOREACH](https://neo4j.com/docs/cypher-manual/4.1/clauses/foreach/) hack:

    MATCH (m1:Role), (x:Role)-[:CAN]-&gt;(e:Entitlement)-[o:ON]-&gt;(j1:Role)
    WHERE m1.id = &#39;m1&#39; AND j1.id = &#39;j1&#39;
    FOREACH(x IN
      CASE WHEN NOT EXISTS((x)-[:CAN]-&gt;({type: e.type})-[:ON]-&gt;(m1)) THEN [1] END |
      CREATE (e)-[o2:ON]-&gt;(m1)
      SET o2 = o
    )
    DELETE o",0,63818915
3332,https://stackoverflow.com/a/63793494,Neo4j count Query,false,"You can find examples of how to use count in the Neo4j docs [here][1] 


  [1]: https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-count
In your case the first example where:
```
count(*)
```
Is used to return a count of each returned item should work. ",0,63793494
3333,https://stackoverflow.com/a/63802054,Neo4j count Query,true,"The following query uses the [aggregating funtion](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) `COUNT`. Distinct pairs of `m.name, n.name` values are used as the &quot;grouping keys&quot;.

    MATCH (m:master_node:Application)--(:master_node:Server)--(n:master_node) 
    WHERE EXISTS(m.name) AND (n:DeploymentUnit OR n:Schema)
    RETURN m.name, n.name, COUNT(*) AS cnt

I assume that `m.name contains &#39;&#39;` in your query was an attempt to test for the existence of `m.name`. This query uses the `EXISTS()` function to test that more efficiently.

[UPDATE]

To determine the number of distinct `n` and `m` pairs in the DB (instead of the number of times each pair appears in the DB):

    MATCH (m:master_node:Application)--(:master_node:Server)--(n:master_node) 
    WHERE EXISTS(m.name) AND (n:DeploymentUnit OR n:Schema)
    WITH DISTINCT m.name AS n1, n.name AS n2
    RETURN COUNT(*) AS cnt

Some things to consider for speeding up the query even further:

 1. Remove unnecessary label tests from the `MATCH` pattern. For example, can we omit the `master_node` label test from any nodes? In fact, can we omit all label testing for any nodes without affecting the validity of the result? (You will likely need a label on at least one node, though, to avoid scanning all nodes when kicking off the query.)

 2. Can you add a direction to each relationship (to avoid having to traverse relationships in both directions)?

 3. Specify the relationship types in the `MATCH` pattern. This will filter out unwanted paths earlier. Once you do so, you may also be able to remove some node labels from the pattern as long as you can still get the same result.

 4. Use the [PROFILE](https://neo4j.com/docs/developer-manual/3.4/cypher/query-tuning/how-do-i-profile-a-query/) clause to evaluate the number of DB hits needed by different Cypher queries.

",2,63802054
3334,https://stackoverflow.com/a/63800251,how could i use &quot;line&quot; twice?,false,"You have to add the `line` variable to the `WITH` statements:
If you check the [official docs][1] you can see the following instructions:

&gt; It is important to note that WITH affects variables in scope. Any
&gt; variables not included in the WITH clause are not carried over to the
&gt; rest of the query.

LOAD CSV WITH HEADERS FROM &#39;http://127.0.0.1/static/relations/252.csv&#39; AS line  
MATCH (a:ip{value:line.userIp}),(b:email{value:line.ucEmail})  
MERGE (a)-[rel:mayrelations]-&gt;(b)  
WITH line, rel, COALESCE(rel.spendTime, []) + line.spendTime AS spendTime
UNWIND spendTime as r0
WITH line, rel, collect(distinct r0) AS unique
set rel.spendTime= unique  


WITH rel, COALESCE(rel.eventOccurTime, []) + line.eventOccurTime AS eventOccurTime
UNWIND eventOccurTime as r1
WITH rel, collect(distinct r1) AS unique
set rel.eventOccurTime= unique


  [1]: https://neo4j.com/docs/cypher-manual/current/clauses/with/",0,63800251
3335,https://stackoverflow.com/a/63818103,User&#39;s web path in neo4j-cypher,false,"Given your data structure, this is a bit tricky, but you could try something like.


    LOAD CSV WITH HEADERS FROM &quot;file:///data.csv&quot; AS line
    MERGE (u:User{id:line.user_id})
    OPTIONAL MATCH (u)-[:VIEWS]-&gt;(v)&lt;-[n:NEXT]-()
    WHERE NOT (v)-[:NEXT]-&gt;()
    WITH u, v, n
    ORDER BY n.timestamp DESC
    LIMIT 1
    FOREACH (i in CASE WHEN v.url = line.from_page_id  THEN [1] ELSE [] END |
      CREATE (p2: Page {url: line.to_page_id})
      CREATE (u)-[:VISITS]-&gt;(p2)
      CREATE (v)-[:NEXT{timestamp:line.timestamp, event_type:line.event_type}]-&gt;(p2)
    )
    FOREACH (i in CASE WHEN v.url = line.from_page_id  THEN [1] ELSE [] END |
      CREATE (p1: Page {url: line.from_page_id})
      CREATE (p2: Page {url: line.to_page_id})
      CREATE (u)-[:VISITS]-&gt;(p1)
      CREATE (u)-[:VISITS]-&gt;(p2)
      CREATE (p1)-[:NEXT{timestamp:line.timestamp, event_type:line.event_type}]-&gt;(p2)
    )

If the &quot;from_page&quot; is equal to the last page the user visited, then it will treat it will only create a to page and connect it to user&#39;s web path. If the last visited page is not the same as &quot;from_page&quot;, then it will create both the from and to pages. This query assumes that your data is ordered by timestamp ascending.",0,63818103
3336,https://stackoverflow.com/a/63793788,Delete duplicate nodes between two nodes in Neo4j,false,"Your query pretty explicitly is matching the &quot;See&quot; action.
```
MATCH (ur:Role)-[c:CAN]-&gt;(e:Entitlement{action:&#39;see&#39;})
```
You might try the query without specifying the action type.

Edit: 

I went back and played with this and this worked for me:
```
MATCH (ur:Role)-[c:CAN]-&gt;(e:Entitlement {action: &quot;see&quot;})-[o:ON]-&gt;(s:Role {id:&#39;msci&#39;}) 
with collect(e) as rels where size(rels) &gt; 1
with tail(rels) as tail
match(n:Entitlement {id: tail[0].id})
detach delete n
```
You&#39;d need to run two queries one for each action but as long as it&#39;s only got the one extra relationship it should work.
",0,63793788
3337,https://stackoverflow.com/a/63798769,Delete duplicate nodes between two nodes in Neo4j,true,"this works if there is more than one extra :) and cleanses your entire graph.

    // get all the patterns where you have &gt; 1 entitlement of the same &quot;action&quot; (see or execute)
    MATCH (n:Role)--&gt;(e:Entitlement)--&gt;(m:Role)
    WITH n,m,e.action AS EntitlementAction,
         COLLECT(e) AS Entitlements    
    WHERE size(Entitlements) &gt; 1
    
    // delete all entitlements, except the first one
    FOREACH (e IN tail(Entitlements) |
         DETACH DELETE e
    )",0,63798769
3338,https://stackoverflow.com/a/63800176,neo4j - declare variables that are available for node creation in FOREACH clause and also for the RETURN clause,false,"Try to declare your parameters outside the `FOREACH` statement:

    OPTIONAL MATCH (user: User {id: $userId} ) 
    WITH user
    OPTIONAL MATCH (p: Product {id: &quot;1&quot;})-[:OF]-&gt;(user)  
    WITH p,  
         CASE WHEN NOT (:Store)-[:ON]-&gt;(p) OR                 
                       (:Store {id: &#39;st&#39;})-[:ON]-&gt;(p) 
                       THEN [1] ELSE [] END as array,
         $store as store,
         $product1 as product1              
    FOREACH(
        x in array |              
        MERGE (p)-[:OF]-&gt;(user)          
        ON MATCH SET p += product1         
        ON CREATE SET p += product1         
        MERGE (s:Store {id: &#39;st&#39;})
        ON MATCH SET s += store         
        ON CREATE SET s += store         
        MERGE (s)-[:ON]-&gt;(p)         
    ) 
    RETURN store, p ",0,63800176
3339,https://stackoverflow.com/a/63798796,Finding the &quot;GAP&quot; in node values ? or next?,false,"I&#39;m not sure if this is the most performant solution, but you can accomplish this using a combination of `collect()` and list comprehensions:
```
MATCH (n) WHERE n.val % 10 = 1 WITH n.val AS val ORDER BY n.val // collect ordered vals
WITH collect(val) AS vals // combine vals into array
WITH vals, [idx IN range(0, size(vals) + 1) WHERE vals[idx + 1] - vals[idx] &gt; 10] AS gaps // find first index with diff &gt; 10
RETURN vals[gaps[0]] + 10 // return missing value
```
To additionally return the next-biggest value if no gaps are found, change the RETURN clause to use a CASE statement:
```
RETURN CASE size(gaps) WHEN 0 THEN vals[-1] + 10 ELSE vals[gaps[0]] + 10 END
```",2,63798796
3340,https://stackoverflow.com/a/63740818,Neo4j - Filter on the basis of multiple types of relationships,false,"One can do the following

    match(d:person)-[r]-(e:person) where type(r) in [&#39;KNOWS&#39;, &#39;DISLIKES&#39;]

Also, watch out for queries like this

    match(d:person)-[r]-(e:person) where (d)-[:KNOWS]-(e) or (d)-[:DISLIKES]-(e)
In my experience, these will run for long and potentially blow your neo4j memory",0,63740818
3341,https://stackoverflow.com/a/63744169,Neo4j - Filter on the basis of multiple types of relationships,true,"You also have 

````
MATCH (d:person)-[r:KNOWS|DISLIKES|RELTYPE3|RELTYPE4]-(e:person)
````
",2,63744169
3342,https://stackoverflow.com/a/63731135,apoc.periodic.iterate fails the batch if there is an duplicate data in parameter,false,"You cannot use `parallel:true`, because you are creating relationships in your query. Every time you want to add a relationship to a node, the cypher engine adds a write lock to a node, and other processes can&#39;t add to that particular node. That is why you have the write lock exception. Not much you can do except to run it with `parallel:false` setting.",0,63731135
3343,https://stackoverflow.com/a/63731778,apoc.periodic.iterate fails the batch if there is an duplicate data in parameter,false,"To avoid [deadlocks](https://neo4j.com/docs/java-reference/current/transaction-management/deadlocks/), concurrent requests that update the DB *should* avoid touching the same nodes or relationships (including the nodes on both ends of those relationships). One way to achieve this is to figure out a way to have the concurrent requests work on disjoint subgraphs.

Or, you can retry queries that throw a `DeadlockDetectedException`. The docs show [an example](https://neo4j.com/docs/java-reference/current/transaction-management/deadlocks/#transactions-deadlocks-code) of how to do that.",0,63731778
3344,https://stackoverflow.com/a/63725750,How can you insert a nested list into neo4j (cypher query language) with a direct relationship,true,"I think that `ON CREATE` and `ON MATCH` only supports a single `SET` clause. And you never create a relationship between a report and a model in your query. And if you are merging by the id of the node, you don&#39;t want to then overwrite it in the `ON CREATE` statement. I would use the following query:

    UNWIND $propsArray as props
          MERGE (sac:sacreports { id: props.id })
            ON CREATE SET sac += {name: props.name , description: props.description}
          WITH sac, props
          UNWIND props.models as model
              MERGE (m: sacmodels {id: model.id})
              ON CREATE SET m += {description: model.description }
              MERGE (sac)-[:IS_USED_IN]-&gt;(m)

",0,63725750
3345,https://stackoverflow.com/a/63725633,Get neo4j&#39;s internal unique ID with cyper and assign it to my object,true,"You can get the internal node Id with the following cypher:

    CREATE (e:Example)
    RETURN id(e) as id

Neo4j also has the `randomUUID()` procedure available for such scenarios. Check the [documentation][1] for more information.

    CREATE (e:Example{id:randomUUID()})
    RETURN e.id as id


  [1]: https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-randomuuid",1,63725633
3346,https://stackoverflow.com/a/63725586,Create a social network csv in neo4j / Connections with a timestamp,true,"First, you want to create a unique constraint for the nodes. I will assume that this is a 

    (:User)-[:INTERACTS]-&gt;(:User)

but you can change it how you see fit later.

    CREATE CONSTRAINT ON (u:User) ASSERT u.id IS UNIQUE;

Now you can go ahead and import the csv file:

    LOAD CSV WITH HEADERS FROM &#39;file:///connections.csv&#39; AS row
    WITH row.source as sourcetag, 
         datetime(replace(row.servertime, &#39; &#39;, &#39;T&#39;)) as timestamp, 
         row.target as beacon
    MERGE (s:User{id:sourcetag})
    MERGE (t:User{id:beacon})
    CREATE (s)-[:INTERACTION{date:timestamp}]-&gt;(t)

You can change the node labels and relationship types how you see fit.",1,63725586
3347,https://stackoverflow.com/a/63721176,Cannot access property of nodes returned from schema procedure call,false,"With below query using Keys()  function you can able to see the properties of a selected label. if you want to see multiple labels at a time, you can keep multiple labels in a match query. Neo4j is a no schema database. So, multiple nodes can have same label name with different set of properties. Please let me know if you are looking for something else.

    MATCH (n:MemberStatus) where n.name=&quot;Active&quot; return keys(n)

[![enter image description here][1]][1]


  [1]: https://i.stack.imgur.com/jpj4U.png",0,63721176
3348,https://stackoverflow.com/a/63715517,Neo4j cypher query to delete child and grandchild nodes of a a specific node,false,"Have you tried something like that:

MATCH (n)--(p)--(gp) WHERE n.name = &#39;parent&#39; DETACH DELETE p, gp",1,63715517
3349,https://stackoverflow.com/a/63703834,Is variable length relationship is traversed in BFS manner in Neo4j?,false,"Actually it is DFS.

If you want to control this and more things about the traversal there is a path expander in the APOC library

https://neo4j.com/labs/apoc/4.1/graph-querying/path-expander/",1,63703834
3350,https://stackoverflow.com/a/63704005,Merging Nodes in Neo4j,true,"Change your second query a bit. Just because you name the node variable Germany, Neo4j doesnt know you want to match the country with the name property Germany.

And in most cases you should merge or match nodes first and only then add tje relationship between the two

    MERGE (BMW:Manufacturer {name:&quot;BMW&quot; , headquarters :&quot;Germany&quot; , employees :100306,factories:25 ,revenue:95.8 ,production:1668982 ,sales: 1688982 })
    MERGE (Germany:Country{name:&#39;Germany})
    MERGE (Germany)-[:MANUFACTURERS]-&gt;(BMW)",0,63704005
3351,https://stackoverflow.com/a/63693534,Quicker way to write a dict to a neo4j database using python,false,"The APOC function [apoc.map.sortedProperties](https://neo4j.com/labs/apoc/4.1/overview/apoc.map/apoc.map.sortedProperties/) creates a (sorted) list of properties, where each property is represented by a list containing a key and its value. That should be helpful for your use case.

For example:

    def set_dict(self, tx, my_dict):
        tx.run(&#39;&#39;&#39;    UNWIND apoc.map.sortedProperties($my_dict) AS prop
                      MERGE (n:property_1 {i: prop[0]}) 
                      SET n.j = prop[1]&#39;&#39;&#39;,
                my_dict=my_dict)",0,63693534
3352,https://stackoverflow.com/a/63687205,How do I use Louvain Algorithm with cypher projection?,true,"The Graph algorithms library is being deprecated. Please, try to use the new [Graph Data Science library][1], which is the successor of the Graph Algorithms.

Using the GDS library, the syntax would look like:

    CALL gds.louvain.stream({
      nodeQuery:&#39;MATCH (t:Tag)
        WHERE EXISTS(t.count_primaryTag_2019)
        OR EXISTS(t.count_secondaryTag_2019)
        RETURN  id(t) AS id&#39;,
      relationshipQuery:&#39;MATCH (n:Tag)-[c:CONNECTED_TO]-(m:Tag) 
        WHERE EXISTS(c.count_question_2019)
        RETURN id(n) AS source, id(m) AS target&#39;})

Regarding your question, you can ignore the direction parameter. The main part is that you have projected the relationships as undirected in your relationship cypher query, where you omit the relationship direction in the `MATCH` statement.

    MATCH (n:Tag)-[c:CONNECTED_TO]-(m:Tag)

So, what you are doing is correct, but try to update your configuration and use the new and improved GDS library. If nothing else, the algorithm execution performance is better.

  [1]: https://neo4j.com/docs/graph-data-science/current/
",1,63687205
3353,https://stackoverflow.com/a/63686626,Cypher - How to sum edge weight for each node,true,"To get the sum of incoming weights for all `pNodes`:
```
MATCH ()-[e]-&gt;(n:pNode)
RETURN n.name, sum(e.w) as weight
```
and for a specific `pNode`:
```
MATCH ()-[e]-&gt;(n:pNode)
WHERE n.name = &quot;p1&quot;
RETURN n.name, sum(e.w) as weight
```",2,63686626
3354,https://stackoverflow.com/a/63677451,Using UNWIND and CREATE to create multiple relationships,true,"To be able to create relationships with dynamic type you will need to use APOC library.

Here is an example:


     UNWIND [100, 200, 300] AS CODENUM
     MATCH (system1:System), (group1:SystemGroup)
     WHERE system1.Name = &#39;Main&#39; AND group1.Name = 
      &#39;MainGroup&#39;
      CALL apoc.create.relationship(system1, &#39;CODE_&#39; 
              +CODENUM,{}, group1) YIELD rel
       RETURN distinct true
",1,63677451
3355,https://stackoverflow.com/a/63668371,not clause in neo4j as recommendation engine,true,"You can try NOT predicate as such:

    MATCH(f:material),(t:enduser) WHERE NOT (f)-[:BOUGHT]-&gt;(t) return f,t",1,63668371
3356,https://stackoverflow.com/a/66222543,Could I use neo4j gds shortest path algorithm with multiplication instead of addition?,false,"You could map your `weight` field to a `logWeight` field by taking a logarithm - then in logarithmic space addition is multiplication in regular space.

Functions you can use:

https://neo4j.com/docs/cypher-manual/current/functions/mathematical-logarithmic/

Then if the shortest path you calculate (using the logarithmic weights) to a node `n` is `n.ShortestDistance` you can get the product of all the weights (pre-logarithm) by doing `exp(n.ShortestDistance)`.",1,66222543
3357,https://stackoverflow.com/a/63691593,Neo4j imports zero records from csv,false," 1. Neither `file:/graphdata.csv` nor `file/graphdata.csv` are legal URLs. You should use `file:///graphdata.csv` instead.
 2. By default, `LOAD CSV` expects a &quot;csv&quot; file to consist of [comma separated values](https://en.wikipedia.org/wiki/Comma-separated_values). You are instead using a variable number of spaces as a separator (and sometimes as a trailer). You need to either:
    - use a *single* space as the separator (and specify an appropriate [FIELDTERMINATOR](https://neo4j.com/docs/cypher-manual/current/clauses/load-csv/#load-csv-import-data-from-a-csv-file-with-a-custom-field-delimiter) option). But this is not a good idea for your data, since some bank names will likely also contain spaces.
    - use a comma separator (or some other character that will not occur in your data).

    For example, this file format would work better:

        TransactionId,Bank_Name,RefNo,Keyword,Amount,AccountNumber,AccountName
        12345,ABC,78,X,1000,5421,WE
        23456,DEF,,X,2000,5471
        34567,ABC,32,Y,3000,4759,HE

3. Your Cypher query is attempting to use `row` properties that do not exist (since the file has no corresponding column headers). For example, your file has no `pName` or `Name` headers.
4. Your usage of the [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) clause is probably not doing what you want, generally. You should carefully read the documentation, and [this answer](https://stackoverflow.com/a/63495126/974731) may also be helpful. ",0,63691593
3358,https://stackoverflow.com/a/63693196,RedisGraph: Merge nodes and move all the reletionships?,false,"I think this can be accomplished in pure Cypher:
```
MATCH (old {val: &#39;old&#39;})-[e:E]-&gt;(old_to)
MERGE (new {val: &#39;new&#39;})
CREATE (new)-[e2:E]-&gt;(old_to)
SET e2.prop1 = e.prop1, [...]
DELETE e
```
The chief annoyance here is that all of the edge properties (and node properties, if those are also to be migrated) must be set explicitly, as RedisGraph does not currently support setting property maps.",2,63693196
3359,https://stackoverflow.com/a/63667995,Optimizing a Cypher query to analyze topology in a network,false,"You could detect clusters with the [Strongly connected component algorithm][1] that is available in the GDS library. I think it fits your definition of a cluster, and it also would work on your example.

&gt; The Strongly Connected Components (SCC) algorithm finds sets of
&gt; connected nodes in a directed graph where each node is reachable in
&gt; both directions from any other node in the same set.

For detecting bridges you could use the [Betweenness centrality algorithm][2] to find potential bridge nodes, that have the bridge relationships connected to them. This would limit the number of edges you need to take into account when calculating which edges are the bridges. Unfortunately, this solution is not perfect as for some very small bridges, let&#39;s say they are a bridge to only a single or 2 nodes, the betweenness centrality won&#39;t be that high. And some nodes in the middle of the graph will have a high betweenness score because all the information would flow through them in theory.

I have another idea that would probably work quite fast. Run the Strongly connected component algorithm and store results back to Neo4j. Then try to find edges that connect different clusters of nodes. This will include both trees and bridges and then you have to decide which of the two options the relationship should be classified as.


  [1]: https://neo4j.com/docs/graph-algorithms/current/labs-algorithms/strongly-connected-components/
  [2]: https://neo4j.com/docs/graph-data-science/current/algorithms/betweenness-centrality/",1,63667995
3360,https://stackoverflow.com/a/63693066,conditional creations of relations?,false,"You can specify your two relationships in separate MERGE clauses:
```
    match (new:state) where new.val = {new}
    match (b:state)-[r1:q]-&gt;(p:state)-[r2:q]-&gt;(n:state)
    where b.val = {blast} and p.val = {past} and n.val = {now}
    merge (b)-[nr1:q]-&gt;(new)
    merge (new)-[nr2:q]-&gt;(n)
    set nr1.val = r1.value, nr2.val = r2.val
    delete r1, r2
    ",2,63693066
3361,https://stackoverflow.com/a/63631548,Neo4j ego network (query optimization),false,"As by your comment to get the ego network, I would try something like this:

    MATCH (n:Topic)
    WHERE n.name = &#39;raman&#39;
    MATCH p=(n)-[*1..2]-(m:Topic)
    WHERE (n)--(m)
    WITH p
    UNWIND relationships(p) as rel
    WITH collect(distinct rel) as rels
    UNWIND rels as r
    RETURN startNode(r).name, endNode(r).name,r.weight",1,63631548
3362,https://stackoverflow.com/a/63622727,Get shortest circle path without repeating any nodes,false,"Try something like:

    MATCH (n:Node{id:&quot;a&quot;})
    MATCH p=(n)-[*..20]-&gt;(n)
    WITH p, length(p) as len
    ORDER by len ASC LIMIT 1
    UNWIND nodes(p) as node
    RETURN distinct node

Not sure how well it scales though, note that I added a filter that checks for paths only 20 or fewer hops away.

",0,63622727
3363,https://stackoverflow.com/a/63622414,Cypher &amp; Neo4j : for loop with Cypher request,true,"First of all, your `run()` call is not passing any [parameters](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/), so that is probably the immediate problem. Also, even if your logic did work, you&#39;d end up writing to each ARTICLE&#39;s seed_label 5 times but always end up with the final property value being 4 -- this is wasteful and not what you intended.

In addition, for much better efficiency, you should avoid calling `run()` within a loop (or at least minimize the number of times you call `run()` within that loop). Generally, you should pass the values you want to iterate over to the query as *list* parameters, and the use [UNWIND](https://neo4j.com/docs/cypher-manual/current/clauses/unwind/) in your query to process the list values. If the lists are not too long, then you can just pass them to `run()`, and no loop is needed. Or, if the lists would be too long to handle in a single transaction, you can keep a loop but pass reasonably-sized *sub-lists* of values to `run()`.

For your specific use case, you should be able to do everything efficiently with a single `run()` call:

    tx.run(&quot;UNWIND RANGE(0, SIZE($ls)-1) AS i MATCH (n:ARTICLE {label: $ls[i]}) SET n.seed_label = i&quot;,
           ls=list_of_labels)",1,63622414
3364,https://stackoverflow.com/a/63639599,How to exclude/blacklist relationship types from apoc.path.expandConfig or similar?,true,"I&#39;ve run into this but never sat down to solve it until today when I saw your question.  If you have a LOT of relationships like I do, I feel your pain.  Ideally they will eventually add a subtract for rels, but for now it is not hard to DIY.  

Steps
1. get the list of all relationships
2. subtract the ones you don&#39;t want
3. format for use in the apoc call

```
// get all relationships
CALL db.relationshipTypes() yield relationshipType WITH collect(relationshipType) as rt
// remove unwanted relationships
WITH [n IN rt WHERE NOT n IN [&#39;PERTURBS&#39;,&#39;CAUSES_SIDE_EFFECT&#39;,&#39;TREATS&#39;,&#39;REPURPOSED_INDICATION&#39;,&#39;SUBSET_OF&#39;,&#39;GENE_EC&#39;,&#39;GENE_GENE&#39;]] as rt2
// format for use in apoc call
WITH REDUCE(ms = &quot;&quot;,word IN rt2 | ms+word+&#39;|&#39;) as js
// remove trailing pipe
WITH LEFT(js, SIZE(js)-1) as relationshipWhiteList
// your cypher here (and use the variable relationshipWhiteList)
```

References used to piece this together

 - REDUCE:
   https://stackoverflow.com/questions/60182740/neo4j-cypher-convert-array-list-to-string
 - List comprehension to filter:
   https://stackoverflow.com/questions/61446845/neo4j-filter-function-is-no-longer-supported
",1,63639599
3365,https://stackoverflow.com/a/63617375,"How can I include a list of relationships specific to each node returned in the unwind block, in a Neo4j cypher query?",true,"You could use the `type()` and `collect()` functions to extract the type of relationship from `rels` and have them as a list.

`collect(DISTINCT type(rels))` will leave you with distinct roles as an array of strings.

You might want to consider ensuring that you have `DISTINCT` in your `collect()` of incidents so that you don&#39;t have duplicate results when you unwind.

Your query when then look something like the following:
```
MATCH (incidents:Incident)&lt;-[:HAS]-(member:Person)-[rels]-&gt;(org:Org {
  orgId: $orgId
})

WITH org, member, collect(DISTINCT type(rels)) as roles, collect(DISTINCT incidents) AS collectedIncidents
UNWIND collectedIncidents AS incident
RETURN incident {
       . *,
         org:properties(org),
         member:properties(member),
         roles: roles
       } AS result
  ORDER BY incident.createdAt DESC
  SKIP $skip
  LIMIT $limit
```",1,63617375
3366,https://stackoverflow.com/a/63603686,Most sort by mutual relationships neo4j,true,"The [aggregating function](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) `COUNT` should help. Something like this:

    MATCH (t1:Thread)&lt;-[:USED]-(u:User)-[:USED]-&gt;(t2:Thread)
    WHERE t1.id = 123
    RETURN t1, t2, COUNT(DISTINCT u) AS cnt
    ORDER BY cnt DESC

The `DISTINCT` option, which incurs overhead, should only be used if it is possible for a `User` to be related to the same pair of threads multiple times.",1,63603686
3367,https://stackoverflow.com/a/63606093,update multiple related nodes simultaneously in neo4j with java,false,"To avoid issues (e.g., deadlocks), you should avoid running concurrent neo4j queries that update the same nodes or relationships (or nodes on the same relationships). If you really need to run concurrent queries, you should try to run them on disjoint subgraphs.

Refer to the neo4j documentation on [isolation levels](https://neo4j.com/docs/java-reference/current/transaction-management/isolation/), [default locking](https://neo4j.com/docs/java-reference/current/transaction-management/locking/), [deadlocks](https://neo4j.com/docs/java-reference/current/transaction-management/deadlocks/), and [delete semantics](https://neo4j.com/docs/java-reference/current/transaction-management/delete/) for more details.",1,63606093
3368,https://stackoverflow.com/a/63720831,update multiple related nodes simultaneously in neo4j with java,false,You can&#39;t run concurrent queries on the same nodes because deadlock happens. You can use semaphore to avoid multiple queries working in critical section.,1,63720831
3369,https://stackoverflow.com/a/63585435,Cypher: How to get all possible variable-length chains and output concatenated string of node properties?,true,"You can use a [variable length relationship](https://neo4j.com/docs/developer-manual/3.4/cypher/clauses/match/#varlength-rels) pattern:

    MATCH p = (:Job {name:&quot;Web Developer&quot;})-[:Appearance*]-&gt;(leaf)
    WHERE NOT (leaf)-[:Appearance]-&gt;()
    RETURN REDUCE(s = NODES(p)[1].word, w IN NODES(p)[2..] | s + &#39; &#39; + w.word) AS name

",0,63585435
3370,https://stackoverflow.com/a/63566309,Neo4j finding a path between two stations,true,"With your current graph model you could try:

    MATCH (x:Station{id:&quot;x&quot;}),(y:Station{id:&quot;y&quot;})
    MATCH p=shortestPath((x)-[*]-(y))
    RETURN p

However, you could improve your graph model, because currently, you have to look at undirected relationships, because your relationship direction does not indicate the direction of the path. If you changed it to:

    (x:Station)-[:Departure]-&gt;(:Train)-[:Arrival]-&gt;(y:Station)

For example, you can then search for a directed path, where the query will perform better:

    MATCH (x:Station{id:&quot;x&quot;}),(y:Station{id:&quot;y&quot;})
    MATCH p=shortestPath((x)-[*]-&gt;(y))
    RETURN p",1,63566309
3371,https://stackoverflow.com/a/63563476,neo4j how to return all paths from a selected starting node,false,"Regarding the question of duplicate path, one trick is to exclude paths whose end node is not a leaf, ie there are relationships starting from it. E.g.:

    MATCH p=(parent {name: &quot;a&quot;})-[:r*1..10]-&gt;(child)
    WHERE NOT (child)-[:r]-&gt;()
    RETURN p


For your second question about the return format, you can use a combination of `UNWIND` and `collect` like this:

```
MATCH p=(parent {name: &quot;a&quot;})-[:r*1..10]-&gt;(child)
WHERE NOT (child)-[:r]-&gt;()
UNWIND nodes(p) as node
WITH p, collect(node.name) as names
RETURN names
```

The result is:
```
╒═════════════╕
│&quot;names&quot;      │
╞═════════════╡
│[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]│
├─────────────┤
│[&quot;a&quot;,&quot;d&quot;]    │
└─────────────┘
```
",1,63563476
3372,https://stackoverflow.com/a/63530516,Counting IN and OUT relations to a Node?,false,"*First of all, you would normally want to specify the appropriate node labels in your patterns so that the system would not be forced to scan every node. And you may also want to add an [index](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/).*

[Degreeness checks](https://stackoverflow.com/a/55925975/974731) are very fast because they do not actually need to traverse any relationships or aggregate anything:

    MATCH (a:Foo)
    WHERE a.val = 11
    RETURN SIZE((a)&lt;--()) AS inCount, SIZE((a)--&gt;()) AS outCount

",1,63530516
3373,https://stackoverflow.com/a/63638853,Neo4j: How to avoid out of memory in large but simple transaction,false,"I use Tomaž&#39;s approach personally, but to offer a less complicated solution for those who don&#39;t want to wade into APOC yet.  You can also use a LIMIT to do this in batches, 

    MATCH (c:CONCEPT) 
    WHERE c.preferredName IS NOT NULL 
    with c limit 1000
    SET c.preferredName_lc = toLower(c.preferredName) RETURN COUNT(c)

NOTE: you have to run each batch manually (or create a loop) until count(c) returns 0, on the second run you could use a SKIP, or in this case I&#39;d just change the where clause to skip over processed nodes

    WHERE c.preferredName_lc is NULL and c.preferredName IS NOT NULL

The need for iterating over batches is one reason I would use apoc iterate, the second reason is that if your cypher operation allows it you can tell apoc to run batches in parallel...  

https://neo4j.com/labs/apoc/4.1/graph-updates/periodic-execution/


",0,63638853
3374,https://stackoverflow.com/a/63483223,Database &#39;neo4j&#39; is unavailable. Cannot reset neo4j database,false,"It&#39;s not easy to guess the issue without seeing your system, but may I ask if you can try to delete your default database, i.e. neo4j physically from the disk (e.g. rm -rf  /home/thomp105/neo4j-community-4.1.1/data/databases/neo4j/), and then try to create another database with different name instead (open neo4j.conf, search for dbms.active_database, which point out on default database, and change it to some other name)? ",3,63483223
3375,https://stackoverflow.com/a/67141522,Database &#39;neo4j&#39; is unavailable. Cannot reset neo4j database,false,"I had this problem running on a linux server. The server was up but got this error on any query: `Database &#39;neo4j&#39; is unavailable.` To troubleshoot I ran `sudo neo4j console` and the problem went away. When I ran the console as user ne04j the problem came back.

    $ /usr/share/neo4j/bin/neo4j console
    Directories in use:
      home:         /var/lib/neo4j
      config:       /etc/neo4j
      logs:         /var/log/neo4j
      plugins:      /var/lib/neo4j/plugins
      import:       /var/lib/neo4j/import
      data:         /var/lib/neo4j/data
      certificates: /var/lib/neo4j/certificates
      run:          /var/run/neo4j

So I tried: `sudo chown -R neo4j:neo4j /var/lib/neo4j/data` and the problem went away. Apparently when I&#39;d done a restore of the database I&#39;d run the neo4j server as root and when the system runs neo4j it does it as the user neo4j so couldn&#39;t read any of its data.  It seems that an error like this would warrant an easy to parse error message but verbosity is not the neo4j way.",0,67141522
3376,https://stackoverflow.com/a/63474706,Commas in MERGE clause like there are in MATCH clause?,true,"The *entire* `MERGE` pattern will be created if *any* item in the pattern does not yet exist. So, to be safe, you must always make sure every `MERGE` pattern has only *one* item that might not exist.

This is why it only makes sense for `MERGE` to support patterns with a single term.

For example, instead of this (which is not legal Cypher, anyway):

    MERGE
      (a:Foo {id: &#39;a&#39;})-[:BAR]-&gt;(b:Foo {id: &#39;b&#39;})&lt;-[:BAR]-(c:Foo {id: &#39;c&#39;}),
      (b)-[:BAR]-&gt;(d:Foo {id: &#39;d&#39;})
    RETURN a

you should actually do this:

    MERGE (a:Foo {id: &#39;a&#39;})
    MERGE (b:Foo {id: &#39;b&#39;})
    MERGE (c:Foo {id: &#39;c&#39;})
    MERGE (d:Foo {id: &#39;d&#39;})
    MERGE (a)-[:BAR]-&gt;(b)
    MERGE (b)&lt;-[:BAR]-(c)
    MERGE (b)-[:BAR]-&gt;(d)
    RETURN a
",1,63474706
3377,https://stackoverflow.com/a/63495126,Neo4j Data Import Slowness,false,"1. For importing a large amount of data, you should consider using the [import](https://neo4j.com/docs/operations-manual/current/tools/import/) tool instead of Cypher&#39;s `LOAD CSV` clause. That tool can only import into a previously unused database.


2. If you still want to use `LOAD CSV`, you need to make some changes.

   - You are using [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) improperly, and are probably generating many duplicate nodes and relationships as a result. You may find [this answer](https://stackoverflow.com/a/63474706/974731) instructive.

     A `MERGE` clause&#39;s *entire pattern* will be created if anything in
    the pattern does not already exist.

     So, your last `MERGE` pattern, with its seven relationships, is especially dangerous. It should be split into seven `MERGE` clauses with individual relationships.

     Also, a `MERGE` pattern that specifies multiple properties is likely bad as well. For example, if all `L3` nodes have a unique `Name` value, then it would be safer to replace this:

         MERGE (p3:L3 {Name: row.sl3, Path:row.sl3a})

     with something like the following:

         MERGE (p3:L3 {Name: row.sl3})
         ON CREATE SET p3.Path = row.sl3a

     *In the above snippet, if the node already exists but `row.sl3a` is different than the existing `Path` value, then no additional node is created. In addition, since the node already existed, the [ON CREATE](https://neo4j.com/docs/cypher-manual/4.1/clauses/merge/#merge-merge-with-on-create) option does not execute its `SET` clause, leaving the original `Path` value unchanged. You could also choose to use [ON MATCH](https://neo4j.com/docs/cypher-manual/4.1/clauses/merge/#merge-merge-with-on-match) instead, or even just call `SET` directly if you want to set the value no matter what.*

   - To avoid having to scanning through all the nodes with a given label every time `MERGE` needs to find an existing node, you should create an [index](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/) or [uniqueness constraint](https://neo4j.com/docs/getting-started/current/cypher-intro/schema/#cypher-intro-schema-constraints) for every label/property pair of every node that you are `MERGE`ing:

     - `:L1(Name)`
     - `:L2(Name)`
     - `:L3(Name)`
     - `:L4(Name)`
",0,63495126
3378,https://stackoverflow.com/a/63456526,RedisGraph - UNWIND batch of queries,false,"The `redisgraph-py` README shows an [example](https://github.com/RedisGraph/redisgraph-py#example-using-the-python-client) of how to pass parameters via its `query()` method:

&gt;     ...
&gt;     params = {&#39;purpose&#39;:&quot;pleasure&quot;}
&gt;     query = &quot;&quot;&quot;MATCH (p:person)-[v:visited {purpose:$purpose}]-&gt;(c:country)
&gt; 		   RETURN p.name, p.age, v.purpose, c.name&quot;&quot;&quot;
&gt; 
&gt;     result = redis_graph.query(query, params)
&gt;     ...

If you really need to use `execute_command()` instead, you can take a look at [how `query()` is implemented](https://github.com/RedisGraph/redisgraph-py/blob/387e86dc734c05fb1b93a54740987a5ab7ae3ea0/redisgraph/graph.py#L120).",1,63456526
3379,https://stackoverflow.com/a/63468856,RedisGraph - UNWIND batch of queries,true,"Here the answer from the RedisLabs dev team:

github.com/RedisGraph/RedisGraph/issues/1293

As of now, the feature is not supported, but will be introduced in the future. ",1,63468856
3380,https://stackoverflow.com/a/63454877,Creating nodes and relations from JSON (dynamically),true,"1. Variable names (like `e` and `r`) are not stored in the DB, and are bound to values only within individual queries. `MERGE` on a pattern with an unbound variable will just create the entire pattern (including creating an empty node for unbound node variables).

2. When you [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) a node, you should only specify the unique identifying property for that node, to avoid duplicates. Any other properties you want to set at the time of creation should be set using `ON CREATE SET`.

3. It is inefficient to parse through the JSON data 3 times to get different areas of the data. And it is especially inefficient the way your query was doing it, since each subsequent `CALL/MERGE` group of clauses would be done multiple times (since every previous `CALL` produces multiple rows, and the number of rows increases multiplicative). You can use [aggregation](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) to get around that, but it is unnecessary in your case, since you can just do the entire query in a single pass through the JSON data.

This may work for you:

    CALL apoc.load.json(json_file,&quot;$.JsonExport.*&quot; ) YIELD value AS data
    MERGE(r:Registration {id:data.identification})
    FOREACH(ent IN data.entities |
      MERGE (e:Entities {identity: ent.identity})
      ON CREATE SET e.name = ent.surname
      MERGE (e)-[:REGISTERED_ON]-&gt;(r)
      FOREACH(loc1 IN ent.entityLocationRelation |
        MERGE (l1:Locations {identity: loc1.locationIdentity})
        MERGE (e)-[:SEEN_AT]-&gt;(l1))
      FOREACH(ent2 IN ent.entityEntityRelation |
        MERGE (e2:Entities {identity: ent2.childIdentification})
        MERGE (e)-[:FRIENDS_WITH]-&gt;(e2))
    )
    FOREACH(loc IN data.locations |
      MERGE (l:Locations{identity:loc.identity})
      ON CREATE SET l.name = loc.city
      MERGE (l)-[:REGISTERED_ON]-&gt;(r)
    )

*For simplicity, it hard-codes the `FRIENDS_WITH` and `REGISTERED_ON` relationship types, as `MERGE` only supports hard-coded relationship types.*",2,63454877
3381,https://stackoverflow.com/a/63704904,Creating nodes and relations from JSON (dynamically),false,"So playing with neo4j/cyper I&#39;ve learned some new stuff and came to another solution for the problem. Based on the given example data, the following can create the nodes and edges dynamically.

    WITH &quot;file:///example.json&quot; AS json_file
    CALL apoc.load.json(json_file,&quot;$.JsonExport.*&quot; ) YIELD value AS data
    CALL apoc.merge.node([&#39;Registration&#39;], {id:data.identification}, {},{}) YIELD node AS vReg

    UNWIND data.entities AS ent
      CALL apoc.merge.node([&#39;Person&#39;], {id:ent.identity}, {}, {id:ent.identity, surname:ent.surname}) YIELD node AS vPer1
    	UNWIND ent.entityEntityRelation AS entRel
    	CALL apoc.merge.node([&#39;Person&#39;],{id:entRel.childIdentification},{id:entRel.childIdentification},{}) YIELD node AS vPer2
    	CALL apoc.merge.relationship(vPer1, entRel.typeRelation, {},{},vPer2) YIELD rel AS ePer

    UNWIND data.locations AS loc
      CALL apoc.merge.node([&#39;Location&#39;], {id:loc.identity}, {name:loc.city}) YIELD node AS vLoc
    	UNWIND ent.entityLocationRelation AS locRel
    	CALL apoc.merge.relationship(vPer1, locRel.typeRelation, {},{},vLoc) YIELD rel AS eLoc

    CALL apoc.merge.relationship(vLoc, &quot;REGISTERED_ON&quot;, {},{},vReg) YIELD rel AS eReg1
    CALL apoc.merge.relationship(vPer1, &quot;REGISTERED_ON&quot;, {},{},vReg) YIELD rel AS eReg2
    CALL apoc.merge.relationship(vPer2, &quot;REGISTERED_ON&quot;, {},{},vReg) YIELD rel AS eReg3

    RETURN vPer1,vPer2, vReg, vLoc, eLoc, eReg1, eReg2, eReg3
",0,63704904
3382,https://stackoverflow.com/a/63455280,"update property in all edges, fast?",false,"Sounds like you need a better approach.

For example, store the calculated expiration time (as a timestamp) in every relationship. And a query that wants to use such a relationship could test that it had not expired. This way, there is no need to update any relationship properties, and all queries will get the correct behavior (down to the millisecond).

Here is a sample snippet:

    ...
    MATCH (foo)-[rel:REL]-&gt;(bar)
    WHERE timestamp() &lt; rel.expiration

You can also periodically remove expired relationships to clean up the DB and improve query performance.",1,63455280
3383,https://stackoverflow.com/a/63461355,UNWIND statement in a Cypher Query,true,"1. *Do not* use [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) if you do not intend to write to the DB. (And if you do want to write to the DB, you *must* learn how to use `MERGE` properly to avoid unwanted results.)
2. *Do not* use [aggregating functions](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) (like `COUNT`) unless you have read the documentation and understand how to use them. In particular, you must understand what &quot;grouping keys&quot; are and how they affect the behavior of aggregating functions.
3. You should learn how [degreeness checks](https://stackoverflow.com/a/55925975/974731) can efficiently count certain relationship patterns.

This query may work for you:

    MATCH (u:User)-[:FOLLOWED]-&gt;(t:Tag)&lt;-[:BELONG_TO]-&gt;(th)
    WHERE u.id = 39792 AND NOT EXISTS((u)-[:READ]-&gt;(th))
    RETURN u.id, th.id, t.id,
      duration.inDays(datetime(), datetime({ epochmillis: apoc.date.parse(th.post_date)})).days AS days,
      SIZE((th)&lt;-[:READ]-()) as count_view
    ORDER BY days DESC, count_view DESC
    LIMIT 5

[UPDATE]

Here is one way to get the 5 newest threads with the most views, per tag followed by the user, that the user has not yet read:

    MATCH (u:User)-[:FOLLOWED]-&gt;(t:Tag)&lt;-[:BELONG_TO]-&gt;(th)
    WHERE u.id = 39792 AND NOT EXISTS((u)-[:READ]-&gt;(th))
    WITH t.id AS tagId, th.id AS threadId
    ORDER BY apoc.date.parse(th.post_date) DESC, SIZE((th)&lt;-[:READ]-()) DESC
    RETURN tagId, COLLECT(threadId)[..5] AS threads",0,63461355
3384,https://stackoverflow.com/a/63441355,MERGE the edges even if the values differ?,false,"`MERGE` has a `ON CREATE` clause that you can use : 

    MATCH (n1:X),(n2:X) WHERE n1.val = 11 and n2.val = 12 
    MERGE (n1)-[x:q]-&gt;(n2)
    ON CREATE SET x.val = 0",1,63441355
3385,https://stackoverflow.com/a/63441392,Order the result by the number of relationships,false,"This query should do what you need : 

    MATCH (n1:Node{uuid: &quot;n1_34&quot;})-[r]-(n2:Node)
    RETURN n1, n2, count(*) AS freq
    ORDER BY freq DESC",0,63441392
3386,https://stackoverflow.com/a/63458639,Order the result by the number of relationships,true,"This snippet will recreate your graph for testing purposes:

    WITH [&#39;n1_34,n1_1187&#39;,&#39;n1_34,n2_2280&#39;,&#39;n1_34,n2_1834&#39;,&#39;n1_34,n2_722&#39;,    &#39;n1_34,n2_932&#39;,&#39;n1_1187,n2_2280&#39;,&#39;n1_1187,n2_932&#39;,&#39;n1_1187,n2_1834&#39;,       &#39;n1_1187,n2_722&#39;] AS node_relationships
    UNWIND node_relationships as relationship
    with split(relationship, &quot;,&quot;) as nodes
    merge(n1:Node{label:nodes[0]})
    merge(n2:Node{label:nodes[1]})
    merge(n1)-[:LINK]-(n2)

Once that is run, the graph I&#39;m working with looks like:

[![enter image description here][1]][1]


Then this CQL will select the nodes in the subgraph and then subsequently count up each of their respective associated links, but only to other nodes existing already in the subgraph:

    match(n1:Node{label:&#39;n1_34&#39;})-[:LINK]-(n2:Node)
    with collect(distinct(n2)) as subgraph_nodes
    unwind subgraph_nodes as subgraph_node
    match(subgraph_node)-[r:LINK]-(n3:Node)
    where n3 in subgraph_nodes
    return subgraph_node.label, count(r) order by count(r) DESC

Running the above yields the following result:
[![enter image description here][2]][2]


  [1]: https://i.stack.imgur.com/YaJm1.png
  [2]: https://i.stack.imgur.com/wvrlJ.png",0,63458639
5607,https://stackoverflow.com/a/63473625,Order the result by the number of relationships,false,"Using [PROFILE](https://neo4j.com/docs/developer-manual/3.4/cypher/query-tuning/how-do-i-profile-a-query/) to assess the efficiency of some of the existing solutions using @DarrenHick&#39;s sample data, the following is the most efficient one I have found, needing only 84 DB hits:

    MATCH (n1:Node{label:&#39;n1_34&#39;})-[:LINK]-(n2:Node)
    WITH COLLECT(n2) AS nodes
    UNWIND nodes AS n
    RETURN n, SIZE([(n)-[:LINK]-(n3) WHERE n3 IN nodes | null]) AS cnt
    ORDER BY cnt DESC

Darren&#39;s solution (adjusted to return `subgraph_node` instead of `subgraph_node.label`, for parity) requires 92 DB hits.

@LuckyChandrautama&#39;s own solution (provided in a comment to Darren&#39;s answer, and adjusted to match Darren&#39;s sample data), uses 122 DB hits.

This shows the importance of using PROFILE to assess the performance of different Cypher solutions against the actual data. You should try doing that with your actual data to see which one works best for you.",0,63473625
5608,https://stackoverflow.com/a/63420586,Cypher Match-MERGE query fails on ConstraintValidationFailed,true,"If the entire pattern does not yet exist, [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) will attempt to create it.

So, either:

- `(c:C {name: &quot;Test&quot;})` already exists, but `c.parts` is not the same as `[&quot;Test&quot;]` (or is missing), OR
- `(c:C {name: &quot;Test&quot;, parts: [&quot;Test&quot;]})` already exists, but there is no `Relates` relationship to it from `n`.

In either case, `MERGE` will go ahead and try to create the pattern, resulting in a constraint violation.

This query would have avoided that situation:

    MATCH (n:N)
    WHERE ID(n) = 10
    MERGE (c:C {name: &quot;Test&quot;})
    ON CREATE SET c.parts = [&quot;Test&quot;]
    MERGE (n)-[:Relates]-&gt;(c)

",1,63420586
5609,https://stackoverflow.com/a/63416165,Find specific unknown depth grandchildren in neo4j cypher,true,"This should work:

    MATCH (r:Root)-[*0..]-&gt;()-[:HAS_SELECTED]-&gt;(l:ListItem)
    WHERE l.alias = &#39;test&#39;
    RETURN r

A [variable-length relationship](https://neo4j.com/docs/developer-manual/3.4/cypher/clauses/match/#varlength-rels) can use a zero lower bound to indicate that the relationship is optional. (When the relationship does not exist, the nodes on both sides of it in the pattern would actually correspond to the same node).

(Also, in a `MATCH` pattern you need to put a colon before a relationship type name.)",2,63416165
5610,https://stackoverflow.com/a/63399075,Neo4J Matching Nodes Based on Multiple Relationships,true,"Since the `ANY()` function can only iterate over a single list, it would be difficult to continue to use that for iteration over 2 lists (but still possible, if you create a single list with all possible `x/y` combinations) AND also be efficient (since each combination would be tested separately).

However, the new [existenial subquery](https://neo4j.com/docs/cypher-manual/current/clauses/where/#existential-subqueries) synatx introduced in neo4j 4.0 will be very helpful for this use case (I assume the 2 lists are passed as the parameters `names1` and `names2`): 

    MATCH (p:Person {person_id: &#39;123&#39;})
    WHERE EXISTS {
      MATCH (p)-[:BELONGS]-(:Face)-[:CORRESPONDS]-(:Image)-[:HAS_ACCESS_TO]-(d:Dias)
      WHERE d.group_name IN $names1 AND d.second_name IN $names2
    }
    MATCH path=(p)-[:ASSOCIATED_WITH]-(:Person)
    RETURN path

By the way, here are some more tips:
- If it is possible to specify the direction of each relationship in your query, that would help to speed up the query.
- If it is possible to remove any node labels from a (sub)query and still get the same results, that would also be faster. There is an exception, though: if the (sub)query has no variables that are already bound to a value, then you would normally want to specify the node label for the one node that would be used to kick off that (sub)query (you can do a PROFILE to see which node that would be).",1,63399075
5611,https://stackoverflow.com/a/63385576,Neo4J Matching Nodes Based On Relationships,true,"I will assume you pass the list of group names in a `names` [parameter](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/).


If you want to get the paths in which the EXISTS test succeeds for ANY name in the list:

    MATCH (p:Person {person_id: &#39;123&#39;})
    WHERE ANY(x IN $names WHERE
      EXISTS((p)-[:BELONGS]-(:Face)-[:CORRESPONDS]-(:Image)-[:HAS_ACCESS_TO]-(:Dias {group_name: x})))
    MATCH path=(p)-[:ASSOCIATED_WITH]-(:Person)
    RETURN path

Or, if you want to get the paths in which the EXISTS test succeeds for ALL names in the list, just replace `ANY` in the above request with `ALL`:

    MATCH (p:Person {person_id: &#39;123&#39;})
    WHERE ALL(x IN $names WHERE
      EXISTS((p)-[:BELONGS]-(:Face)-[:CORRESPONDS]-(:Image)-[:HAS_ACCESS_TO]-(:Dias {group_name: x})))
    MATCH path=(p)-[:ASSOCIATED_WITH]-(:Person)
    RETURN path",1,63385576
5612,https://stackoverflow.com/a/63384759,Neo4j OGM fails to clear null-ed relationship on save,false,"The workaround &quot;solution&quot; in full, from my comment above:

```

import org.neo4j.ogm.annotation.GeneratedValue;
import org.neo4j.ogm.annotation.Id;
import org.neo4j.ogm.annotation.NodeEntity;
import org.neo4j.ogm.annotation.Relationship;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@NodeEntity( label = &quot;Car&quot; )
public class Car {

  @GeneratedValue
  @Id
  private Long id;

  @JsonIgnoreProperties( { &quot;car&quot; } )
  @Relationship( type = &quot;DRIVEN_BY&quot;, direction = Relationship.OUTGOING )
  private CarDriver drivenBy;

  public Long getId()
  {
    return this.id;
  }

  public CarDriver getDrivenBy()
  {
    return this.drivenBy;
  }

  public void setDrivenBy( final CarDriver value )
  {
    if( this.drivenBy != null &amp;&amp; this.drivenBy.getCar() != this )
    {
      this.drivenBy.setCar( null );
    }
    this.drivenBy = value;
    if( this.drivenBy != null &amp;&amp; this.drivenBy.getCar() != this )
    {
      this.drivenBy.setCar( this );
    }
  }
}
```

```
import org.neo4j.ogm.annotation.Id;
import org.neo4j.ogm.annotation.NodeEntity;
import org.neo4j.ogm.annotation.Relationship;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@NodeEntity( label = &quot;Person&quot; )
public class Person {

  @Id
  private String name;

  @JsonIgnoreProperties( { &quot;drivenBy&quot; } )
  @Relationship( type = &quot;DRIVEN_BY&quot;, direction = Relationship.INCOMING )
  private CarDriver drives;

  public String getName()
  {
    return this.name;
  }

  public void setName( final String name )
  {
    this.name = name;
  }

  public CarDriver getDrives()
  {
    return this.drives;
  }

  public void setDrives( final CarDriver value )
  {
    if( this.drives != null &amp;&amp; this.drives.getDriver() != this )
    {
      this.drives.setDriver( null );
    }
    this.drives = value;
    if( this.drives != null &amp;&amp; this.drives.getDriver() != this )
    {
      this.drives.setDriver( this );
    }
  }
}
```

```
import org.neo4j.ogm.annotation.EndNode;
import org.neo4j.ogm.annotation.GeneratedValue;
import org.neo4j.ogm.annotation.Id;
import org.neo4j.ogm.annotation.RelationshipEntity;
import org.neo4j.ogm.annotation.StartNode;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@RelationshipEntity( type = &quot;DRIVEN_BY&quot; )
public class CarDriver {
  @GeneratedValue
  @Id
  private Long id;
  @JsonIgnoreProperties( &quot;drivenBy&quot; )
  @StartNode
  private Car car;
  @JsonIgnoreProperties( &quot;drives&quot; )
  @EndNode
  private Person driver;

  public Long getId()
  {
    return this.id;
  }

  public Car getCar()
  {
    return this.car;
  }

  public void setCar( final Car car )
  {
    if( this.car != null &amp;&amp; this.car.getDrivenBy() != this )
    {
      this.car.setDrivenBy( null );
    }
    this.car = car;
    if( this.car != null &amp;&amp; car.getDrivenBy() != this )
    {
      car.setDrivenBy( this );
    }
  }

  public Person getDriver()
  {
    return this.driver;
  }

  public void setDriver( final Person driver )
  {
    if( this.driver != null &amp;&amp; this.driver.getDrives() != this )
    {
      this.driver.setDrives( null );
    }
    this.driver = driver;
    if( this.driver != null &amp;&amp; driver.getDrives() != this )
    {
      driver.setDrives( this );
    }
  }
}
```

```
import static org.junit.jupiter.api.Assertions.assertNull;

import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.neo4j.ogm.config.Configuration;
import org.neo4j.ogm.session.Session;
import org.neo4j.ogm.session.SessionFactory;
import org.springframework.util.StringUtils;

public class PoCTest {

  private static SessionFactory ogmSessionFactory;

  @BeforeAll
  private static void createSessionFactory()
  {
    final Configuration config = new Configuration.Builder().uri( &quot;bolt://localhost:7687&quot; )
          .credentials( &quot;neo4j&quot;, StringUtils.replace( &quot;111&quot;, &quot;1&quot;, &quot;n304j&quot; ) )
          .useNativeTypes()
          .verifyConnection( true )
          .build();
    ogmSessionFactory = new SessionFactory( config, PoCTest.class.getPackageName() );
  }

  private static Session getOgmSession()
  {
    return ogmSessionFactory.openSession();
  }

  @BeforeEach
  void setUp()
  {
    getOgmSession().deleteAll( CarDriver.class );
    getOgmSession().deleteAll( Car.class );
    getOgmSession().deleteAll( Person.class );
  }

  @Test
  void testCreateCarChangeDriver()
  {
    final Car car = new Car();
    final Person fred = new Person();
    fred.setName( &quot;fred&quot; );
    final CarDriver carDriver = new CarDriver();
    carDriver.setCar( car );
    carDriver.setDriver( fred );
    getOgmSession().save( car );
    getOgmSession().delete( carDriver );
    assertNull( getOgmSession().load( Car.class, car.getId() ).getDrivenBy() );
    assertNull( getOgmSession().load( Person.class, fred.getName() ).getDrives() );
  }
}
```",0,63384759
5613,https://stackoverflow.com/a/63365427,Return empty list for albums without photos,true,"You can use [pattern comprehension](https://neo4j.com/docs/cypher-manual/current/syntax/lists/#cypher-pattern-comprehension) to do the equivalent of `OPTIONAL MATCH` and to automatically provide an empty list when there are no matches:

    MATCH (a:Album)
    RETURN a.id AS albumId, a.name AS albumName,
      [(a)&lt;-[:BELONGS_TO]-(p:Photo) |
        {id: p.id, uri: p.uri, thumbnails:
          [(p)&lt;-[to:THUMBNAIL_OF]-(t:Thumbnail) | {uri: t.uri, size: to.size}]
        }
      ] AS photos


*By the way, shouldn&#39;t the `size` property be on `Thumbnail` node? Might allow some other queries to be more efficient.*",1,63365427
5614,https://stackoverflow.com/a/63371337,How to loop over an object in neo4j using cypher,true,"I&#39;ve made an example for you. Tell me if fits with your purposes! :-)

```js
const products = [
  { name: &#39;apple&#39;, price: 30 },
  { name: &#39;orange&#39;, price: 40 },
  { name: &#39;lemon&#39;, price: 50 },
]

const driver = neo4j.driver(uri, neo4j.auth.basic(user, password))

const main = async () =&gt; {
  try {
      await driver.verifyConnectivity()
      console.log(&#39;Driver created&#39;)
  } catch (error) {
      console.log(`connectivity verification failed. ${error}`)
  }

  const session = driver.session()
  try {
      await session.run(`
    UNWIND $products as product
    CREATE (p: Product)
    SET p += product
    RETURN COLLECT(p) as products
    `,{products})

  } catch (error) {
      console.log(`unable to execute query. ${error}`)
  } finally {
      await session.close()
  }

  await driver.close()
}

main()
```",0,63371337
5615,https://stackoverflow.com/a/63347235,Neo4j Cypher has ultra-restrictive pattern comprehension - or am I using it wrong?,true,"[EDITED]

If you moved the `order` property into the `Thread` nodes (which should be valid if each `Thread` node is connected to only a single `Forum`), then you can create an [index](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance) (or [uniqueness constraint](https://neo4j.com/docs/getting-started/current/cypher-intro/schema/#cypher-intro-schema-constraints)) on `:Thread(order)` to speed up your query.

For example, this query should leverage the index to paginate forward faster (assuming that the `f.id`, the `order` value to use for pagination purposes, and `limit` value are passed as the [parameters](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/) `id`, `order`, and `limit`):

    MATCH (f:Forum)-[:CONTAINS]-&gt;(t:Thread)
    WHERE f.id = $id AND t.order &gt; $order
    WITH f, t
    ORDER BY t.order
    LIMIT $limit
    RETURN f{.id, .name, .URL,
      firstOrder: MIN(t.order),
      lastOrder: MAX(t.order),
      threads: [x IN COLLECT(t) | x{.id, .title, .URL}]}

And here is a (slightly more complex, but also fast) query for backwards pagination:

    MATCH (f:Forum)-[:CONTAINS]-&gt;(t:Thread)
    WHERE f.id = $id AND t.order &lt; $order
    WITH f, t
    ORDER BY t.order DESC
    LIMIT $limit
    WITH f, t
    ORDER BY t.order
    RETURN f{.id, .name, .URL,
      firstOrder: MIN(t.order),
      lastOrder: MAX(t.order),
      threads: [x IN COLLECT(t) | x{.id, .title, .URL}]}

If you analyze the [PROFILE](https://neo4j.com/docs/developer-manual/3.4/cypher/query-tuning/how-do-i-profile-a-query/) of the above queries with various `$limit` values, you should see that the db-hit complexity is `O(F*L)`, where `F` is the number of `Forum` nodes (which is probably relatively constant) and `L` is the `$limit` value. So, these queries should be significantly faster -- with the index -- as long as:

    F*L &lt;&lt; (average number of `Threads` per `Forum`).",1,63347235
5616,https://stackoverflow.com/a/63307814,Conditional partial merge of pattern into graph,false," 1. Your queries that use `MATCH` never specify which `Person` you want. Variable names like `p` only exist for the life of a query (and sometimes not even that long). So `p` is unbound in your `MATCH` queries, and can result in your `MERGE` clauses creating empty nodes. You need to add `MATCH (p:Person {Id: &#39;a&#39;})` to the start of those queries (assuming all people have unique Id values).
 2. It should NOT be the responsibility of every single query to ensure that all needed localities exist and are connected correctly -- that is *way too much* complexity and overhead for every query. Instead, you should create the appropriate localities and inter-locality relationships separately -- before you need them. If fact, it should be the responsibility of each query that *creates a locality* to create all the relationships associated with it.
 3. A `MERGE` will only not create the specified pattern if *every single thing in the pattern already exists*, so to avoid duplicates a MERGE pattern should have at most 1 thing that might not already exist. So, a `MERGE` pattern should have at most 1 relationship, and if it has a relationship then the 2 end nodes should already be bound (by `MATCH` clauses, for example).

Once the `Locality` nodes and the inter-locality relationships exist, you can add a person like this:


    MATCH (locality:Locality {name: &quot;San Diego&quot;})
    MERGE (p:Person {Id: &#39;a&#39;}) // create person if needed, specifying a unique identifier
    ON CREATE SET p.name = &#39;Omar&#39;; // set other properties as needed
    MERGE (p)-[:SITUATED_IN]-&gt;(locality) // create relationship if necessary

The above considerations should help you design the code for creating the `Locality` nodes and the inter-locality relationships.
",1,63307814
5617,https://stackoverflow.com/a/63420649,Conditional partial merge of pattern into graph,false,"Finally, the solution I used is much simpler, it&#39;s a series of merges.

    match (person:Person {Id: &#39;Omar&#39;}) // that should be present in the graph
    merge (country:Country {name: &#39;USA&#39;})
    merge (state:State {name: &#39;California&#39;})-[:SITUATED_IN]-&gt;(country)
    merge (city:City {name: &#39;Los Angeles&#39;})-[:SITUATED_IN]-&gt;(state)
    merge (person)-[:SITUATED_IN]-&gt;(city)
    return person;",0,63420649
5640,https://stackoverflow.com/a/63247887,"My cypher query where I count incoming relationship seems slow, need some help to improve performance",false,"while doing more searching I found the answer, the query that I think i need is the following:

    MATCH (country:Country)
    OPTIONAL MATCH (country)-[:CONTAINS]-&gt;(city:City)
    RETURN DISTINCT country {.*
      , city: COLLECT(DISTINCT city.identifier)
      , IS_SPECIAL_PROVISION_FOR_Count: size((:AnnouncementOfOpportunity)-[:IS_SPECIAL_PROVISION_FOR]-&gt;(country))
      , LOCATED_IN_Count: size((:Organization)-[:LOCATED_IN]-&gt;(country))
    }
    ORDER BY country.identifier ASCENDING

I make use of the `SIZE()` function to compute the number of relationships.",0,63247887
5641,https://stackoverflow.com/a/63234023,When should inferred relationships and nodes be used over explicit ones?,false,"My feeling is that the only valid scenario for creating redundant &quot;shortcut&quot; relationships is this:

- Your use case has a stringent time constraint (e.g., average query time must be less than 200ms), *but* your neo4j query -- *despite optimization* -- exceeds that constraint, *and* you have verified that adding &quot;shortcut&quot; relationships will indeed make the response time acceptable.

You should be aware that adding redundant &quot;shortcut&quot; relationships comes with its own costs:
- Queries that *modify* the DB would need to be more complex (to modify the redundant relationships) and also slower.
- You&#39;d always have to add the redundant relationships -- even if actually you never need some (most?) of them.
- If you want to make *concurrent* updates to the DB, the chances that you may [lose some updates and introduce inconsistencies](https://neo4j.com/docs/java-reference/current/transaction-management/isolation/#transactions-isolation) into the DB would increase -- meaning that you&#39;d have to work even harder to avoid inconsistencies.

NOTE: For visualization purposes, you can use [virtual nodes and relationships](https://neo4j.com/docs/labs/apoc/current/virtual/virtual-nodes-rels/#virtual-nodes-rels), which are temporary and not actually stored in the DB.",0,63234023
5642,https://stackoverflow.com/a/63258084,"Cypher query to return graph as object, where each parent node contains an array of its children?",true,"This should return the `state` object (assuming the state name is passed in via the `stateName` [parameter](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/)):

    MATCH (s:State)
    WHERE s.name = $stateName
    OPTIONAL MATCH (s)-[:IS_STATE_OF]-&gt;(c)
    OPTIONAL MATCH (c)-[:PUBLISHED_FOR]-&gt;(a)
    OPTIONAL MATCH (a)-[:WROTE]-&gt;(b)
    WITH s, c, a, CASE WHEN b IS NULL THEN [] ELSE COLLECT({name: b.name}) END AS books
    WITH s, c, CASE WHEN a IS NULL THEN [] ELSE COLLECT({name: a.name, books: books}) END AS authors
    WITH s, CASE WHEN c IS NULL THEN [] ELSE COLLECT({name: c.name, authors: authors}) END AS pcs
    RETURN {name: s.name, publishingCompanies: pcs} AS state",1,63258084
5643,https://stackoverflow.com/a/63217582,Cypher - Conditional SET,true,"Because I&#39;m using Javascript with the Neo4j driver for Node.js, I used string interpolation with a function to dynamically build the query:

    verifyParam(param, paramName) {
      if (param !== null &amp;&amp; param !== undefined) return `SET n.${paramName} = ${param}`;

      return &#39;&#39;;
    }

Then in the query string:

    `
    MATCH (n:address {id: $id})
    
    ${verifyParam($name, &#39;name&#39;)}
    ${verifyParam($streetAddress, &#39;streetAddress&#39;)}
    ${verifyParam($build, &#39;build&#39;)}
    ${verifyParam($door, &#39;door&#39;)}
    ${verifyParam($latitude, &#39;latitude&#39;)}
    ${verifyParam($longitude, &#39;longitude&#39;)}
    
    RETURN (n)
    `

Maybe is not the best solution, but I didn&#39;t found a better solution using only Cypher.",0,63217582
5644,https://stackoverflow.com/a/63287411,Nodejs neo4j-driver Trying to read and return result set of over 4m records,false,"Some observations:

1. You should not use `DISTINCT` in `COUNT(DISTINCT x)` when unnecessary, as that forces the query to accumulate in memory a set of **all** the distinct values found thus far and to check each new value against that list -- so that it can give you an accurate count. In your query, the `sp`, `op`, and `cp` values should have been naturally distinct anyway (assuming you never have multiple relationships of the same type between the same pair of nodes). So, if you had just used `COUNT(x)` instead, the query could have simply incremented a counter to get each count. *However, the query below does not need to use `COUNT` at all.*
2. When possible, you should avoid traversing relationships or getting nodes if you don&#39;t have to. In your case, you could have gotten the counts *very quickly* using a Cypher pattern like `SIZE((x)-[:FOO]-&gt;())` that [leverages the internal GetDegree() operation](https://neo4j.com/developer/kb/how-do-i-improve-the-performance-of-counting-number-of-relationships-on-a-node/).
3. The `industrySectorId` value is completely independent of the counts. So, you should not be expending an effort to get all the counts *for each* `industrySectorId`, since the counts would never change between `industrySectorId`s. The query below just collects all the `industrySectorId` values in a list, and does each count just once. 
4. `(c {campaignId: c.campaignId})` is unnecessarily torturous. It should just have been `(c)`.

This query should be *much* faster:

    MATCH (c:Campaign)
    RETURN
      c.campaignId AS campaignId,
      c.senddate AS sendDate, c.subjectLine AS subject, c.preHeader AS preHeader,
      [(c)&lt;-[:HAS]-(i:IndustrySector) | i.industrySectorId] AS industrySectorIds,
      SIZE((c)-[:SENT_EMAIL]-&gt;()) AS totalSent,
      SIZE((c)&lt;-[:OPENED]-()) AS totalOpened,
      SIZE((c)&lt;-[:CLICKED]-()) AS totalClicked

It uses quick GetDegree() checks to get the counts without actually traversing any relationships or getting any nodes at the other end. It also just puts all the `industrySectorId` values in a single `industrySectorIds`. This way, each result row contains all the desired data for each `Campaign`.

[UPDATE]

Since you have indicated that there can indeed be multiple relationships of the same type between a `Campaign` and the same `Person`, #1 and #2 above do not apply to you.

The following query should still be faster than your query, since it uses #3 (to avoid repeating the same set of expensive queries per `IndustrySector`) and #4, and does the `MATCH/COUNT` steps one-at-a-time to avoid cartesian products:

    MATCH (c:Campaign)
    OPTIONAL MATCH (c)-[:SENT_EMAIL]-&gt;(sp:Person)
    WITH c, COUNT(DISTINCT sp) AS totalSent
    OPTIONAL MATCH (c)&lt;-[:OPENED]-(op:Person)
    WITH c, totalSent, COUNT(DISTINCT op) AS totalOpened
    OPTIONAL MATCH (c)&lt;-[clicked:CLICKED]-(cp:Person)
    WITH c, totalSent, totalOpened, COUNT(DISTINCT cp) AS totalClicked
    RETURN
      c.campaignId AS campaignId,
      c.senddate AS sendDate, c.subjectLine AS subject, c.preHeader AS preHeader,
      [(c)&lt;-[:HAS]-(i:IndustrySector) | i.industrySectorId] AS industrySectorIds,
      totalSent,
      totalOpened,
      totalClicked",1,63287411
5645,https://stackoverflow.com/a/63195839,How to use a query parameter for ORDER BY?,true,"You can use the [dynamic property](https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#cypher-expressions-general) syntax.

For example, this should work:

    const query = &quot;
        MATCH (o:SomeThing)
        ORDER BY o[$propName]
        SKIP $skip
        LIMIT $limit
        RETURN o&quot;;
    
    session.run(query, { propName: &#39;name&#39;, skip: 0, limit: 20 });

",1,63195839
5646,https://stackoverflow.com/a/63195411,How to get the relationships in a couple of paths?,true,"[EDITED]

This should work:

    MATCH p=(a)-[*]-&gt;(b)
    WHERE ID(a) = 20 AND ID(b) = 25
    UNWIND RELATIONSHIPS(p) AS rel
    RETURN DISTINCT rel;

",0,63195411
5647,https://stackoverflow.com/a/64933959,Convert Natural Language to Cypher queries,false,"Great paper on this topic: https://dspace.mit.edu/bitstream/handle/1721.1/119708/1078222310-MIT.pdf?sequence=1

This involves, at the core:
- Named Entity Recognition (custom NER with SpaCy, https://towardsdatascience.com/custom-named-entity-recognition-using-spacy-7140ebbb3718)
- Named Entity Linking (with a Knowledge Base, https://medium.com/analytics-vidhya/entity-linking-a-primary-nlp-task-for-information-extraction-22f9d4b90aa8)
- Relation Extraction (https://medium.com/@andreasherman/different-ways-of-doing-relation-extraction-from-text-7362b4c3169e) (although, the RE method in the aforementioned paper seems more concrete)

I&#39;m not an expert on this at all- just beginning to learn about NLP, graph databases, etc. 

So if anyone has additional resources or notes on the ones I shared, please contribute!",2,64933959
5648,https://stackoverflow.com/a/63180331,neo4j query with filter (contains),false,"Your `WHERE` clause requires `g`, but the preceding `WITH` clause does not pass it. It seems the Cypher planner does not flag this as an error (at least in 4.1.0), but it is possible that it could cause an issue. So, try changing `with n,cinema,path,path2` to `with n,cinema,path,path2,g`.

By the way, your `WHERE` clause can made a bit more efficient, since there is no need to call `TOLOWER(&quot;jhon&quot;)` (up to 3 times) when you could just use &quot;jhon&quot; as-is. So, you should changed this:

    WHERE
    (  (  toLower(n.nickname) CONTAINS toLower(&quot;jhon&quot;) OR
     toLower(g.nickname) CONTAINS toLower(&quot;jhon&quot;) OR
     toLower(cinema.address) CONTAINS toLower(&quot;jhon&quot;)
    )   )

to this:

    WHERE
     toLower(n.nickname) CONTAINS &quot;jhon&quot; OR
     toLower(g.nickname) CONTAINS &quot;jhon&quot; OR
     toLower(cinema.address) CONTAINS &quot;jhon&quot;


",0,63180331
5649,https://stackoverflow.com/a/63226383,neo4j query with filter (contains),false,"i have another stuck and not responding query.
this time i used **COUNT + DISTINCT**

the counting result should be 66,000

   

    MATCH (movie: movie) WHERE (movie.movie=&quot;xxx_xxxx&quot; ) 
    with movie 
    MATCH (movie)-[found:found]-&gt;(n:firstName) 
    with n, movie
    MATCH (n)-[:cinema|secondName*0..1]-&gt;(g)-[p:cinema]-&gt;(cinema:cinema)&lt;- 
    [found:found]-(movie) 
    with n,g,cinema,movie 
    OPTIONAL MATCH (cinema)-[as:ID]-&gt;(id:ID)&lt;-[found:found]-(movie) 
    with n,g,cinema,id,movie 
    OPTIONAL MATCH (id:ID)-[p2:cinema]-&gt;(cinema2:cinema)&lt;-[found:found]-(movie)
    with n,g,cinema,id,cinema2 
    OPTIONAL MATCH path2 = ((cinema:cinema)-[as:ID]-&gt;(id:ID)-[p2:cinema]-&gt; 
    (cinema2:cinema))
    with path2,n,g,id,cinema,cinema2 
    MATCH path = (n)-[:cinema|secondName*0..1]-&gt;(g)-[p:cinema]-&gt;(cinema:cinema) 
     with n,cinema,path,path2,g 
    return count(DISTINCT NODES(path)+COALESCE (NODES(path2),[])) AS rowCount


Do you know what is the problem with this query?
tnx :)",0,63226383
5650,https://stackoverflow.com/a/63185574,How can I import a Cypher query to my Node.js logic?,false,"You can use the [@cybersam/require-cypher](https://github.com/cybersam/require-cypher/packages/336996) package (which I just created).

For example, if `folder/myCypherScript.cyp` contains this:

    MATCH (a:Person)--&gt;(:$hobby)
    RETURN PROPERTIES(a)

then after the package is installed (`npm i @cybersam/require-cypher`), this code will output the contents of that file:

    // Just require the package. You don&#39;t usually need to use the returned module directly.
    // Handlers for files with extensions .cyp, .cql, and .cypher will be registered.
    require(&#39;@cybersam/require-cypher&#39;);

    // Now require() will return the string content of Cypher files
    const CYPHER_SCRIPT = require(&#39;./folder/myCypherScript.cyp&#39;)
    
    console.log(CYPHER_SCRIPT);

",0,63185574
5651,https://stackoverflow.com/a/63161054,Neo4J Match subnodes by relationship,false,"Here is a sample query that uses a [variable-length relationship](https://neo4j.com/docs/developer-manual/3.4/cypher/clauses/match/#varlength-rels) pattern to return the  *paths* to all the parts (and sub-parts) of the specified `start` node:

    MATCH path=(start:Structure)-[:PartProperty*]-&gt;()
    WHERE start.name = &quot;CombusionEngine&quot;
    RETURN path

And here is a variation that just returns all the distinct parts (and sub-parts):

    MATCH (start:Structure)-[:PartProperty*]-&gt;(part)
    WHERE start.name = &quot;CombusionEngine&quot;
    RETURN DISTINCT part",0,63161054
5652,https://stackoverflow.com/a/63160792,Pivoting data in Cypher,true,"In order for Neo4j tools (like the Neo4j Browser) to generate a visualization that looks like a pivot table from a Cypher query, the query would have to *hardcode* the headings for each &quot;column&quot; -- since a Cypher query cannot dynamically generate the names of the values it returns. That is, your `RETURN` clause would have to look something like `RETURN Group, label1, label2, label3`.

Now, if you do happen to know all the possible labels beforehand, then you can indeed perform a simple query that returns your pivot table. For example:

    MATCH (n:DATA)
    WHERE n.status =~ &quot;SUCCESS&quot;
    WITH n.group as Group, n.label AS l, AVG(n.durationMillis/60000.0) AS m
    WITH Group, apoc.map.fromLists(COLLECT(l), COLLECT(m)) AS lmMap
    RETURN Group,
      lmMap[&#39;label1&#39;] AS label1,
      lmMap[&#39;label2&#39;] AS label2,
      lmMap[&#39;label3&#39;] AS label3

The APOC function [apoc.map.fromLists](https://neo4j.com/docs/labs/apoc/current/data-structures/map-functions/#map-functions) returns a map generated from lists of keys and values. If a `Group` does not have a particular label, its cell value will be `null`.",1,63160792
5653,https://stackoverflow.com/a/63149529,apoc.load.jdbc check row property before create,false,"You can use a `CASE` statement to achieve this:

    call apoc.load.driver(&#39;oracle.jdbc.driver.OracleDriver&#39;)
    WITH &quot;jdbc:oracle:thin:@10.82.14.170:1521/ORACLE&quot; as url
    CALL apoc.load.jdbc(url,&quot;select * from Patients&quot;,[],{credentials:{user:&#39;KCB&#39;,password:&#39;123&#39;}}) YIELD row
    Create (p:Person) set p = CASE WHEN row.ID &lt;&gt; p.id THEN row ELSE null END
    return p

However, this statement does not make sense, because you always create a new Person, so the row.ID will never be the same as p.id.",0,63149529
5654,https://stackoverflow.com/a/63158240,apoc.load.jdbc check row property before create,true,"As @TomažBratanič mentions in his answer, your desired conditional check makes no sense. That is, *unless* you also replace your `CREATE` clause.

Your query uses `CREATE` to *always* create a new `p` with no properties. So `row.ID &lt;&gt; p.ID` will *always* be true, and you&#39;d always be executing the `SET` clause.

However, I *believe* your real intention is to avoid changing an existing `Person` node (and to avoid creating a duplicate `Person` node for the same person). So, below is a query that uses [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) and [ON CREATE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/#query-merge-on-create-on-match) to do that. I assume that people have unique `ID` values.

    CALL apoc.load.driver(&#39;oracle.jdbc.driver.OracleDriver&#39;)
    CALL apoc.load.jdbc(
      &quot;jdbc:oracle:thin:@10.82.14.170:1521/ORACLE&quot;,
      &quot;select * from Patients&quot;,[],{credentials:{user:&#39;KCB&#39;,password:&#39;123&#39;}}
    ) YIELD row
    MERGE (p:Person {ID: row.ID})
    ON CREATE SET p = row
    RETURN p

Also, you should consider creating an [index](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/) (or [uniqueness constraint](https://neo4j.com/docs/getting-started/current/cypher-intro/schema/#cypher-intro-schema-constraints)) on `:Person(ID)` to optimize the lookup of existing `Person` nodes.",1,63158240
5655,https://stackoverflow.com/a/63108047,Find a number of photos inside a photo album,true,"You need to ORDER BY before collecting your `p` nodes

    MATCH (p:Photo)-[bt:BELONGS_TO]-&gt;(a:Album) 
    WHERE a.name = &quot;Summer 2019&quot; 
    WITH
    	a,
    	p
    ORDER BY p.file_name
    RETURN a, collect(p)[4..] as photos",1,63108047
5656,https://stackoverflow.com/a/63080024,Neo4j - Find missing node to complete circle,false,"You are basically asking for all distinct nodes on paths leading to `A`, but which are not directly connected to `A`.

Here is one approach (assuming the nodes all have a `Foo` label and the relationships all have the `BAR` type):

    MATCH (f:Foo)-[:BAR*2..]-&gt;(a:Foo)
    WHERE a.id = &#39;A&#39; AND NOT EXISTS((f)-[:BAR]-&gt;(a))
    RETURN DISTINCT f AS missingNodes

The variable-length relationship pattern `[:BAR*2..]` looks for all paths of length 2 or more.",0,63080024
5657,https://stackoverflow.com/a/63080147,Using Multiple With and Where Clauses on an Import for the same Node type,false,"If everything before the 3rd `WITH` clauses works as expected, then it must be the `WHERE` clause right *after* the 3rd `WITH` clause that is failing.

In fact, since your second `WHERE` clause is this (notice the `NOT`):

    WHERE NOT gpath.category IN [
      &#39;ETHERNET&#39;,&#39;PRI TRUNKS&#39;,&#39;CUSTOMER SIP TRUNKS&#39;,
      &#39;ETHERNET TRANSPORT&#39;,&#39;EPON ETHERNET TRANSPORT&#39;]

and your 3rd is this:

    WHERE gpath.category IN [
      &#39;ETHERNET&#39;,&#39;PRI TRUNKS&#39;,&#39;CUSTOMER SIP TRUNKS&#39;]

there is *no way* that the 3rd `WHERE` clause can ever succeed.

If you are trying to *conditionally* perform operations, you should look at the APOC procedures for [Conditional Cypher Execution](https://neo4j.com/docs/labs/apoc/current/cypher-execution/conditionals/#conditionals-case). In your case, since you have 3 conditions and want to write to the DB, you should consider using [apoc.do.case](https://neo4j.com/docs/labs/apoc/current/cypher-execution/conditionals/#conditionals-case).

For example:

    LOAD CSV WITH HEADERS FROM &#39;file:///detail.csv&#39; AS row
    MERGE (gpath:GranPath {circPathInstID:row.CircPathInstID})
    SET
      gpath.circPathHumID = row.CircPathHumID,
      gpath.category = row.Type
    WITH row, gpath
    CALL apoc.do.case(
      [
        gpath.category IN [&#39;ETHERNET&#39;,&#39;PRI TRUNKS&#39;,&#39;CUSTOMER SIP TRUNKS&#39;],
          &#39;MERGE (usvc:UnmService {name:row.CircPathHumID, status:row.CurrentPending})
           MERGE (usvc)-[:DATA_SOURCE {source:&quot;GRANITE&quot;}]-&gt;(gpath)&#39;,
        gpath.category IN [&#39;ETHERNET TRANSPORT&#39;, &#39;EPON ETHERNET TRANSPORT&#39;],
          &#39;MERGE (uxp:UnmTransport {name:row.CircPathHumID, status:row.CurrentPending})
           MERGE (uxp)-[:DATA_SOURCE {source:&quot;GRANITE&quot;}]-&gt;(gpath)&#39;
      ],
      &#39;MERGE (upath:UnmNonEthPath {name:row.CircPathHumID, status:row.CurrentPending})
       MERGE (upath)-[:DATA_SOURCE {source:&quot;GRANITE&quot;}]-&gt;(gpath)&#39;,
      {row: row, gpath: gpath})
    YIELD value
    RETURN gpath",0,63080147
5658,https://stackoverflow.com/a/63101823,Getting node/edge creation/removal statistics,true,"When using the earlier neo4j version, you could write `n = result.summary().counters.nodes_created`, but from 4.0 the `summary()` method does not exist.

Now I found from https://neo4j.com/docs/api/python-driver/current/breaking_changes.html that `Result.summary()` has been replaced with `Result.consume()`, this behaviour is to consume all remaining records in the buffer and returns the `ResultSummary`.

You can get all counters by `counters = run_res.consume().counters`",2,63101823
5659,https://stackoverflow.com/a/63062742,apoc.path.subgraphAll - How to Set Blacklist and Return Only Wanted Nodes &amp; Relationships,false,"Looks like there is a typo in [the documentation](https://neo4j.com/docs/labs/apoc/current/graph-querying/expand-subgraph/#expand-subgraph-config).

Looking in the [actual code](https://github.com/neo4j-contrib/neo4j-apoc-procedures/blob/16581f3253f82e75506428dfd2a498346c6bfb1d/core/src/main/java/apoc/path/PathExplorer.java#L153), the &quot;List&quot; in &quot;blackListNodes&quot; should have a lower-case &quot;L&quot;. That is, it should be &quot;blacklistNodes&quot;.

You should create an [issue](https://github.com/neo4j-contrib/neo4j-apoc-procedures/issues) against the documentation so that this does not affect future users.",0,63062742
5660,https://stackoverflow.com/a/63041964,Return non-matching nodes while creating relationships Neo4j Cypher,true,"First of all, you should always try to specify a *label* for the node that is used to kick off a `MATCH` (unless the `MATCH` pattern uses any already-bound nodes). Otherwise, every single node in the DB must be scanned. In addition, you should consider using [indexes](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/) to speed up your `MATCH`s (but, again, you&#39;d need to specify the labels).

Here is a query that uses the APOC procedure [apoc.do.when](https://neo4j.com/docs/labs/apoc/current/cypher-execution/conditionals/#conditionals-overview) to create a new relationship when appropriate. It returns each `row` and the corresponding new relationship (or `NULL` if either node is not found):

    UNWIND $batch as row
    OPTIONAL MATCH (from:Foo {id: row.startId})
    OPTIONAL MATCH (to:Foo {id: row.endId})
    CALL apoc.do.when(
      from IS NOT NULL AND to IS NOT NULL,
      &#39;CREATE (from)-[rel:HAS]-&gt;(to) RETURN rel&#39;,
      &#39;RETURN NULL AS rel&#39;,
      {from: from, to: to}) YIELD value
    RETURN row, value.rel AS rel


",1,63041964
5661,https://stackoverflow.com/a/63041590,Set Property of a Realtionship to label in Neo4j,false,"In neo4j terminology, a *relationship* must have a single &quot;type&quot; -- not an optional set of &quot;labels&quot; (which are only for nodes). Furthermore, a relationship&#39;s type cannot be changed.

So, to do what you want, you&#39;d have to create new relationships (with the desired types) and delete the old ones.

For example, here&#39;s is how you can use the APOC procedure [apoc.create.relationship](https://neo4j.com/docs/labs/apoc/current/graph-updates/data-creation/#data-creation) to create new relationships with the right types (and with the same properties as the old relationships except for `SysML`), and delete the old relationships:

    MATCH (a:Foo)-[r:Abstraction]-&gt;(b:Foo)
    CALL apoc.create.relationship(a, r.SysML, apoc.map.removeKey(PROPERTIES(r), &#39;SysML&#39;), b) YIELD rel
    DELETE r
    RETURN rel",0,63041590
5662,https://stackoverflow.com/a/63042159,Set Property of a Realtionship to label in Neo4j,false,"It is not possible to rename realtionships so one has to create a new one.
Example string for this problem:

    match (a)-[old:Abstraction]-&gt;(b) where old.SysML = &quot;Verify&quot;
    create (a)-[new:Verify]-&gt;(b)
    delete old",0,63042159
5663,https://stackoverflow.com/a/63042610,Neo4j: Return subtrees in Cypher,false,"The APOC procedure [apoc.convert.toTree](https://stackoverflow.com/a/38595482/974731) can produce each subtree (but using a generic JSON schema). For example:

    MATCH p=(f:Foo)-[:A*0..]-&gt;(:Foo)
    WHERE f.id IN [&#39;FOOD&#39;, &#39;TOPPING&#39;]
    WITH COLLECT(p) AS ps
    CALL apoc.convert.toTree(ps, false) YIELD value
    RETURN value AS subtree

[UPDATE 1]

If `FOOD` and `TOPPING` are not property values but labels, you can do this:

    MATCH p=(f)-[:A*0..]-&gt;()
    WHERE f:FOOD OR f:TOPPING
    WITH COLLECT(p) AS ps
    CALL apoc.convert.toTree(ps, false) YIELD value
    RETURN value AS subtree

[UPDATE 2]

If you also want to ignore the leaf node on each path (that has at least 1 relationship), you can use the APOC function [apoc.path.slice](https://neo4j.com/docs/labs/apoc/current/graph-querying/path-querying/#path-functions-function-overview) to eliminate the last relationship in a path:

    MATCH p=(f)-[:A*0..]-&gt;()
    WHERE f:FOOD OR f:TOPPING
    WITH COLLECT(CASE WHEN LENGTH(p) &gt; 0 THEN apoc.path.slice(p, 0, LENGTH(p)-1) ELSE p END) AS ps
    CALL apoc.convert.toTree(ps, false) YIELD value
    RETURN value AS subtree",0,63042610
5664,https://stackoverflow.com/a/63041209,Querying nodes based on relationships between two different nodes,false,"This may work for your scenario:

    MATCH (b1:B), (b2:B)
    WHERE b1.id = 123 AND b2.id = 456
    MATCH (a1:A)-[:rel]-&gt;(b1)
    MATCH (a1)-[:rel]-&gt;(y1:B)
    WHERE y1 &lt;&gt; b1 AND y1 &lt;&gt; b2
    WITH b2, COLLECT(DISTINCT a1) AS a1s, COLLECT(DISTINCT y1) AS otherBs
    WITH b2, [b IN otherBs WHERE ALL(a IN a1s WHERE (a)-[:rel]-&gt;(b))] AS candidates
    WHERE SIZE(candidates) &gt; 0
    MATCH (a2:A)-[:rel]-&gt;(b2)
    WITH candidates, COLLECT(a2) AS a2s
    UNWIND [c IN candidates WHERE ALL(a IN a2s WHERE (a)-[:rel]-&gt;(c))] AS b3
    RETURN b3

This query assumes the `rel` relationship is directed from `A` to `B`, and it will *only* return a result if there are any appropriate `b3` nodes. It first creates a list of all the possible `B` `candidates` related to the `A` nodes related to `b1`. Then it whittles down the `candidates` list, keeping only the `B` nodes that are also related to the `A` nodes related to `b2`.

There are many nuances in this query. For example, this snippet would abort the query if **any** `A` node with a `rel` relationship to `b1` does not also have a `rel` relationship to some other `B` node (that is not the same as `b1` and `b2`):

    MATCH (a1)-[:rel]-&gt;(b1)
    MATCH (a1)-[:rel]-&gt;(y1:B)
    WHERE y1 &lt;&gt; b1 AND y1 &lt;&gt; b2

Whereas the following refactoring of the above snippet would only abort the query if **all** `A` nodes with a `rel` relationship to `b1` do not also have a `rel` relationship to some other `B` node (that is not the same as `b1` and `b2`):

    MATCH (y1:B)&lt;-[:rel]-(a1)-[:rel]-&gt;(b1)
    WHERE y1 &lt;&gt; b1 AND y1 &lt;&gt; b2




",1,63041209
5665,https://stackoverflow.com/a/63018826,Neo4J Not Require Relationship for Query,true,"This may work for you:

    MATCH p=(a:Person)-[a1:PARENT_OF]-&gt;(b:Person)
    WHERE a.ID=&#39;9101&#39;
    OPTIONAL MATCH (b)-[b1:PARENT_OF]-&gt;(c:Person)
    WITH a, a1,
      {id:b.ID, name:b.TEN, gioitinh:b.GIOI_TINH, loaiqh:a1.type,
       loaiqh1: CASE WHEN b1 IS NOT NULL THEN b1.type END,
       children: CASE WHEN b1 IS NOT NULL THEN COLLECT({id:c.ID,name:c.TEN,gioitinh:c.GIOI_TINH,loaiqh:b1.type}) ELSE [] END} as thehe2
    RETURN  {id:a.ID,name:a.TEN,gioitinh:a.GIOI_TINH,loaiqh:a1.type, children:collect(thehe2)} as phahe",0,63018826
5666,https://stackoverflow.com/a/63007685,Finding all Leaf Nodes in Neo4j efficiently,false,"have you tried this? 

````
MATCH (root:Node {name: &#39;Name&#39;})&lt;-[:REL *]-(leaf:Node)
WITH leaf
WHERE NOT (leaf)&lt;-[:REL]-()
RETURN leaf
````

On a similar case for me it gives the lowest number of db hits.",0,63007685
5667,https://stackoverflow.com/a/62999233,Neo4j Cypher select where exists query,false,"[UPDATED]

This query uses the new [existential subquery](https://neo4j.com/docs/cypher-manual/current/clauses/where/#existential-subqueries) feature to return every `ContentItem` node whose native ID is in `$neoIds` and has any of the desired relationships:

    MATCH (n:ContentItem)
    WHERE
      ID(n) IN $neoIds AND (
        EXISTS {
          MATCH (n)-[:IN]-&gt;(pt:PulseTopic)
          WHERE pt.id IN $pulseTopics}
        OR EXISTS {
          MATCH (n)-[:IN]-&gt;(pst:SubPulseTopic)
          WHERE pst.id IN $subPulseTopics}
        OR EXISTS {
          MATCH (n)-[:FROM]-&gt;(s:Supplier)
          WHERE s.id IN $suppliers}
        OR EXISTS {
          MATCH (n)-[:USED_FOR]-&gt;(ua:UseArea)
          WHERE ua.id IN $useAreas}
        OR EXISTS {
          MATCH (n)-[:IN]-&gt;(blt:BLTopic)
          WHERE blt.id IN $blTopics
        }
      )
    RETURN n

This should be much more efficient than combining the results of multiple `OPTIONAL MATCH` clauses, since the latter would continue to search for (and hold in memory) all possible relationship matches even when one had already been found for a particular `n` node.",0,62999233
5668,https://stackoverflow.com/a/63007688,Neo4j Cypher select where exists query,false,"OK, I sorted it.  Firstly I actually had a mistake in there as it was the n.id value rather than the id(n) that was being passed in.

Secondly, for some unknown reason, I was getting one None result.  So I am just filtering that out in python now.

Thirdly, it seems that I need to put the `id(n) IN $neoIds` into each union query.

This doesn&#39;t seem like the best solution, but it works.  If you have any suggestions for improvements I&#39;d be interested.  Here is the code:

    OPTIONAL MATCH (n:ContentItem)-[:IN]-&gt;(pt:PulseTopic) WHERE pt.id IN $pulseTopics AND id(n) IN $neoIds RETURN n
    UNION
    OPTIONAL MATCH (n:ContentItem)-[:IN]-&gt;(pst:SubPulseTopic) WHERE pst.id IN $subPulseTopics AND id(n) IN $neoIds RETURN n
    UNION
    OPTIONAL MATCH (n:ContentItem)-[:FROM]-&gt;(s:Supplier) WHERE s.id IN $suppliers AND id(n) IN $neoIds RETURN n
    UNION
    OPTIONAL MATCH (n:ContentItem)-[:USED_FOR]-&gt;(ua:UseArea) WHERE ua.id IN $useAreas AND id(n) IN $neoIds RETURN n
    UNION
    OPTIONAL MATCH (n:ContentItem)-[:IN]-&gt;(blt:BLTopic) WHERE blt.id IN $blTopics AND id(n) IN $neoIds RETURN n",0,63007688
5669,https://stackoverflow.com/a/62995854,How to WHERE a param that is an array,false,"Neo4j ids are integers, not strings. 
If with p.id you mean the internal id, try id(p)
",0,62995854
5670,https://stackoverflow.com/a/62991974,delete all edges of a certain type,false,"Your query should run faster if you can specify a starting node label. E.g:

    match (:SomeLabel)-[e:usedAt]-&gt;() delete e

Your original query is doing a full db scan, using labels will constrain the query to look only at the selected node types, which will be faster.

Use the periodic iterate, but try it with parallel set to false. Depending on your overall graph structure you might be suffering some deadlock in the parallel processing.",0,62991974
5671,https://stackoverflow.com/a/63046656,delete all edges of a certain type,false,"It is not a matter of how you write the query, but a matter of neo4j&#39;s structure. Simply put, no matter how you write the query, the edges cannot be deleted as efficient as you expect. This is because: 1)It is a huge transaction in neo4j with your data size. In its essential, neo4j ensures transaction for each operation. 2) There are a lot of random read and write from disk or memory and none of them are fast. So if you stick to neo4j, you&#39;d better avoid such operations. ",1,63046656
5672,https://stackoverflow.com/a/62969920,Handling parameterised order by filters within neo4j cypher,true,"Something like this could work, by adding a `field` key to the object and inverting the collection before the `SKIP` and `LIMIT`

The suggestion below is pure Cypher. Using apoc, you could also create your dynamic queries.

````

MATCH (s:Species)
  WHERE toLower(s.name) CONTAINS toLower($search)

WITH s


OPTIONAL MATCH (s)-[e:EATS]-&gt;(eatsSpecies:Species)
OPTIONAL MATCH (s)&lt;-[:EATEN_BY]-(eatenBySpecies:Species)
OPTIONAL MATCH (s)&lt;-[:IS_ABOUT]-(image:Image)
OPTIONAL MATCH (s)-[:FALLS_UNDER]-&gt;(primary:Primary)
OPTIONAL MATCH (s)-[:MEASURED_BY]-&gt;(month:Month)

WITH s, eatsSpecies, eatenBySpecies, image, primary, month

WITH s,
     // add a &#39;sortField&#39;
     s[$field] AS field,    
     count(DISTINCT eatsSpecies.name) AS eats,
     count(DISTINCT eatenBySpecies.name) AS eatenBy,
     primary,
     image,
     count(distinct month) as monthCount

WITH {
       name:              s.name,
       scientificName:    s.scientificName,
       description:       s.description,
       primary:           case when exists(primary.GUID) then true else false end,
       active:            case when exists(s.active) then s.active else true end,
       months:            monthCount,
       guid:              s.GUID,
       eats:              eats,
       eatenBy:           eatenBy,
       image: case when exists(image.url) then true else false end,
       field:            field
     } AS species ORDER BY species.field 

WITH COLLECT(species) AS sortedSpecies

RETURN CASE $sort 
           WHEN &quot;asc&quot; THEN sortedSpecies[$skip .. $limit]
           ELSE REDUCE(array=[], i IN RANGE(1,size(sortedSpecies)) |
                 array
                 +sortedSpecies[size(sortedSpecies)-i]
              )[$skip .. $limit]
       END AS sortedSpecies
````",1,62969920
5673,https://stackoverflow.com/a/63352580,attach debugger to neo4j procedure jar,true,"For the record, I find a way to debug my neo4j stored procedure. I&#39;m using Java 8. I used IntelliJ idea. I added the config `dbms.jvm.additional=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005` to the *neo4j.conf* file

Inside IntelliJ IDEA, I added a new configuration for remote debugging.
[![Remote debugging configuration for IntelliJ IDEA][1]][1]

Here note that syntax in Java 9+ is different. At the end, to give port parameter it uses `address=*:5005`. There is post about it here. https://stackoverflow.com/a/62754503/3209523

  [1]: https://i.stack.imgur.com/hq63V.png",0,63352580
5674,https://stackoverflow.com/a/62954065,Match pairs of nodes with reciprocal relationships,true,"You could do this:

```
MATCH (c1:Concept)-[:REL]-(c2:Concept)
WHERE id(c1) &gt; id(c2)
RETURN [c1.concept_id, c2.concept_id]
```",0,62954065
5675,https://stackoverflow.com/a/62960812,Neo4j- questions on Syntax apoc trigger,false,"You should:
 - minimize the number of rows of data that have to be processed for a query, and
 - not repeat operations unnecessarily.

With those rules in mind, this query may work (efficiently) for you:

    CALL apoc.trigger.add(
      &#39;loadEnrollments&#39;,
      &quot;
      CALL apoc.cypher.doIt(&#39;MATCH (e:Enrollment) DETACH DELETE e&#39;, {}) YIELD value
      WITH value
      MATCH (n:SPerson)
      WITH COUNT(n) as size
      MATCH (c:Course {name: &#39;Paradigm Shifting 101&#39;})
      UNWIND apoc.trigger.nodesByLabel($assignedLabels, &#39;Enrollment&#39;) AS node
      MERGE (p1:SPerson {name: node.name, cell: node.cell, created_at: node.created_at})
      DETACH DELETE node
      CALL apoc.create.relationship(p1, CASE WHEN size &gt; 3 THEN &#39;Waitlist&#39; ELSE &#39;Enrolled&#39; END, {}, c) YIELD rel
      &quot;,
      { phase: &#39;after&#39; }
    );",0,62960812
5676,https://stackoverflow.com/a/62944728,Can&#39;t match-where-limit in Cypher?,true,"Figured out how. Very unintuitively, you need to limit before the operation after a  `WITH`.

```cypher
MATCH (n:myBaseLabel)
WHERE NOT n:myPossibleSubLabel AND NOT n:myExclusionLabel 
WITH n
LIMIT {updateChunk}
SET n:myExclusionLabel 
RETURN count(n)
```",2,62944728
5677,https://stackoverflow.com/a/62921830,Neo4j Optimizing query to get all distinct tags,true,"Yes, a `MATCH` pattern with disconnected terms causes cartesian products, which should be avoided.

You should do this instead:

    MATCH (q:Question)-[:HAS_TAG]-&gt;(t:Tag)
    WHERE q.id &lt; 2
    RETURN DISTINCT t.name

[UPDATE]

Also, to optimize the lookup of the desired `Question` nodes, you can create an [index](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/) on `:Question(id)`. That should avoid having to scan through *all* `Question` nodes.",1,62921830
5678,https://stackoverflow.com/a/62901703,Neo4j Syntax Exception while creating an apoc procedure inside a apoc trigger,false,"With respect to your immediate question, you need to pass `node` to `apoc.do.when` so that its internal query can access it.

However, in actuality, you should change your query so that the internal query does not even need to do a `MATCH`:

    CALL apoc.trigger.add(
      &#39;loadEnrollments&#39;,   
      &quot;UNWIND apoc.trigger.nodesByLabel($assignedLabels, &#39;Enrollment&#39;) AS node
       MERGE (p1:SPerson { name: node.name, cell: node.cell, created_at: node.created_at})
       WITH p1, node
       MATCH (c:Course {name: &#39;Paradigm Shifting 101&#39;})
       MATCH (n:SPerson)
       WITH p1, c, node, COUNT(n) as size
       CALL apoc.do.when(
         size&gt;3,
         &#39;MERGE (p1)-[:Waitlist]-&gt;(c)&#39;,
         &#39;MERGE (p1)-[:Enrolled]-&gt;(c)&#39;,
         {p1: p1, c: c}
       ) YIELD value
       DETACH DELETE node&quot;, 
       { phase: &#39;after&#39; }
    );",0,62901703
5679,https://stackoverflow.com/a/62892625,Cypher: Very slow relationship creation (UNWIND),true,"I found a good solution. Execute this query on your database: 

`CREATE CONSTRAINT node_id ON (n:Node) ASSERT n.id IS UNIQUE` 

It will speed up everything. The idea is the following: if you match node by using the `id`, you must make sure that `id` is unique. If it&#39;s not, the time complexity of the query grows a lot.
",0,62892625
5680,https://stackoverflow.com/a/62927311,exponential performance cost on aggregated function,false,"I&#39;m not too good at neo4j either, but I&#39;ll a try. Not really sure why the results are so large, but may be due to the second one having an `ORDER BY`

Here&#39;s what I came up with

    MATCH
    	(user:Users)-[watched:WATCH]-&gt;(movie1:MOVIES)
    	WHERE
    		movie1.genre = &quot;action&quot; and
    		watched.date &gt;= date({year: 2020, month: 06, day: 01})
    MATCH
    	(user)-[watches_other:WATCH]-&gt;(movie2:MOVIES)
    	WHERE
    		movie1 &lt;&gt; movie2 and
    		movie1.subgenre = movie2.subgenre and
    		watches_too.date &gt;= date({year: 2020, month: 06, day: 01})
    WITH
    	user.id AS id,
    	COLLECT(movie2.title) as titles
    RETURN
    	id, titles
    LIMIT 100;",0,62927311
5681,https://stackoverflow.com/a/62879905,Neo4j:Delete all relationships except for those in list,true,"This should work:

    WITH [&#39;test1&#39;, &#39;test2&#39;] AS tests
    MATCH (p:Person {name: &#39;John&#39;})
    OPTIONAL MATCH (p)-[d:DRIVES]-&gt;(c:Car)
    WHERE NOT c.name IN tests
    DELETE d
    RETURN p

and also this:

    WITH [&#39;test1&#39;, &#39;test2&#39;] AS tests
    MATCH (p:Person {name: &#39;John&#39;})
    FOREACH(x IN [(p)-[d:DRIVES]-&gt;(c:Car) WHERE NOT c.name IN tests | d] | DELETE x)
    RETURN p",1,62879905
5682,https://stackoverflow.com/a/62873250,even after null check why I am getting null value in neo4j?,false,Most probably m.title has no value  or does not exist.,0,62873250
5683,https://stackoverflow.com/a/62880182,even after null check why I am getting null value in neo4j?,false,"Since an `OPTIONAL MATCH` *does not have to match* (e.g., if a `b` has no `DIRECTED` relationships), your query&#39;s `RETURN` clause can legitimately see a NULL `m` (and also a NULL `m.title`).

If you just want to see a (possibly empty) *list* of `m.title` values (any of which could be NULL if that movie has no `title`):

    MATCH (a:Person)-[:HAS_CONTACT]-&gt;(b)
    RETURN a.name, b.name, [(b)-[:DIRECTED]-&gt;(m:Movie) | m.titles] AS titles
    LIMIT 1",0,62880182
5684,https://stackoverflow.com/a/62895617,How do I qualify and name a relationship in Neo4j APOC?,false,"Solved. The correct format was to qualify in the selection for a,b as (a:ProgNode{inode:row.parent, compileunit:row.compile}), and to simply add row.tree to the index. All closed for now. Thanks to Maxime Guery at Data Nostra 

The full query ended up being 

            with graphDB_Driver.session() as ses:
            ses.run(&quot;UNWIND $batch AS row MATCH (a:ProgNode{inode:row.parent, compileunit:row.compile}) MATCH (b:ProgNode{inode:row.child, compileunit:row.compile}) CALL apoc.merge.relationship(a, row.tree, {compileunit:row.compile}, apoc.map.removeKeys(properties(row), [&#39;parent&#39;, &#39;child&#39;]),b) YIELD rel RETURN 1&quot;, batch=BATCH[&quot;batch&quot;])",0,62895617
5685,https://stackoverflow.com/a/62862223,Skip reverse path in neo4j query,true,"You could add: 

WHERE id(p) &lt; id(r) 

",1,62862223
5686,https://stackoverflow.com/a/62844908,Getting an unclear Error Message in Neo4j with APOC batch loader,true,"The `&quot;batch&quot; data structure` in your question contains neither of the properties required by your Cypher code:

    nodetype
    node

You have to make sure that all the elements in the `$batch` list have at least those 2 properties if you want to use that Cypher code.",1,62844908
5687,https://stackoverflow.com/a/62844962,How to show relationships in an optional manner in neo4j?,false,"Here is one way:

    MATCH p = (:person1 {hobby: &#39;gamer&#39;})-[:knows]-(:person2)
    RETURN p
    UNION ALL
    MATCH p = (:person1 {hobby: &#39;gamer&#39;})-[:knows]-(:person2)--(:person3)
    RETURN p

The [UNION](https://neo4j.com/docs/cypher-manual/current/clauses/union/#query-union) clause combines the results of 2 queries. And the `ALL` option tells `UNION` to not bother to remove duplicate results (since the 2 subqueries will never produce the same paths).",0,62844962
5688,https://stackoverflow.com/a/62846574,How to show relationships in an optional manner in neo4j?,false,"If you really want the path to be returned, you can do something along these lines, using apoc (https://neo4j-contrib.github.io/neo4j-apoc-procedures/3.4/nodes-relationships/path-functions/)

````
MATCH requiredPath=(n)-[r]-&gt;(m)
OPTIONAL MATCH optionalPath = (m)-[q]-&gt;(s)
RETURN apoc.path.combine(requiredPath,optionalPath) AS p
````",0,62846574
5689,https://stackoverflow.com/a/62845834,Limit Neo4j apoc.path.expand by relationship property value,true,"I don&#39;t think you can do this in one go, because you you have to compare for each step in each path.

Also you have to think of the case where you have scores like 0.09,0.11,0.11,0,12
in which taking the top 2 could return arbitrary results.

````

MATCH p=(n0)-[:TO*1..3]-&gt;()
// From starting node
WHERE n0.n=&#39;a&#39;
// get for each node the scores of the outgoing reps, sort them and get the second one
// and put them in an array
WITH p,
     REDUCE (array=[], n IN [x in nodes(p) WHERE (x)-[:TO]-&gt;()] |
             (array
             + apoc.coll.sort([(n)-[r:TO]-&gt;() | r.score])[1])
            ) AS cutOffScoresByStep
WITH p,cutOffScoresByStep

// only get the paths where the score on each rel is higher than the corresponding cutOffScore
WHERE ALL (rel IN relationships(p) 
           WHERE rel.score &gt;= cutOffScoresByStep[apoc.coll.indexOf(relationships(p),rel)]
          )
             
RETURN p
````",1,62845834
5690,https://stackoverflow.com/a/62852832,NEO4J - RHEL7 - Cannot create constraint on empty DB,false,"It would seem the database might not be empty due to this error:

&gt; Existing data does not satisfy CONSTRAINT ON ( label[1]:label[1] )
&gt; ASSERT label[1].property[0] IS UNIQUE

It complains that the constraint cannot be created as the existing data does not satisfy the constraint.

You can find the culprit with this query:

    MATCH ( e:Equipment ) 
    WITH e.UUID as id, count(*) as count
    WHERE count &gt; 1
    RETURN id;

",0,62852832
5691,https://stackoverflow.com/a/62877669,NEO4J - RHEL7 - Cannot create constraint on empty DB,true,"In the end, it was a problem with the deployment. A newer lucene library was deployed, one that did not contain that method.",0,62877669
5692,https://stackoverflow.com/a/62839428,Get start and end nodes of specific path in a large graph,false," 1. The `(start_node)` in your `MATCH` patterns should specify a label (like `(start_node:Foo)`), to avoid having to scan `every` node in the DB. Also, you should create an [index](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/) (or uniqueness constraint) for that start node.
 2. You should make all the relationships in your `MATCH` patterns `directional`, if appropriate. That is, put an arrow on either end.
 3. You should specify the relationship *types* in your patterns as well (like `()-[:BAR]-&gt;()`), so that the query would not be forced to evaluate *all* relationship types.",1,62839428
5693,https://stackoverflow.com/a/62842854,any way to limit result by node,false,"You can do it by inserting a COLLECTing and getting the first n items of it.

````
MATCH (user:Users)-[buy:Sales]-&gt;(item:Items)&lt;-[buy2:Sales]- (user2:Users)-[buy_other:Sales]-&gt;(item2:Items)
WHERE item.category = item2.category

// this is where you collect and get some items of it
WITH user,COLLECT(item2)[0..2] AS item2s
UNWIND item2s AS item2


RETURN
user.mail, item2.id
````",0,62842854
5694,https://stackoverflow.com/a/62831435,Return all relationships,false,"You need to match a relationship pattern:

    MATCH ()-[r:MEMBER]-() 
    RETURN r",1,62831435
5695,https://stackoverflow.com/a/62831814,Return all relationships,true,"Since Neo4j&#39;s relationships always have a direction, this is the fastest.

```
MATCH ()-[r:MEMBER]-&gt;()
RETURN r
```

Neo4j&#39;s browser will not display a graph, but just return the property maps of the relationships.

",0,62831814
5696,https://stackoverflow.com/a/62820262,Using Unwind and Dumping Data in neo4j - Query Optimization,false,"I think your main problem lies in how you merge and match the nodes. Ideally, you always want to have a unique identifier for nodes. I can see that `Friend` node has a property `id`, which I will assume is unique for every `Friend` and `Target`.

First, you want to create a unique constraint on that property:

    CREATE CONSTRAINT ON (f:Friend) ASSERT f.id IS UNIQUE;
    CREATE CONSTRAINT ON (f:Target) ASSERT f.id IS UNIQUE;

You want something similar for `Location` nodes as well. seems like you store both location value and the lowercase value of location, so any of them should be unique for each node.

    CREATE CONSTRAINT ON (l:Location) ASSERT l.id IS UNIQUE;

Now you can optimize your query like this:

    &quot;&quot;&quot;UNWIND [{id: &quot;1235&quot; , uid : &quot;0&quot;}] as user
    
        UNWIND &quot;&quot;&quot;+ l +&quot;&quot;&quot; as c
    
        OPTIONAL MATCH (n:Target {id : c.id})
    
        OPTIONAL MATCH (m:Friend {id : c.id})
    
        WITH coalesce(n, m) as node,user,c // returns first non-null value
    
        CALL apoc.do.when(node is null,
        &quot;MERGE (n:Friend {id:c.id}) 
         ON CREATE SET n+= {name:c.name, profile: c.profile, 
               location:c.location, uid : user.uid} 
         RETURN n&quot;, &#39;&#39;, {c:c,user:user})
        YIELD value
        with coalesce(node, value.n) as y,user,c
        MERGE (u:Target {id: user.id , uid : user.uid})
        &quot;&quot;&quot;+create_rel+&quot;&quot;&quot;
    
        foreach (sc in c.cityn | 
            merge(cn:Location {location:sc.location}) 
            ON CREATE SET cn.loc_lower = sc.loc_lower 
            merge (y)-[:`located_at`]-(cn))
    
        &quot;&quot;&quot;",0,62820262
5697,https://stackoverflow.com/a/62822175,Using Unwind and Dumping Data in neo4j - Query Optimization,false,"1. You should avoid running multiple write queries (that can touch the same nodes and relationships) concurrently, as that could cause intermittent `TransientError`s, as you have seen. (However, queries that cause transient errors *can* be retried.)
2. You should be passing `user` and `l` to your query as [parameters](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/), so that the Cypher planner will only need to compile the query *once*, and to make the query less prone to Cypher-injection attacks. (Also, there is no need to `UNWIND` a list that will always have just a single map -- you could have directly used the map via `WITH {id: &quot;1235&quot; , uid : &quot;0&quot;} AS user`. But, as I mentioned, you should just pass the `user` map as a parameter so you can efficiently change the user without forcing a recompilation.)
3. To avoid recompilation, you also need to need to make the `create_rel` string a constant string (so, it might as well be directly in your main query string). Again, you should also pass any variables needed by that as parameters.
4. You should create [indexes](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/) (or uniqueness constraints) on `:Target(id)` and `:Friend(id)`, to speed up your `MATCH` and `MERGE` clauses.
5. (a) `MERGE (u:Target {id: user.id , uid : user.uid})` only needs to be executed *once*, not per `c` value. So, it should be executed *before* the `UNWIND`.

   (b) Also, it is not strictly necessary for this query to create `u`, since nothing in the query uses it. So, instead of running this identical `MERGE` clause once per thread, you should consider taking it out and running it a separate standalone query.

Here is a query that combines suggestions #2 and #5a (but you will have to take care of the others yourself), along with some refactoring using [pattern comprehension](https://neo4j.com/docs/developer-manual/3.4/cypher/syntax/lists/#cypher-pattern-comprehension) to avoid unnecessary DB hits: 
    
    MERGE (u:Target {id: $user.id, uid: $user.uid})
    WITH u
    UNWIND $l as c
    WITH u, c, [(n:Target {id : c.id})-[*0]-()|n] AS nodeList
    WITH u, c, CASE WHEN SIZE(nodeList) = 0 THEN [(n:Friend {id : c.id})-[*0]-()|n] ELSE nodeList END AS nodeList
    CALL apoc.do.when(SIZE(nodeList) = 0, &#39;MERGE (n:Friend {id: c.id, name: c.name, profile: c.profile, location: c.location, uid: user.uid}) RETURN n&#39;, &#39;RETURN nodeList[0] AS n&#39;, {c:c,user:$user,nodeList:nodeList}) YIELD value
    WITH u, c, value.n AS node
    FOREACH (sc IN c.cityn | MERGE (cn:Location {location: sc.location, loc_lower: sc.loc_lower}) MERGE (node)-[:located_at]-(cn))

    // Put your parameterized create_rel code here",0,62822175
5698,https://stackoverflow.com/a/62803241,Cypher query creating new nodes instead of building relationship with existing nodes,true,"Since the existing nodes store `personID` as an integer, you need to convert the `person` string values to integers via the `TOINTEGER()` function:

    MATCH (m:Mem)
    UNWIND m.personID as person
    MERGE (p:Person {personID: TOINTEGER(person)})
    MERGE (m)-[:WITH]-&gt;(p)

",1,62803241
5699,https://stackoverflow.com/a/62800542,Unwind array and match with other nodes using Cypher on Neo4j graph database,true,"[UPDATED]

This should work for you:

    MATCH (m:Mem)-[:WITH]-&gt;(p:Person)
    WHERE p.personID IN m.personID
    RETURN m.mem, m.date, p.personID, p.nickname

Also, notice that the relationship pattern must use`:WITH` instead of `WITH` if you want to query for the `WITH` relationship type.

### Addendum

Of course, since you have the `WITH` relationships, you should consider deleting the redundant `m.personID` property. You should get the same results without `m.personID` this way:

    MATCH (m:Mem)-[:WITH]-&gt;(p:Person)
    RETURN m.mem, m.date, p.personID, p.nickname",1,62800542
5700,https://stackoverflow.com/a/62784079,Get the nodes which are all connected with my input node using py2neo and flask,true,"Suppose your nodes have a property called `nodeid`, you can use [`NodeMatcher()`](https://py2neo.org/v4/matching.html#py2neo.matching.NodeMatcher) to match node `2` (see [Node Matching](https://py2neo.org/v4/matching.html#node-matching)), then iterate over its adjacent nodes:

```python
from py2neo import Graph, NodeMatcher

matcher = NodeMatcher(graph)

node = matcher.match(nodeid=&quot;2&quot;).first()

list(r.end_node[&quot;nodeid&quot;] for r in graph.match(nodes=(node,)))
```

Otherwise, just run a cypher query:

```
q = &#39;&#39;&#39;MATCH (a)-[r]-(b) where a.nodeid=&#39;2&#39; RETURN b&#39;&#39;&#39;
[i for i in graph.run(q)]
```",1,62784079
5701,https://stackoverflow.com/a/62781912,How to get counts of Edges related to a node in one query - NEO4J,true," 1. You need to read the documentation on [aggregating functions](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) (like `COUNT`). In particular, you need to understand that the `WITH` (and `RETURN`) clause treats terms that *do not* contain aggregating functions as the &quot;grouping keys&quot; for the terms that *do* contain aggregating functions.

    For example, a clause such as `WITH foo, COUNT(foo) AS fooCount` will *always* produce a `fooCount` of 1.

 2. `WITH` clauses *must* specify the bound variables whose values you want to use later in the same query; any unspecified variables will be dropped. SInce your second and third `WITH` clauses do not specify `p`, their subsequent `MATCH` clauses are actually NOT using the previously bound value for `p` (but creating totally new `p` variables, each having multiple values).

 3. You should use `OPTIONAL MATCH` instead of `MATCH` to get the counts of things that may not exist. A `MATCH` would cause the entire query to abort if it fails to find a match.

 4. You neglected to make the `(p)-[ro:REPOST_OF]-(:Post)` relationship pattern *directional*. If you wanted to get a count of the number of times that `p` was reposted, so you should have used the pattern `(p)&lt;-[ro:REPOST_OF]-(:Post)`.

 5. You forgot to return `upvotes`.

 6. You should use `ORDER BY posted.date DESC` instead of `ORDER BY -posted.date`.

This may work better for you:

    MATCH (:User {id: &quot;172ed572-e3af-d3ee-77c0-8d9d181b12f1&quot;})-[:COLLEAGUE_OF]-(user:User)-[posted:POSTED]-&gt;(p:Post)
    WHERE posted.date &gt;= 0
    OPTIONAL MATCH (p)&lt;-[ro:REPOST_OF]-(:Post)
    WITH p, posted, user, COUNT(ro) AS reposts
    OPTIONAL MATCH (p)-[rt:REPLY_TO]-&gt;(:Post)
    WITH p, posted, user, reposts, COUNT(rt) AS replies
    OPTIONAL MATCH (p)-[uv:UP_VOTE]-&gt;(:Post)
    RETURN p, posted, user, reposts, replies, COUNT(uv) AS upvotes
    ORDER BY posted.date DESC

",1,62781912
5702,https://stackoverflow.com/a/62782631,How to select Array element with Cypher Query,true,"If possible, it would be more convenient to change your CSV file&#39;s data format for the `friends` column to be a semicolon-delimited list (assuming that no list element will ever contain a semicolon or comma), like this:

    user_id,name,review_count,friends,useful,funny,cool
    ntlvfPzc8eglqvk92iDIAw,Rafael,553,oeMvJh94PiGQnx_6GlndPQ;wm1z1PaJKvHgSDRKfwhfDg;IkRib6Xs91PPW7pon7VVig;A8Aq8f0-XvLBcyMk2GJdJQ,628,225,227

Once that is done, you can import the `User` nodes like this:

    LOAD CSV WITH HEADERS FROM &#39;file:///test.csv&#39; AS row
    MERGE (u:User {id: row.user_id})
    SET u += row{
      .name, .useful, .funny, .cool,
      review_count: TOINTEGER(row.review_count),
      friends: SPLIT(row.friends, &#39;;&#39;)
    }
    RETURN u

And after importing is completed, this query:

    MATCH (u:User)
    WHERE u.name = &#39;Rafael&#39;
    RETURN u.friends

will return:

    ╒═════════════════════════════════════════════════════════════════════════════════════════════════════╕
    │&quot;u.friends&quot;                                                                                          │
    ╞═════════════════════════════════════════════════════════════════════════════════════════════════════╡
    │[&quot;oeMvJh94PiGQnx_6GlndPQ&quot;,&quot;wm1z1PaJKvHgSDRKfwhfDg&quot;,&quot;IkRib6Xs91PPW7pon7VVig&quot;,&quot;A8Aq8f0-XvLBcyMk2GJdJQ&quot;]│
    └─────────────────────────────────────────────────────────────────────────────────────────────────────┘

[UPDATE]

If you want to create unique `FRIEND` relationships with the friends (instead of creating a `friends` property), this should work:

    LOAD CSV WITH HEADERS FROM &#39;file:///test.csv&#39; AS row
    MERGE (u:User {id: row.user_id})
    SET u += row{
      .name, .useful, .funny, .cool,
      review_count: TOINTEGER(row.review_count)
    }
    UNWIND SPLIT(row.friends, &#39;;&#39;) AS friendId
    MERGE (f:User {id: friendId})
    MERGE (u)-[:FRIEND]-(f)
    RETURN u

`MERGE (u)-[:FRIEND]-(f)` uses an *undirected* relationship, and will only create the relationship if there is not already one (in either direction).",1,62782631
5703,https://stackoverflow.com/a/62783025,Count how many dates in a list are between two dates,true," 1. Your `MATCH` is scanning ALL the nodes in your database to find the `CONNECTED_TO` relationships. You should be qualifying the end nodes with the `Tag` label to scan just the `Tag` nodes.
 2. You should be calculating the static `date` values just once.
 3. You should use the `REDUCE` function instead of list comprehension (which generates new lists that your query will just drop) to count the dates within range.
 4. There is no need to use the `RANGE` function, which also generates a list.

This query should be faster:

    WITH date({year: 2019, month: 12}) AS a, date({year: 2019, month: 1}) AS b
    MATCH (:Tag)-[c:CONNECTED_TO]-(:Tag)
    RETURN ID(c) AS id, REDUCE(s=0, d IN c.dates | CASE WHEN a &gt; d &gt;= b THEN s + 1 ELSE s END) AS Size

",2,62783025
5704,https://stackoverflow.com/a/62775781,Store a collection as a node in Neo4j,false,"The second part looks easy enough:
- give the A nodes a distinct label
- `MATCH (n:A_LABEL) WHERE a.b_property &gt; 35 RETURN (n)`
- iterate over the list, checking for a relationship from the first one to each of the rest, and creating one if it&#39;s not there.

Could the values change over time? If so, you may need a corresponding function that removes this kind of relationship from nodes whose score is now &lt;= the threshold value.


It&#39;s harder to advise about how to store the collections, without knowing more about the problem you&#39;re solving.",0,62775781
5705,https://stackoverflow.com/a/62818610,Store a collection as a node in Neo4j,true,"[UPDATED]

Your query is doing a lot of unnecessary work. Also, your `Itemset` is always a list containing a single map, so having a list seems unnecessary.

This query should be equivalent (except that `Itemset` is just a map):

    MATCH (t:Trans)-[:CONTAINS]-&gt;(i2:Item), (t)-[:CONTAINS]-&gt;(i1:Item), (t)-[:CONTAINS]-&gt;(i3:Item) 
    WITH {i1: i1.I_ID, i2: i2.I_ID, i3: i3.I_ID} AS Itemset, COUNT(*) as NumTransactions
    WHERE NumTransactions &gt; 100
    RETURN Itemset, NumTransactions

It feels to me like you should not be storing the `Itemset` in an `A` node. Here is an example of how to create relationships from each `Item` to the same `B` node:

    MATCH (t:Trans)-[:CONTAINS]-&gt;(i2:Item), (t)-[:CONTAINS]-&gt;(i1:Item), (t)-[:CONTAINS]-&gt;(i3:Item) 
    WITH i1.I_ID AS id1, i2.I_ID AS id2, i3.I_ID AS id3, COUNT(*) as c
    WHERE c &gt; 100
    MERGE (b:B {numTransactions: c})
    MERGE (i1)-[:FOO]-&gt;(b)
    MERGE (i2)-[:FOO]-&gt;(b)
    MERGE (i3)-[:FOO]-&gt;(b)",0,62818610
5706,https://stackoverflow.com/a/62764750,Neo4J - Post pagination for multiple Unions,false,"If you can [migrate/upgrade](https://neo4j.com/docs/operations-manual/current/upgrade/planning/) to neo4j 4.x, you can take advantage of the newly-added support for [post-union processing](https://neo4j.com/docs/cypher-manual/current/clauses/call-subquery/#subquery-post-union):

    CALL {
      MATCH(node:D1593731983259)
        WHERE toLower(node.name) CONTAINS $searchTerm
      RETURN node
      UNION
      MATCH(node:D1593031169841)
        WHERE toLower(node.name) CONTAINS $searchTerm
      RETURN node
    }
    RETURN node
    SKIP 20 LIMIT 20",1,62764750
5707,https://stackoverflow.com/a/62762423,Handling nested optional data in cypher Neo4j,true,"[UPDATED]

The second element in your `questions` list is missing all the `guid` properties expected by your Cypher code.

Here is a fixed example (that provides all the expected `guid` properties):

    WITH [
      {
        text: &quot;something&quot;,
        guid: &quot;9a4aeac0-4ea4-469a-80c1-908573a4ad55&quot;,
        answer: [
          {
            text: &quot;something&quot;,
            guid: &quot;9a4aeac0-4ea4-469a-80c1-908573a74635&quot;,
            correct: false
          },
          {
            text: &quot;something&quot;,
            guid: &quot;9a4aeac0-4ea4-469a-80c1-908573a4ad22&quot;,
            correct: false
          },
          {
            text: &quot;something&quot;,
            guid: &quot;9a4aeac0-4ea4-469a-80c1-908573a4a987&quot;,
            correct: false
          }
        ]
      },
      {
        text: &quot;something&quot;,
        guid: &quot;9a4aeac0-4ea4-469a-80c1-908573a4ad66&quot;,
        answer: [
          {
            text: &quot;something&quot;,
            guid: &quot;9a4aeac0-4ea4-469a-80c1-908573a74611&quot;,
            correct: false
          },
          {
            text: &quot;something&quot;,
            guid: &quot;9a4aeac0-4ea4-469a-80c1-908573a74622&quot;,
            correct: false
          },
          {
            text: &quot;something&quot;,
            guid: &quot;9a4aeac0-4ea4-469a-80c1-908573a74633&quot;,
            correct: false
          }
        ]
      }
    ] as questions
    
    MATCH (dot:Dot{GUID: &quot;9a4aeac0-4ea4-469a-80c1-908573a4ad61&quot;})
    
    FOREACH (question IN questions |
      MERGE (q:Trivia:Question { GUID: question.guid })
        ON CREATE SET q.GUID = apoc.create.uuid(), q.creationDate = datetime(), q.text = question.text
        ON MATCH SET q.text = question.text
      MERGE (q)-[g:IS_ABOUT]-&gt;(dot)
        ON CREATE SET g.creationDate = datetime()
      FOREACH (answer IN question.answer |
        MERGE (a:Trivia:Answer { GUID: answer.guid })
          ON CREATE SET a.GUID = apoc.create.uuid(), a.creationDate = datetime(), a.text = answer.text, a.correct = answer.correct
          ON MATCH SET  a.text = answer.text, a.correct = answer.correct
        MERGE (a)-[t:TO]-&gt;(q)
          ON CREATE SET t.creationDate = datetime()
      )
    )
    
    RETURN dot",0,62762423
5708,https://stackoverflow.com/a/62720268,is is Possible oin CYPHER to Set (Copy) the Labels of Another Node?,false,"Doubt it worked before. At the moment, cypher does not support assigning dynamic labels. You will have to use the [APOC library][1] to achieve this. If you want to create a node with dynamic labels you could use:

    CALL apoc.create.node([&#39;Label&#39;,&#39;Label2&#39;], {key:value,property:value})

Or you can also just assign dynamic labels to an existing node:

    CALL apoc.create.addLabels( [node,id,ids,nodes], [&#39;Label&#39;,&#39;Label2&#39;])


  [1]: https://neo4j.com/docs/labs/apoc/current/


",0,62720268
5709,https://stackoverflow.com/a/62712312,filtering a fulltext search with a relationship constraint,false,"I don&#39;t know what are you trying to achieve, but there are some red flags in your query I would like to point out.

    WITH
        node,
        COLLECT(node) AS nodes,
        COUNT(node) AS total

When aggregating with the cypher, it uses an implied grouping, meaning that all the columns in the `WITH` statement are automatically used to aggregate by or a groupby of the SQL world. So your the above statement will always collect only 1 node and the count will be 1 as well.

Next, you already have a node variable declared, yet you use it in the `OPTIONAL MATCH`, which is weird and probably wrong.

    OPTIONAL MATCH
        (node)
        WHERE
            node.account_id = $account_id

This is probably also the place where you create more duplicates.

If you only want to filter out the nodes that have a MEMBER relationship to the specific account id, I would use the following query:

    CALL db.index.fulltext.queryNodes(
        &quot;titleAndKeywords&quot;, 
        $search_text) 
    YIELD node
    WITH node
        WHERE $label in labels(node)
    // Filter our only nodes with a relationship
    // to specific account
    MATCH 
        (a:Account {
                id : $account_id
            })
        -[:MEMBER]-&gt;
        (node)
    // collect the nodes so we can get the total
    WITH collect(nodes) as nodes, 
         count(*) as total
    // You can do the pagination as array slicing
    RETURN nodes[$skip..$skip + $limit] as result, total",1,62712312
5710,https://stackoverflow.com/a/62713336,filtering a fulltext search with a relationship constraint,false,"This is what I came up with in the end, using node matching

    CALL {
    	MATCH 
    		(a:Account { 
    				id : $account_id 
    			})
    		-[:MEMBER]-&gt;
    		(n1:Workspace)
    	RETURN n1 AS n
    	
    	UNION
    	
    	MATCH
    		(n2:Workspace { 
    			account_id : $account_id
    		})
    	RETURN n2 AS n
    }
    
    CALL db.index.fulltext.queryNodes(
    	&quot;titleAndKeywords&quot;, 
    	$search_text) 
    YIELD node
    
    WITH n, node
    	WHERE n = node
    
    WITH
    	COLLECT(n) AS results,
    	COUNT(n) AS total
    	
    RETURN results[$skip..$skip + $limit] AS results, total",0,62713336
5711,https://stackoverflow.com/a/62714160,filtering a fulltext search with a relationship constraint,false,"Did you try, instead of OPTIONAL MATCH

WHERE
(a:Account {
            id : $account_id
        })
    -[:MEMBER]-&gt;
    (node))",1,62714160
5712,https://stackoverflow.com/a/62698230,How do you find all nodes with exactly N relationships of a single type?,true,"You can aggregate by [COUNT][1]:

    MATCH (b:B)-[:rel]-&gt;(a:A)
    WITH b, count(a) AS cnt WHERE cnt = 3 // or for example WHERE cnt IN [3, 4]
    RETURN b

**Upd:** Try to use the [COLLECT][2] and [SIZE][3] functions if you need to return nodes connected to (:B):

    MATCH (b:B)-[:rel]-&gt;(a:A)
    WITH b, 
         collect(a) AS nds WHERE size(nds) = 3
    RETURN b, nds


  [1]: https://neo4j.com/developer/aggregation-returns-functions/#aggregate-count
  [2]: https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-collect
  [3]: https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size",0,62698230
5713,https://stackoverflow.com/a/62704437,How do you find all nodes with exactly N relationships of a single type?,false,"I guess it can be shorter

````
MATCH (b:B)
WHERE size((b)-[:rel]-&gt;(:A)) = 3
RETURN b,[(b)-[:rel]-&gt;(a:A) | a ] AS nds
````",0,62704437
5714,https://stackoverflow.com/a/62856566,Neo4J CYPHER in C# or Java: Return JSON output from “call db.schema.nodeTypeProperties()”?,false,"I was able to get what I wanted by using `apoc.export.json.all` to stream in a JSON dataset of the entire database. I leveraged the examples at https://neo4j.com/docs/labs/apoc/current/export/json/#export-database-json. I apologize for what turned out to be the misdirection of my question. `db.schema.nodeTypeProperties()` was not going to get me what I really needed.

```
using Newtonsoft.Json.Linq;

public async void TestNeo4j()
{
    // Set up the graph database driver and connect the session to the Neo4J database.
    IDriver driver = GraphDatabase.Driver(Neo4JBoltURI, AuthTokens.Basic(Neo4JUser, Neo4JPassword));
    IAsyncSession session = driver.AsyncSession();
    IResultCursor cursor;

    try
    {
        // Bring the JSON text in as a stream
        string query = &quot;CALL apoc.export.json.all(null,{stream:true,useTypes:true}) &quot; +
            &quot;YIELD file, nodes, relationships, properties, data &quot; +
            &quot;RETURN file, nodes, relationships, properties, data&quot;;

        cursor = await session.RunAsync(query);
        string sJsonData = await cursor.SingleAsync(record =&gt; record[&quot;data&quot;].As&lt;string&gt;());
        //Debug.Log(sJsonData);

        //// Save the JSON to a file.
        //string path = @&quot;C:\Users\Public\Documents\Neo4JExportAll.json&quot;;
        //if (File.Exists(path)) File.Delete(path);
        //File.WriteAllText(path, sJsonData);

        // Each line is a separate JSON statement describing a node or a relationship
        // Iterate all statements
        using (StringReader reader = new StringReader(sJsonData))
        {
            string line = string.Empty;
            do
            {
                line = reader.ReadLine();
                if (line != null)
                {
                    // Deserialize the JSON line into JObject jo.
                    JObject jo = JObject.Parse(line);
                    // Dig into the JObject to get the data from the stream.
                }

            } while (line != null);
        }
    }
    finally
    {
        await session.CloseAsync();
    }
}

```",0,62856566
5715,https://stackoverflow.com/a/62673113,javascript neo4j-driver how to convert datetime into string,false,"Since DateTime returns a bunch of neo4 int style stuff e.g.

    DateTime {
      year: Integer { low: 2020, high: 0 },
      month: Integer { low: 7, high: 0 },
      day: Integer { low: 1, high: 0 },
      hour: Integer { low: 8, high: 0 },
      minute: Integer { low: 48, high: 0 },
      second: Integer { low: 18, high: 0 },
      nanosecond: Integer { low: 833000000, high: 0 },
      timeZoneOffsetSeconds: Integer { low: 0, high: 0 },
      timeZoneId: null
    }

I am converting the field with .toString()

    export function convertDateToString (
    	date)
    	: string {
    		const date_values = [];
    		for (const key in date) {
    			const cursor = date[key];
    			if (cursor) {
    				date_values.push(cursor.toString());
    			}
    		}
    		const the_date = new Date(...date_values as [number, number, number, number, number, number]);
    		return the_date.toUTCString();
    }

",-1,62673113
5716,https://stackoverflow.com/a/69077931,javascript neo4j-driver how to convert datetime into string,true,"This should work- addresses the two issues i commented on the accepted answer. Perhaps op already worked this out, but hopefully this will help somebody else. 

    import { DateTime } from &#39;neo4j-driver&#39;;
    
    /**
     * Convert neo4j date objects in to a parsed javascript date object
     * @param dateString - the neo4j date object
     * @returns Date
     */
    const parseDate = (neo4jDateTime: DateTime): Date =&gt; {
      const { year, month, day, hour, minute, second, nanosecond } = neo4jDateTime;
    
      const date = new Date(
        year.toInt(),
        month.toInt() - 1, // neo4j dates start at 1, js dates start at 0
        day.toInt(),
        hour.toInt(),
        minute.toInt(),
        second.toInt(),
        nanosecond.toInt() / 1000000 // js dates use milliseconds
      );
    
      return date;
    };

console.log output to compare dates -  

    DateTime {
       year: Integer { low: 2021, high: 0 },
       month: Integer { low: 9, high: 0 },
       day: Integer { low: 6, high: 0 },
       hour: Integer { low: 15, high: 0 },
       minute: Integer { low: 41, high: 0 },
       second: Integer { low: 30, high: 0 },
       nanosecond: Integer { low: 184000000, high: 0 },
       timeZoneOffsetSeconds: Integer { low: 0, high: 0 },
       timeZoneId: null
     }
     2021-09-06T15:41:30.184Z",0,69077931
5717,https://stackoverflow.com/a/62665225,Neo4j WHERE NOT clause for different nodes not working,false,"Try this query:

    match (a)-[:requires]-(b), 
          (a)-[:instanceOf]-&gt;(n)&lt;-[:superclassOf*]-(:Host_configuration)
    where not (b)-[:instanceOf]-&gt;(z)&lt;-[:superclassOf*]-(:Host)  
    return distinct a, b
It&#39;s possible to directly update the where clause with the path you want to exclude. You can define the where clause to exclude `b` where it is a subclass of `Host`.",0,62665225
5718,https://stackoverflow.com/a/62786049,Neo4j WHERE NOT clause for different nodes not working,false," 1. I believe you should care about the *direction* of the `(a)-[:requires]-(b)` pattern. If you do not specify a direction, you would not know who requires whom AND you might also get the same node pair *twice* (in opposite orders). In my answer, I assume you meant `(a)-[:requires]-&gt;(b)`, but you can easily reverse the direction if need be.
 2. For efficiency, you should perform *both* `instanceOf/superclassOf` tests [using path patterns in a WHERE clause](https://neo4j.com/docs/cypher-manual/current/clauses/where/#query-where-patterns). Such a path pattern just checks for a *single match* before succeeding, and does not bother to expend the resources to hunt down *all possible matches*. (By the way, a path pattern in a WHERE clause cannot introduce new variables.)
 3. Once the above issues are taken care of, your `MATCH` clause would just be `MATCH (a)-[:requires]-&gt;(b)`, and any given `a/b` pair would only be found once (as long as your DB has at most one `requires` relationship going *from* a given node *to* another given node). So that should mean that your `RETURN` clause can omit the `DISTINCT` option, which would be more efficient.

So, this may work better for you:


    MATCH (a)-[:requires]-&gt;(b)
    WHERE
      (a)-[:instanceOf]-&gt;()&lt;-[:superclassOf*]-(:Host_configuration) AND
      NOT (b)-[:instanceOf]-&gt;()&lt;-[:superclassOf*]-(:Host)
    RETURN a, b

By the way, it would also be more efficient for the `MATCH` clause to specify the node labels for `a` and `b`, so that the DB does not have to scan *every node* in the DB. I have not done that in my answer.",0,62786049
5719,https://stackoverflow.com/a/62660207,Improve Neo4j Cypher query performance,false,"The best approach to defining graph schemas is to have a unique id for each entity in your graph. This means that you could look up your nodes by their unique id. That way you can define a [unique constraint][1] for that property, which will speed up the query execution. For example, if the name property of the server were enough to look up the Server node, you could first define a unique constraint:

    CREATE CONSTRAINT constraint_name
    ON (s:Server) ASSERT s.name IS UNIQUE;

Then when you will be searching for the server, the queries will perform much better.

    MATCH (server:Server {name:row.`SOURCE_HOST`})

This is the best approach as far as I have seen. If you don&#39;t have unique property, you could create one by combining two properties, in your case `name + source`. If that is not an option for you, you can [create an index][2] on both `name` and `source` properties, and if you use the Enterprise version you can also create a [composite index][3] on both properties to optimize performance.


  [1]: https://neo4j.com/docs/cypher-manual/current/administration/constraints/
  [2]: https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/#administration-indexes-create-a-single-property-index
  [3]: https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/#administration-indexes-create-a-composite-index",0,62660207
5720,https://stackoverflow.com/a/62653104,Cannot aggregate total with a CALL with UNION,false,"If I understand you correctly, you get two rows with a result of 1 instead of 1 row with the result of 2. When aggregating in cypher it does implied groupby, meaning that all the columns in the `WITH` or `RETURN` statement will be used in the groupby statement by default. So if you want to return only a total count you can use:

    CALL {
        OPTIONAL MATCH 
            (a:Account { 
                    id : $account_id 
                })
            -[:MEMBER]-&gt;
            (n:Workspace)
        RETURN n
        
        UNION
    
        OPTIONAL MATCH
            (n:Workspace { 
                account_id: $account_id 
            })
        RETURN n
    }
    WITH n
    RETURN count(*) as total",1,62653104
5721,https://stackoverflow.com/a/62698655,Cypher - Aggregation with optional match,true,"Try to use [DISTINCT][1]:

    MATCH (a:Artifact)-[:CURRENT {root: &#39;art1&#39;}]-&gt;(c:ArtifactProperty)
    OPTIONAL MATCH (a:Artifact)-[:CURRENT {root: &#39;art1&#39;}]-&gt;(b:Artifact) 
    WITH a {
      .id, 
      children: collect(DISTINCT b {.id}), 
      properties: collect(DISTINCT c {.key, .value})
    } AS mapped
    RETURN mapped.id, mapped.children, mapped.properties


  [1]: https://neo4j.com/docs/cypher-manual/current/syntax/operators/#syntax-using-the-distinct-operator",1,62698655
5722,https://stackoverflow.com/a/62631888,"neo4j. Matching nodes, but I need to return edges if there",false,"```
MATCH (n)
WHERE &lt;complex condition&gt;
WITH COLLECT(n) AS nodes
MATCH (n)-[r]-(m)
WHERE (n IN nodes) AND (m in nodes)
AND id(n)&gt;id(m)
RETURN n,r,m
````",0,62631888
5723,https://stackoverflow.com/a/62653096,prevent (?i) to change to ({1}i) in a query String of PreparedStatement using neo4j-jdbc-3.5.1driver,true,"This sounds like a bug to me, the Neo4J drivers seems to unconditionally replace question marks with the Neo4J parameter placeholder (in this case inside a string literal), instead of only replacing where a parameter can occur syntactically. You should report this to Neo4J.

The workaround would seem to me to use a parameter here, and set your regular expression as the value of that parameter. 

That is, use

```
&quot;MATCH (n) WHERE n.name =~ ? RETURN n&quot;
```

And use `stmt.setString(1, &quot;(?i).*SUBSTRING.*&quot;)` to set the expression for that variable on the prepared statement.

Or as you suggested yourself in the comments, use:

```
&quot;MATCH (n) WHERE lower(&#39;n.name&#39;) contains lower(SUBSTRING) RETURN n&quot;
```",1,62653096
5724,https://stackoverflow.com/a/62595907,Cypher get all nodes but not every relationship for visualisation with neovis.js,true,"if you want all the :Tag nodes, including the ones that are not connected, try 

```
MATCH (t1:Tag)
OPTIONAL MATCH (t1)-[c:CONNECTED_TO]-&gt;(t2:Tag) 
WHERE c.count_question &gt; 50 
RETURN t1, c, t2
```",0,62595907
5725,https://stackoverflow.com/a/62583659,How can I create relationships in neo4j/Cypher from a csv that depend on the type of nodes?,true,"- You should be using `A.type` and `B.type` when appropriate.
- Since the nodes already exist, you should replace the 2 existing `MERGE` clauses with `MATCH` clauses.
- If you want to ensure you don&#39;t create duplicate relationships, you should use `MERGE` instead of `CREATE` for the relationship.
- You can use the APOC procedure [apoc.do.case](https://neo4j.com/docs/labs/apoc/current/cypher-execution/conditionals/#conditionals-case) to perform conditional write operations.

For example:

    LOAD CSV WITH HEADERS FROM &#39;file:///&#39; AS line
    CALL apoc.do.case([
      line.`A.type` = &#39;ASSET&#39; AND line.`B.type` = &#39;ORGANIZATION&#39;,
        &#39;MATCH (a:Asset {Name: line.FROM}), (b:Organization {Name: line.TO}) MERGE (a)-[:FOO]-&gt;(b) RETURN a, b&#39;,
      line.`A.type` = &#39;ASSET&#39; AND line.`B.type` = &#39;BANCO&#39;,
        &#39;MATCH (a:Asset {Name: line.FROM}), (b:Bank {Name: line.TO}) MERGE (a)-[:FOO]-&gt;(b) RETURN a, b&#39;,
      line.`A.type` = &#39;BANK&#39; AND line.`B.type` = &#39;ACTIVO&#39;,
        &#39;MATCH (a:Bank {Name: line.FROM}), (b:Asset {Name: line.TO}) MERGE (a)-[:FOO]-&gt;(b) RETURN a, b&#39;
      ],
      &#39;&#39;, // empty ELSE case
      {line: line}
      ) YIELD value
    RETURN value

",0,62583659
5726,https://stackoverflow.com/a/62580899,A method to sum all values in a returned column using Cypher in Neo4j,true,"This should work:

    MATCH (:Trans)-[:CONTAINS]-&gt;(i:Item) 
    WITH i, COUNT(*) as c
    WITH COLLECT({i: i, c: c}) AS data
    WITH data, REDUCE(s = 0.0, n IN data | s + n.c) AS total
    UNWIND data AS d
    RETURN d.i.ITEM_ID as item, d.c AS NumTransactions, d.c/total as support

*By the way, `SIZE(COUNT(t))` is inefficient, as it first creates a new collection of `t` nodes, gets its size, and then deletes the collection. `COUNT(t)` would have been more efficient.*

*Also, given your `MATCH` clause, as long as every `t` has at most a single `CONTAINS` relationship to a given `i`, `COUNT(*)` (which counts the number of result rows) would give you the same result as `COUNT(t)`.*
",0,62580899
5727,https://stackoverflow.com/a/62565123,Create multiple relationships in Neo4j using array of integers using Cypher,false,"You did not use the optimal strategy for importing the data. In a graph DB, it is not good practice to store data (like lists of IDs) that would *only* be used to create relationships later. That would leave you with a lot of redundant data that would never be used again (and ideally should be deleted).

A better strategy would involve 3 steps:

 1. Import the nodes from the `People` file - but *ignore* the Place ID lists
 2. Import the nodes from the `Place` file - but *ignore* the People ID lists
 3. Import the relationships from one of the files (I assume it does not matter which). For example, I&#39;ll assume we pick the `Place` file, and that each file row has an `id` field with the ID of a Place and a `people` field containing a semicolon-delimited collection of People IDs. A query like this would then create all the needed relationships (and avoid creating duplicates):

        LOAD CSV WITH HEADERS FROM &#39;file:///places.csv&#39; AS row
        MATCH (place:Place) WHERE place.id = row.id
        MATCH (person:People) WHERE person.id IN SPLIT(row.peopleIds, &#39;;&#39;)
        MERGE (person)-[:VISIT]-&gt;(place)

",0,62565123
5728,https://stackoverflow.com/a/62680966,Create multiple relationships in Neo4j using array of integers using Cypher,true,"I&#39;ve managed to track down a similar question to my one here, which provides an answer [here][1]

To solve my question I&#39;ve used the following:

    MATCH (p1:People)
    UNWIND p1.placeID as pID
    MERGE (p2:Place{placeID: pID})
    MERGE (p1)-[AT]-&gt;(p2)


  [1]: https://stackoverflow.com/questions/37861841/creating-relationships-based-on-array-values-in-neo4j",0,62680966
5729,https://stackoverflow.com/a/62562813,AES-128-CBC cipher in java,false,"AES-128 requires a 16 byte key. The &quot;128&quot; in &quot;AES-128&quot; is the key size in bits. Divide by 8 to get the key size in bytes == 16 bytes.

&gt;  I have the cipher algorithm in php with a 64 bytes key and it works

I am.... skeptical. I suspect it&#39;s somehow deriving a 16 byte key from the 64 bytes.

",3,62562813
5730,https://stackoverflow.com/a/62564115,AES-128-CBC cipher in java,false,"As stated by @dnault the en-/decryption key for AES-128 is 16 bytes long (AES-192 = 24 bytes, AES-256 = 32 bytes). You wrote that you are presenting a 64 character long key to the decryption method in PHP. My sample program shows that only the first 16 characters of the key were used.

**Solution for your Java-app:** just use the first (seen from the left side) 16 bytes of your &quot;key&quot; for encryption and decryption:

    &lt;?php
        // https://stackoverflow.com/questions/62562417/aes-128-cbc-cipher-in-java/62562813#62562813
        $method = &quot;AES-128-CBC&quot;;
        $plaintext = &quot;Hello World&quot;;
        $key = &quot;1234567890123456789012345678901234567890123456789012345678901234&quot;;
        var_dump($key);
        $iv =  &quot;\x08\x07\x05\x06\x04\x01\x02\x03\x12\x11\x0f\x10\x0e\x0b\x0c\x0d&quot;;
        $encrypted = base64_encode(openssl_encrypt($plaintext, $method, $key, OPENSSL_RAW_DATA, $iv));
        echo &#39;encrypted with key &#39; . $key . &#39; is &#39; . $encrypted . &#39;&lt;br&gt;&#39;. PHP_EOL;
        // truncated key = first 16 characters as for aes-128-cbc
        $key = &quot;1234567890123456&quot;;
        var_dump($key);
        $encrypted = base64_encode(openssl_encrypt($plaintext, $method, $key, OPENSSL_RAW_DATA, $iv));
        echo &#39;encrypted with key &#39; . $key . &#39; is &#39; . $encrypted . &#39;&lt;br&gt;&#39;. PHP_EOL;
    ?&gt;

Result:

    string(64) &quot;1234567890123456789012345678901234567890123456789012345678901234&quot;
    encrypted with key 1234567890123456789012345678901234567890123456789012345678901234 is iLaK2e4sWLOb0KfGy7ZRsQ==&lt;br&gt;
    string(16) &quot;1234567890123456&quot;
    encrypted with key 1234567890123456                                                 is iLaK2e4sWLOb0KfGy7ZRsQ==&lt;br&gt;


",1,62564115
5731,https://stackoverflow.com/a/62555524,Importing sting arrays to integer from csv to Neo4j using Cypher,true,"that would probably something like 

```
placeID : REDUCE(array=[] , s IN split(row.placeID,&quot;;&quot;) | array+[toInteger(s)] )

```
to get an array of integers

example 
```
with &#39;123;456&#39; as placeID
return REDUCE(array=[] , s IN split(placeID,&quot;;&quot;) | array+[toInteger(s)] )
```

will return 
```
[123,456]
```

and even shorter :)

```
with &#39;123;456&#39; as placeID
return [s IN split(placeID,&quot;;&quot;) | toInteger(s)]
```
",1,62555524
5732,https://stackoverflow.com/a/62556774,Neo4j: add properties to a relation on match and on create,false,"Merge is used when you want to create if the relationship doesn&#39;t exists, and refresh it otherwise.
So, `ON MERGE SET` would be enough.

So,

    CALL apoc.load.json(&quot;path/to/my/JSON&quot;) yield value 
        WITH value.`Request`.timestamp AS request
        MATCH(a:foo), (c:bar)
        WHERE a.id = c.id
        MERGE(a)-[b:has_relation]-&gt;(c)
        ON MATCH SET 
            b.timestamp = request.timestamp
            
should works",0,62556774
5733,https://stackoverflow.com/a/62566150,Neo4j: add properties to a relation on match and on create,true," 1. The `request` value is probably already the desired timestamp string.

    Here is one solution. Change this:

        WITH value.`Request`.timestamp AS request

    to this:

        WITH value.Request AS request

 2. It would also be clearer to change this:

        ON CREATE SET 
          b += {
            creation_batch_timestamp:trim(request.timestamp)
            }
        ON MATCH SET 
          b += {
            update_batch_timestamp:trim(request.timestamp)
            }

    to this:

        ON CREATE SET b.creation_batch_timestamp = trim(request.timestamp)
        ON MATCH  SET b.update_batch_timestamp = trim(request.timestamp)
",2,62566150
5734,https://stackoverflow.com/a/62545578,Neo4j - Where not exists,true,"Since your first query&#39;s outer `MATCH` clause binds the `p` and `t` values, the inner `MATCH` clause cannot find anything other than the same `p` and `t` values. In other words, this simpler query is logically equivalent:

    MATCH (c:company)-[:sells]-&gt;(p:product)&lt;-[:taxes]-(t:tax)
    WHERE t.name &lt;&gt; &#39;tax2&#39;
    RETURN c,p

So, your first query will return a product every time it is taxed by something other than &quot;tax2&quot;.

Your second query uses an unbound variable, `t2`, in its inner `MATCH` clause. Therefore, its [existential subquery](https://neo4j.com/docs/cypher-manual/current/clauses/where/#existential-subqueries) is able to evaluate *all* taxes for each product (not just `t`) before allowing the outer `MATCH` to succeed.",2,62545578
5735,https://stackoverflow.com/a/62543406,Combine two cypher queries,true,"Assuming the two id lists are always the *same size* (in your example, 2), here is one approach (assuming you also want the id values sorted in ascending order):

    MATCH (n:Org)
    WHERE n.id in [1, 2]
    WITH n ORDER BY n.id
    WITH COLLECT(n) AS ns
    MATCH (m:Org)
    WHERE m.id in [5, 9]
    WITH ns, m ORDER BY m.id
    WITH ns, COLLECT(m) AS ms
    UNWIND [i IN RANGE(0, SIZE(ns)-1) | {a: ns[i], b: ms[i]}] AS row
    RETURN
      row.a.id as group1_id, row.a.name as group1_name,
      row.b.id as group2_id, row.b.name as group2_name

And here is a simpler approach:

    WITH [1, 2] AS xs, [5, 9] AS ys
    UNWIND RANGE(0, SIZE(xs)-1) AS i
    MATCH (n:Org), (m:Org)
    WHERE n.id = xs[i] AND m.id = ys[i]
    RETURN n.id as group1_id, n.name as group1_name, m.id as group2_id, m.name as group2_name

And finally, if the `xs` and `ys` lists are passed to the query as [parameters](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/):

    UNWIND RANGE(0, SIZE($xs)-1) AS i
    MATCH (n:Org), (m:Org)
    WHERE n.id = $xs[i].id AND m.id = $ys[i].y
    RETURN n.id as group1_id, n.name as group1_name, m.id as group2_id, m.name as group2_name",1,62543406
5736,https://stackoverflow.com/a/62515168,How to include failed matches values in cypher,false,"I have found the issue, `collect` and `count` ignore null values. To solve it I used the COALESCE function to set null to 0.

    MATCH (p:Population) match (a:Allele)
    with a, p
    OPTIONAL MATCH (a)-[s:has_support]-&gt;(p)
    return a, collect(COALESCE(s.value, 0)), collect(p.name) limit 25",1,62515168
5737,https://stackoverflow.com/a/62507609,creating map/object parameter in cypher,true,"In Neo4j Desktop 1.2.9 with Neo4j 4.0.4 it works [![enter image description here][1]][1]

But in other versions, you may try

````
:param props: {status:&quot;closed&quot;}
````
or

````
:param props: {&quot;status&quot;:&quot;closed&quot;}
````
the latter being the equivalent of what is said in the manual you refer to.

  [1]: https://i.stack.imgur.com/FNxnl.png",2,62507609
5738,https://stackoverflow.com/a/62545462,Neo4j cypher. setting reverse relationship between nodes,false,"What you are asking about appears to be a bad idea.

Enforcing a pattern where a relationship of some given type is *always* paired with another relationship of some given type in the opposite direction (and vice versa) is **bad practice**. This is because, with neo4j, following a relationship in either direction *is equally easy and efficient*. It is wasteful to create relationships when not necessary.

Sample **anti-patterns**:

    (a)-[:HAS_ROOMMATE]-&gt;(b)-[:HAS_ROOMMATE]-&gt;(a)

and also:

    (a)-[:HAS_HUSBAND]-&gt;(b)-[:HAS_WIFE]-&gt;(a)

*On the other hand, if one cannot assume that a relationship in one direction must imply some relationship in the opposite direction, then it may be OK to have relationships in opposite directions (but you should also consider the alternative of adding an appropriate flag property to a single relationship).*

By the way, when querying for a relationship, you can specify a non-directional pattern. For example, to find a `Person`&#39;s roommate(s) you can do this (notice that the relationship pattern does not specify an arrowhead in either direction:

    MATCH (p:Person {id: 123})-[:HAS_ROOMMATE]-(q)
    RETURN p, q",0,62545462
5739,https://stackoverflow.com/a/64073323,Neo4j PHP Graphaware &#39;415 Unsupported Media Type &#39;,false,"I see the same problem :(

I debugged it into HttpDriver/Session.php flush function and I think headers are set up incorrectly:

```
public function flush(Pipeline $pipeline)
    {
        $request = $this-&gt;prepareRequest($pipeline);
        try {
            $response = $this-&gt;httpClient-&gt;sendRequest($request);

value of request
[headers:GuzzleHttp\Psr7\Request:private] =&gt; Array
        (
            [Host] =&gt; Array
                (
                    [0] =&gt; localhost:7474
                )

            [0] =&gt; Array
                (
                    [X-Stream] =&gt; 1
                    [Content-Type] =&gt; application/json
                )

        )
```

Pretty sure the request should be like this:
```
Array
        (
            [Host] =&gt; Array
                (
                    [0] =&gt; localhost:7474
                )
            [X-Stream] =&gt; 1
            [Content-Type] =&gt; application/json
        )

```

To fix this I modified PrepareRequst function to generate correct headers
```
// Line 197
$headers = [
  &#39;X-Stream&#39; =&gt; true,
  &#39;Content-Type&#39; =&gt; &#39;application/json&#39;
];
```",1,64073323
5740,https://stackoverflow.com/a/62482084,How can I find and remove nodes for which two of a given relationship exist?,false,"You might be able to delete extra attachments via the following code

    MATCH (b:Body)-[r:has]-&gt;(h:Heart)
    WITH b, h
    ORDER BY id(b)   // you can order it by something else if you have a better created date identifier
    WITH collect(b) as bodies, h   // collect turns nodes into a list
    WHERE size(bodies) &gt; 1   // size is how large the list is
    WITH tail(bodies) as bodies, h   // tail grabs all elements except first
    UNWIND bodies as b   // turns them back into individual nodes
    WITH b, h
    MATCH (b)-[r:has]-&gt;(h)
    DELETE r;

This works on a small setup I made, but I&#39;m not too good to confirm that it works, or if there&#39;s a more succinct version of this.",1,62482084
5741,https://stackoverflow.com/a/62484526,How can I find and remove nodes for which two of a given relationship exist?,true,"The statement below deletes all relationships except for one. You&#39;ll have to add logic to determine which is the one that you want to keep though  :)

    MATCH (:Body)-[r:has]-&gt;(h:Heart)
    WITH h,COLLECT(r) AS rs
    WHERE SIZE(rs)&gt; 1
    FOREACH (r IN rs[1..] |
        DELETE r
    )",2,62484526
5742,https://stackoverflow.com/a/62477663,&quot;with&quot; keyword changes the results,false,"You should read the documentation on how [aggregating functions](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) like `COLLECT` work, especially the information on &quot;grouping keys&quot;.

All `WITH` or `RETURN` clause terms that do NOT use aggregating functions are used as &quot;grouping keys&quot;, which control what data should be aggregated together.

Query 1 has 2 grouping keys (`n` and `n2`), but Query 2 only has 1 (`n`). So, you would generally expect the resulting aggregations to be different.",1,62477663
5743,https://stackoverflow.com/a/62491737,&quot;with&quot; keyword changes the results,false,"Your Query 1 reduces for each n only the paths that lead to a specific n2

Your Query 2 reduces for each n all paths that lead to any node

Hence, the number of paths, and thus of items in the collect(r) of Query 2 is greater than for Query 1

Assuming that the amounts are  &gt; 0, Query 2 has a higher count of results for which the WHERE clause returns true.

In fact, it&#39;s not the WITH keyword that changes the results, but it&#39;s the list of variables / placeholders that you provide.",1,62491737
5744,https://stackoverflow.com/a/62460980,Cypher executed from Stored Procedure much slower than raw cypher,false,"You missed one place where the `$graphId` parameter should be used. That is why the Cypher code is being &quot;recompiled&quot; every time.

Try replacing this snippet:

    (vb:Word {graphId: &#39;&quot; + graphId +&quot;&#39;})

with this:

    (vb:Word {graphId: $graphId})
    ",0,62460980
5745,https://stackoverflow.com/a/62455335,Neo4j query improvization,true,"This may work for you:

    MATCH p=(s:Server)-[:AFFINITY*..4]-(:Server)
    WHERE
      s.name = &#39;XYZ&#39; AND
      ALL(i IN RANGE(0, LENGTH(p)-1) WHERE
        NONE(j IN RANGE(i+1, LENGTH(p)) WHERE NODES(p)[i] = NODES(p)[j]))
    RETURN NODES(p) 

Also, if it is valid to make the `-[:AFFINITY*..4]-` relationship pattern directional (by putting an arrow on one end), then the query should be even faster.

[UPDATE]

Based on your comments, I will assume below that the relationship pattern is changed to be directional and to use a reduced upper bound of 3. To get a result closer to your original results:

    MATCH p=(s1:Server)-[:AFFINITY*..3]-&gt;(s2:Server)
    WHERE
      s1.name = &#39;XYZ&#39; AND
      (LENGTH(p) = 3 OR NOT (s2)-[:AFFINITY]-&gt;(:Server)) AND
      ALL(i IN RANGE(0, LENGTH(p)-1) WHERE
        NONE(j IN RANGE(i+1, LENGTH(p)) WHERE NODES(p)[i] = NODES(p)[j]))
    RETURN NODES(p) 

This query returns results for the longest paths that do not exceed the bound.",0,62455335
5746,https://stackoverflow.com/a/62459096,How to get all the indexes created on a label using cypher query in redisgraph,true,"at the moment the procedure is not implemented, as such you can&#39;t query which indices already exists, but there&#39;s no harm in trying to create an already existing index. Please feel free to open an issue on our github repository asking for this capability.",3,62459096
5747,https://stackoverflow.com/a/62455687,Compute Avg of list value for each element in Neo4j,true,"Assuming that you pass the list of &quot;sublists&quot; as a [parameter](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/), `list`, this may work for you:

    RETURN [w IN
      REDUCE(s = [], sublist IN $list | CASE
        WHEN SIZE(s) = 0 THEN sublist
        ELSE [i IN RANGE(0, SIZE(s)-1) | s[i] + sublist[i]]
        END) |
      w / TOFLOAT(SIZE($list))] AS result

`REDUCE` is used to generate a single list with the sums of the corresponding sublist elements.",0,62455687
5748,https://stackoverflow.com/a/62439794,My match/merge process is not creating relationships in the Neo4J database,true,"Your second query&#39;s `LOAD CSV` clause does not specify `FIELDTERMINATOR &#39;\t&#39;`. The default terminator is a comma (&#39;,&#39;). That is probably why it fails to `MATCH` anything.

Try adding `FIELDTERMINATOR &#39;\t&#39;` at the end of that clause.",1,62439794
5749,https://stackoverflow.com/a/62437917,Totalize and Relationships in depth,false,"Since `[r2*2]` specifies a [variable length relationship](https://neo4j.com/docs/developer-manual/3.4/cypher/clauses/match/#varlength-rels) pattern, `r2` is a *list* of relationships.

Here is one way to get what it *seems* you want:

    MATCH (p:Person{id:123})-[r]-&gt;(m), path=(m)-[*2]-&gt;(m2)
    RETURN p,count(distinct(r.idSale)) as qtd,sum(r.value) as value,type(r),m,
      SIZE(apoc.coll.toSet([r2 IN RELATIONSHIPS(path) | r2.idSale])) AS qtd2,
      REDUCE(s = 0, r2 IN RELATIONSHIPS(path) | s + r2.value) AS total2,
      [r2 IN RELATIONSHIPS(path) | TYPE(r2)] AS types2,
      m2

This query uses the APOC function [apoc.coll.toSet](https://neo4j.com/docs/labs/apoc/current/data-structures/collection-list-functions/) to get a distinct list. Also, it returns a list of relationship types in `types2`.",0,62437917
5750,https://stackoverflow.com/a/62436543,Variable in neo4j query,true,"You can pass [parameters](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/) to a Cypher query. For example, if `id` is passed in as a parameter:

    :param id =&gt; 1
    RETURN $id

[UPDATE]

If a parameter (say, `propName`) specifies a property *name*, then you can use the `n[$propName]` syntax to *get* the specified property from `n`. But to *set* the property value you could use APOC procedures like [apoc.create.setProperty](https://neo4j.com/docs/labs/apoc/current/graph-updates/data-creation/). ",2,62436543
5751,https://stackoverflow.com/a/62514965,Example script provided by neo4j for JavaScript won&#39;t run,false,"first of all, I think your URL should be  `&quot;url&quot;: &quot;bolt://localhost:7687&quot;`
And you still with `await driver.close()` outside an async function

If you are starting to use neo4j, look for an OGM (Object Graph Model) to help you.
",0,62514965
5752,https://stackoverflow.com/a/62925193,Example script provided by neo4j for JavaScript won&#39;t run,false,"I also had some problems with this. 

First off, Natam Oliveira is correct. You need to use the `bolt` protocol, and await promises needs to be within an `async` function. For some reason the `neo4j` protocol is used in some examples in the docs. Additionally it would seem both examples currently provided by Neo4j—in the driver-manual and javascript-driver section—causes errors if you use them outside of some kind of unspecified environment. 

There were some clues on the npmjs pagckage page, though, so by working them into the existing code, I was at least able to spit out some data. However I&#39;m also wondering on how you could make this work inside the `async` function, so an explanation to how that could work with this driver would be very welcome.

Here&#39;s what worked for me:

    const neo4j = require(&#39;neo4j-driver&#39;)
    
    const cnx = {
    	user: &#39;neo4j&#39;,
    	password: &#39;some passphrase&#39;,
    	uri: &#39;bolt://localhost:7687&#39;
    }
    
    const driver = neo4j.driver(cnx.uri, neo4j.auth.basic(cnx.user, cnx.password))
    
    driver.verifyConnectivity()
    	.then((cnxMsg) =&gt; {
    		console.log(cnxMsg)
    	})
    
    const session = driver.session({ database: &#39;neo4j&#39; })
    
    session.run(&#39;MATCH (n:Movie) RETURN n LIMIT 5&#39;)
    	.subscribe({
    		onKeys: keys =&gt; {
    			console.log(keys)
    		},
    		onNext: record =&gt; {
    			console.log(record.get(&#39;n&#39;).properties.title)
    		},
    		onCompleted: () =&gt; {
    			session.close()
    		},
    		onError: error =&gt; {
    			console.error(error) 
    		}
    	})

This spits out some movies using the *streaming API* as seen in the NPM documentation. (Note: It will only work if you started/installed the Movie database, so double check that you didn&#39;t delete it, as its deletion is also part of the Neo4j tutorial.) Now just change the `MATCH` Cypher query to whatever you like, and play around with the output, for instance by piping it to Express.

Sources:

* https://neo4j.com/docs/driver-manual/current/client-applications/
* https://neo4j.com/developer/javascript/#javascript-driver
* https://www.npmjs.com/package/neo4j-driver
* https://neo4j.com/docs/api/javascript-driver/current/",1,62925193
5753,https://stackoverflow.com/a/62424272,How to skip an unwound list,true,"This was mainly a misunderstanding on my part. If you want to filter before bunching them together, then perform the `COLLECT` at a later stage.

Working code:

    MATCH (n:Mob)
    WITH COUNT(n) as total, n as node
    WITH total, node
    WHERE node.order &gt; 1000
    WITH total, node
    SKIP 10
    LIMIT 5
    WITH collect(node) as nodes, total
    RETURN nodes, total",0,62424272
5754,https://stackoverflow.com/a/62421807,Swapping elements in a list based on their match in a dictionary,false,"Using [str.translate()](https://docs.python.org/2/library/string.html#string.translate)
```
def substitutor(text,theDict):
    d = {ord(v): k for k, v in theDict.items()}
    return text.translate(d)
```",0,62421807
5755,https://stackoverflow.com/a/62421838,Swapping elements in a list based on their match in a dictionary,false,"Invert the dictionary, then use that to translate the elements of `text`.

```
def substitutor(text, theDict):
    rev_dict = {v: k for k, v in theDict.items()}
    return &#39;&#39;.join(rev_dict.get(c, &#39;&#39;) for c in text)
```
",1,62421838
5756,https://stackoverflow.com/a/62421880,Swapping elements in a list based on their match in a dictionary,false,"Your Code Is Incorrect, In First Place You Shouldn&#39;t Be Defining Iliteration Index (n here) With Something Else, **What You Can Do Is To Get Each Element Of String And Use It As Key To Dictionary To Get It&#39;s Encrypted Character!! **

For sample I put a one liner code for you, it will work accordingly your problem!!

    def substitutor(text,theDict):
        encrypted_text = &#39;&#39;.join([ theDict.get(n) for n in list(text) if theDict.haskey(n) ])
        return encrypted_text",0,62421880
5757,https://stackoverflow.com/a/62420911,Filter nodes after receiving total number,true,"You need to have a `WITH` clause between the `UNWIND` and `MATCH` clauses. This should work:

    MATCH (n:Mob)
    WITH COUNT(n) as total, COLLECT(n) as nodes
    UNWIND nodes as node
    WITH total, node
    WHERE 8000 &lt; node.order &lt; 8100
    RETURN total, node

However, this is simpler if you are OK with getting a *single list* of suitable nodes instead of multiple return records:

    MATCH (n:Mob)
    RETURN
      COUNT(n) AS total,
      [m IN COLLECT(n) WHERE 8000 &lt; m.order &lt; 8100] AS nodes, COUNT(n) AS total

[UPDATE]

If you also want to do the equivalent of `SKIP` and `LIMIT` (assuming the SKIP and LIMIT counts are passed as [parameters](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/) `skip` and `limit`):

    MATCH (n:Mob)
    RETURN
      COUNT(n) AS total,
      [m IN COLLECT(n) WHERE 8000 &lt; m.order &lt; 8100][$skip..($skip+$limit)] AS nodes
",1,62420911
5758,https://stackoverflow.com/a/62423236,Filter nodes after receiving total number,false,"Adding to cybersam&#39;s answer. In order to SKIP/LIMIT a list you need to do [x..y] where x and y are numbers i.e.

    MATCH (n:Mob)
    RETURN [m IN COLLECT(n) WHERE 8000 &lt; m.order &lt; 8100][0..10] AS nodes, COUNT(n) AS total

Or

    MATCH (n:Mob)
    WITH COUNT(n) as total, COLLECT(n) as nodes
    UNWIND nodes as node
    WITH total, node
    WHERE node.order &gt; 1000
    WITH total, node
    SKIP 10
    LIMIT 5
    WITH collect(node) as nodes, total
    RETURN nodes, total",0,62423236
5759,https://stackoverflow.com/a/62418509,Finding right path in Cypher Neo4j,false,"[UPDATED]

This query should check that:

- matched paths have alternating `ORIGIN/DESTINATION` relationships, and
- every departing flight lands at least 30 minutes before the next departing flight (if any), and
- the sum of the ticket prices of the `Flight` nodes (which are every other node starting at the second one) &lt; 3000
```
MATCH p = (origin:Airport {name: &#39;LAX&#39;})-[:ORIGIN|DESTINATION*..5]-(destination:Airport)
WHERE
  ALL(i IN RANGE(0, LENGTH(p)-1) WHERE
    TYPE(RELATIONSHIPS(p)[i]) = [&#39;ORIGIN&#39;, &#39;DESTINATION&#39;][i] AND
    (i%4 &lt;&gt; 1 OR (i + 2) &gt; LENGTH(p) OR
      (apoc.date.parse(NODES(p)[i].date,&#39;m&#39;,&#39;MM/dd/yyyy hh:mm:ss&#39;) + NODES(p)[i].duration + 30) &lt; apoc.date.parse(NODES(p)[i+2].date,&#39;m&#39;,&#39;MM/dd/yyyy hh:mm:ss&#39;))
  ) AND
  REDUCE(s = 0, n IN [k IN RANGE(1, LENGTH(p), 2) | NODES(p)[k]] |
    s + [(n)&lt;-[:ASSIGN]-(ticket) | ticket.price][0]
  ) &lt; 3000
RETURN p
```

The query uses the [apoc.date.parse](https://neo4j.com/docs/labs/apoc/current/temporal/datetime-conversions/#datetime-available-procedures-apoc.date.parse) function to convert each `date` into the number of epoch minutes, so that a `duration` (assumed to also be in minutes) can be added to it.",0,62418509
5760,https://stackoverflow.com/a/62413793,"Cypher: Indexing returnInvalid input &#39;i&#39;: expected whitespace comment, ON, &#39;=&#39;, node labels",true,"The [syntax](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/#administration-indexes-syntax) you are using was added to neo4j 4.x. It is not supported in older versions of neo4j.

In older versions that support composite indexes, like neo4j 3.5, the [syntax](https://neo4j.com/docs/cypher-manual/3.5/schema/index/#schema-index-create-a-composite-index) for creating your index would be:

    CREATE INDEX ON :User(id, username, email)
 
*Note: This older syntax is currently still supported in version 4.0.4, but deprecated.*",1,62413793
5761,https://stackoverflow.com/a/62413367,issue in Cypher query with exclusion,false,"By not working I assume you mean doesn&#39;t return any results... It looks like your article has no relationships with other articles that don&#39;t have this exact type of article. If you want to find articles that don&#39;t have a relationship to a specific article type, you can try:

    MATCH (n:Article {TypeArticle: &#39;PF&#39;, ArticleStatut:&#39;20&#39; , ETB:&#39;CLM&#39;})
    WHERE NOT (n)--&gt;(:Article{TypeArticle:&quot;CA&quot;})
    return n",0,62413367
5762,https://stackoverflow.com/a/62403919,neo4j: Setting apoc.create.uuid() on the outside causes replacement,true,"You can move set UUID inside `ON CREATE SET` so it would only add UUID when the node is created and ignore it when node is updated.


    UNWIND $data as data
    MERGE (d:Device {cell_id: data.cell_id})
    ON CREATE SET 
    	d+= data,
    	d._uuid = apoc.create.uuid()
    WITH d
    MERGE (g:Device_Group {group_name: $GROUP_NAME})
    WITH g,d
    MERGE (g)-[:GROUPS]-&gt;(d)

 ",1,62403919
5763,https://stackoverflow.com/a/62391361,Optimise Neo4j Query,true,"You can improve this query in the following ways: 

 **Create an Index on the name property of DeploymentUnit Label which is used for matching**

    CREATE INDEX FOR (n:DeploymentUnit) ON (n.name)

 **Avoiding the cartesian product in the query using WITH**

    MATCH (m:Server)-[r]-(n:Middleware)-[r1]-(o:OperatingSystem)
    WITH n.name+m.name as du_name, o
    MATCH (y:DeploymentUnit{name: du_name}) 
    MERGE (y)-[:STRATEGIC_RUNS_ON]-&gt;(o) 
    MERGE (y)&lt;-[:STRATEGIC_OUT_RUNS_ON]-(o)
",0,62391361
5764,https://stackoverflow.com/a/62392958,neo4j: If statement for deleting nodes based on relationships,true,"You can probably do this without the APOC library and just use the `OPTIONAL MATCH` clause.

    UNWIND [{name:&#39;John&#39;}] as rows
    // Match the person
    MATCH (u:Person)
    WHERE u.user_name = rows.name
    // Check if she/he owns any car
    OPTIONAL MATCH (u)-[:OWNS]-&gt;(c:Car)
    // Delete them all
    DETACH DELETE u,c

I&#39;ve checked and cypher has no problem if sometimes there will be null as variable `c`.

You can check this by doing:

    DETACH DELETE null

It doesn&#39;t return any error, so I think it should work fine.",0,62392958
5765,https://stackoverflow.com/a/62392987,neo4j: If statement for deleting nodes based on relationships,false,"This query using [pattern comprehension](https://neo4j.com/docs/cypher-manual/current/syntax/lists/#cypher-pattern-comprehension) should work:

    UNWIND [{name:&#39;John&#39;}] as rows
    MATCH (u:Person)
    WHERE u.user_name = rows.name
    FOREACH(x IN [(u)-[:OWNS]-&gt;(c:Car)|c] | DETACH DELETE x)
    DETACH DELETE u
",0,62392987
5766,https://stackoverflow.com/a/62384621,How to remove/delete duplicate nodes from RedisGraph,true,"To delete duplicates you can use the following

```
MATCH (p:Person)
WITH p.id as id, collect(p) AS nodes 
WHERE size(nodes) &gt;  1
UNWIND nodes[1..] AS node
DELETE node
```
",3,62384621
5767,https://stackoverflow.com/a/62393798,How to add a given label to given node by using spring data neo4j?,false,"At the moment, cypher does not support assigning dynamic node labels. You will need to use the APOC library:

    MATCH (st) WHERE st.originId = $originId
    CALL apoc.create.addLabels( [st], [$label​]) YIELD node
    RETURN distinct &#39;done&#39;",0,62393798
5768,https://stackoverflow.com/a/62380714,group by function in neo4j?,false,"You’re using `ISBN` property of `PURCHASED` relationship  so it will only show when the book is purchased by at least one customer. You should change it to use `Book`&#39;s `ISBN` property:

    MATCH(b:Book)
    OPTIONAL MATCH (cu:Customer)-[pu:PURCHASED]-&gt;(:Order)-[]-&gt;(b)
    RETURN b.ISBN, SUM(pu.qty) AS quantity ",0,62380714
5769,https://stackoverflow.com/a/62367486,"Neo.ClientError.Statement.SyntaxError: Invalid input &#39;l&#39;: expected &#39;r/R&#39; or &#39;o/O&#39; (line 1, column 20 (offset: 19))",true,"Looks like you are using older version of Neo4j. The guide you are referring is for latest Neo4j version.
Constraint names are not supported in older versions hence it is throwing error.
 
**You can modify your query as bellow:**

    CREATE CONSTRAINT ON (f:Flight) ASSERT f.flightId IS UNIQUE

",0,62367486
5770,https://stackoverflow.com/a/62395113,Neo4J set new property on Relationship by Relationship ID,false,"You should NEVER do this:

    merge ()-[r:rel {id:row.sysID}]-&gt;()

If the relationship does not already exist, that clause would create a new relationship *between 2 brand new nodes having no labels or properties* (and your `on match` clause would also not be applied).

Since your question indicates you just want to update the `SysML` property of existing `rel` relationships, you should use `MATCH` instead of `MERGE`:

    LOAD CSV WITH HEADERS FROM &quot;file:///SysML.csv&quot; AS row 
    MATCH ()-[r:rel {id: row.sysID}]-&gt;() 
    SET r.SysML = row.type

By the way, it would be more efficient if you qualified the end nodes (e.g., by supplying labels, or even property values) to avoid having to scan through every relationship in the DB. ",0,62395113
5771,https://stackoverflow.com/a/62334647,Cypher: Query to check if node is part of top 10 results,true,"This is one way:

    MATCH (org)
    WHERE org.revenueCurrency = &#39;USD&#39;
    WITH org
    ORDER by org.revenue DESC
    WITH COLLECT(org) AS orgs
    UNWIND [i IN RANGE(0, SIZE(orgs)-1) | {org: orgs[i], top10: i &lt; 10}] AS result
    RETURN result

The `top10` property of each `result` row will be a boolean.

[UPDATE]

If you want each result row to be &quot;flat&quot; instead of a map, use this altered `RETURN` clause:

    RETURN result.org AS org, result.top10 AS top10
",1,62334647
5772,https://stackoverflow.com/a/62329920,Find string that doesn&#39;t have prefix in Neo4j,true,"Try

    MATCH (n:Person) WHERE NOT n.name STARTS WITH &#39;Pet&#39; RETURN n",0,62329920
5773,https://stackoverflow.com/a/62331514,Neo4j Bloom is missing nodes for apoc.path.subgraphAll while Neo4j Desktop Browser works as expected,false,"It looks like Neo4j Bloom doesn&#39;t handle an array of nodes and an array of relationships as an input. Try the following query:

    MATCH (u:Undefined)
    CALL apoc.path.subgraphAll(u, {}) YIELD nodes, relationships
    UNWIND relationships as rel
    RETURN startNode(rel),rel,endNode(rel)

Not sure if it will work. You could also try and use an APOC procedure that returns paths like for example `apoc.path.expand`.
",0,62331514
5774,https://stackoverflow.com/a/62322863,Neo4j: Alternative Filter using list (General Approach),true,"You could try this as an approach:

    WITH keys({id:&#39;1002&#39;,name:&#39;Ford&#39;, type:&#39;4-wheel&#39;}) AS required
    MATCH (c:Car)
    WITH c, required, keys(c) AS toCheck, size(required) AS reqSize
    WITH c, reqSize, required + toCheck as matched
    UNWIND matched as matchedItems
    WITH c, reqSize, matchedItems, COUNT(matchedItems) AS counted WHERE counted &gt; 1
    RETURN CASE WHEN size(collect(counted)) = reqSize THEN c ELSE null END
Basically, the operation is to create a list of keys that you are looking for and add it to a list of the keys in the node you are checking. 

Next, group the key names by key name with a count, retaining only the duplicate key names, those with a count of two (the counts can only be one or two if the key names in the required list and the checked list are unique within the lists). 

FInally, if the count of duplicate key names matches the length of the list of required keys, the node contains all the required keys.

You can reduce a lot of the &#39;WITH&#39;ery in the above query. It&#39;s only there to show the logic behind the thinking.
",0,62322863
5775,https://stackoverflow.com/a/62315703,Cypher: Nested FOREACH build a &quot;real number tree&quot;. Problem is making deeper loops conditional so smaller numbers are higher precision,false,"You can use [indexing](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/) to quickly find nodes with a property value within a range. You should not create nodes for a limited set of values.

Using the engine example mentioned in your comment, let&#39;s say the data model is as follows (the unit for each property is fixed by you, and does not need to be stored):

    (:Engine {id: 123, bore: 85.75, stroke: 80, powerDensity: 77.789})

After you create [indexes](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/) on `:Engine(bore)`, `:Engine(stroke)`, `:Engine(powerDensity)`, you can efficiently perform queries involving any of the indexed properties (or all of them).

For example:

    PROFILE MATCH (e:Engine)
    WHERE (80 &lt;= e.bore &lt;= 95.2) AND e.stroke &lt; 85 and e.powerDensity &gt; 75
    RETURN e

When multiple indexed properties are used in the same `MATCH`, then only one of the indexes may be used (but the Cypher planner will try to pick the index that is most likely to get the fastest results).",0,62315703
5776,https://stackoverflow.com/a/62294339,How do I remove objects containing NULL from a COLLECT() clause in a CYPHER query?,true,"[UPDATED]

A really nice thing about your particular data model is: you can get all the `myFriends` and `theirFriends` elements with a single *undirected* relationship pattern: `(user)-[:HAS_FRIEND]-(f)`.

For example:

    MATCH (user:User)
    WHERE user.id IN [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]
    OPTIONAL MATCH (user)-[:HAS_FRIEND]-(f:User)
    OPTIONAL MATCH (user)-[:HAS_TEACHER]-&gt;(t:User)
    RETURN {
      name: user.name,
      friends: COLLECT(DISTINCT f{.id}),
      teachers: COLLECT(t{.id})
    }

So, no list concatenation is needed. Also, the `DISTINCT` option removes duplicate `friends` elements.

*By the way, this query also uses the neat [map projections](https://neo4j.com/docs/cypher-manual/current/syntax/maps/#cypher-map-projection-examples) syntax as suggested by @P.S., which avoids `null` values.*
",0,62294339
5777,https://stackoverflow.com/a/62294707,How do I remove objects containing NULL from a COLLECT() clause in a CYPHER query?,false,"An elegant solution using [map projections][1] and keeping the `OPTIONAL MATCH` clause.

```
MATCH (user:User)
WHERE user.id IN [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]
OPTIONAL MATCH (user)-[:HAS_FRIEND]-&gt;(myFriends:User)
OPTIONAL MATCH (user)&lt;-[:HAS_FRIEND]-(theirFriends:User)
OPTIONAL MATCH (user)-[:HAS_TEACHER]-&gt;(myTeachers:User)
RETURN {
  name: user.name,
  friends: collect(myFriends {.id}) + collect(theirFriends {.id}),
  teachers: collect(myTeachers {.id})
}
```


  [1]: https://neo4j.com/docs/cypher-manual/current/syntax/maps/#cypher-map-projection-examples",0,62294707
5778,https://stackoverflow.com/a/62291639,In Neo4j how can I create relationships between one node an a collection of other nodes?,false,"A `MATCH` clause generates one or more result rows (or aborts the query if no results are found). A subsequent read/write clause would be executed once *per row*. Rearranging the order of the clauses, as you did, is one way to work around that (when possible).",0,62291639
5779,https://stackoverflow.com/a/62287607,Neo4j: Matching nodes in FOREACH,true,"Unfortunately you cannot use `MATCH` statement in a `FOREACH` clause, you can use the `MERGE` though. If that would work for you it is ok, otherwise you could use a second `UNWIND` statement. Btw.. how come you are using both `UNWIND` and `FOREACH`? Do you have a double nested data structure?",0,62287607
5780,https://stackoverflow.com/a/62287741,Cypher match path with intermediate nodes,false,"If you want to calculate the weighted shortest path, then it is the easiest to use GDS or even APOC plugin. You could probably create a shortest weighted path function with cypher but it would be not optimized. I can only think of finding all paths between the two nodes and suming the weights. In the next step you would filter the path with the minimum sum of weight. This would not scale well though.

As for the second part of your question I would need more information as I dont know exactly what you want.",0,62287741
5781,https://stackoverflow.com/a/62289950,Cypher match path with intermediate nodes,true,"This should get all usable paths (without plugins):

    WITH [&#39;BEGINS_AT&#39;, &#39;ENDS_AT&#39;] AS types
    MATCH p=(a:Stop)-[:BEGINS_AT|ENDS_AT*]-(b:Stop)
    WHERE a.name = &#39;A&#39; AND b.name = &#39;B&#39; AND
      ALL(i IN RANGE(0, LENGTH(p)-1) WHERE TYPE(RELATIONSHIPS(p)[i]) = types[i%2])
    RETURN p

To get the shortest path:

    WITH [&#39;BEGINS_AT&#39;, &#39;ENDS_AT&#39;] AS types
    MATCH p=(a:Stop)-[:BEGINS_AT|ENDS_AT*]-(b:Stop)
    WHERE a.name = &#39;A&#39; AND b.name = &#39;B&#39; AND
      ALL(i IN RANGE(0, LENGTH(p)-1) WHERE TYPE(RELATIONSHIPS(p)[i]) = types[i%2])
    RETURN p
    ORDER BY LENGTH(p)
    LIMIT 1;

or

    WITH [&#39;BEGINS_AT&#39;, &#39;ENDS_AT&#39;] AS types
    MATCH p=shortestpath((a:Stop)-[:BEGINS_AT|ENDS_AT*]-(b:Stop))
    WHERE a.name = &#39;A&#39; AND b.name = &#39;B&#39; AND
      ALL(i IN RANGE(0, LENGTH(p)-1) WHERE TYPE(RELATIONSHIPS(p)[i]) = types[i%2])
    RETURN p",1,62289950
5782,https://stackoverflow.com/a/62290335,Neo4j: Cypher for filtering based on list of properties,true,"This should work:

    UNWIND [{a_id:&#39;1001&#39;, c_id:&#39;1001&#39;}] as row
    MATCH (a:Assembly)-[:RECIPE]-&gt;(c:Component)
    WHERE
      (NOT EXISTS(row.a_id) OR row.a_id = a.id) AND
      (NOT EXISTS(row.c_id) OR row.c_id = a.id) AND
      (NOT EXISTS(row.c_name) OR row.c_name = c.name) AND
      (NOT EXISTS(row.c_manu) OR row.c_manu = c.manu)
    RETURN c

",0,62290335
5783,https://stackoverflow.com/a/62280085,Filter all nodes in returned path for criteria,false,"`FILTER` is the `FOREACH` of returns

```
MATCH path = (start)-[:EDGE*0..]-&gt;
             (end:END)
WHERE id(start) = {start_id}
RETURN DISTINCT filter( node in nodes(path) 
                        WHERE (node)-[:OTHER_EDGE*]-&gt;
                              ()-[:CERTAIN_EDGE]-&gt;() ),
       end
```",0,62280085
5784,https://stackoverflow.com/a/62272229,Cypher - Input to subquery without fabric?,true,"Your use case does not actually require subqueries. For example:

    MATCH (c:Category)&lt;-[:IN_CATEGORY]-(:Business)&lt;-[:REVIEWS]-(:Review)&lt;-[:WROTE]-(u:User)
    WHERE c.category_id IN [&#39;Hotels&#39;, &#39;Hostels&#39;]
    WITH c, u
    ORDER BY u.pageRank20 DESC
    WITH c.category_id AS cat_name, COLLECT(DISTINCT u)[..10] AS users
    UNWIND users AS user
    RETURN cat_name, user.name AS name, user.pageRank20 AS pageRank20
",0,62272229
5785,https://stackoverflow.com/a/62357071,Redis requests done in 1 to 3 ms taking 300ms,false,"I&#39;m not familiar with Julia but please note RedisGraph report its internal execution time, I&#39;ll suggest using this report for measurement,

In addition it would be helpful to understand when (on which sample) did RedisGraph took over 100ms to process the query, usually it is the first query which causes RedisGraph to do some extra work.",1,62357071
5786,https://stackoverflow.com/a/62258210,Neo4j: Get Min/Max of multiple node/relationship properties,true,"You need a scaler function for this, the `min()` and `max()` functions you get from Cypher are aggregation functions that work across rows, which isn&#39;t what you need here.

If you have [APOC Procedures](https://neo4j.com/docs/labs/apoc/current/overview/) installed you can make use of `apoc.coll.min()` and `apoc.coll.max()` which work across elements of a list:

```
MATCH (U:User)-[i:invests]-&gt;(P:Project)
RETURN U, apoc.coll.min([i.amount, P.availableAmount]) as minValue
```

If you don&#39;t have APOC or aren&#39;t allowed to use it, then you can use the CASE structure to find the minimum:

```
MATCH (U:User)-[i:invests]-&gt;(P:Project)
RETURN U, CASE WHEN i.amount &lt; P.availableAmount THEN i.amount ELSE P.availableAmount END as minValue
```",1,62258210
5787,https://stackoverflow.com/a/62253632,Cypher/Neo4j Query To Get Info Of Currect Node and Others Related With That,true,"Your MATCH indicates that the user MUST follow someone. If they don&#39;t they are filtered out. So if that pattern is not a requirement, use an [OPTIONAL MATCH][1] instead of a MATCH.


  [1]: https://neo4j.com/docs/cypher-manual/current/clauses/optional-match/",0,62253632
5788,https://stackoverflow.com/a/62243464,Join two matches in Neo4J,false,"You can simplify your query a lot. Cypher is quite cool and expressive :)

    MATCH (c:Critic)
    WHERE (c)-[:REVIEWS{Stars:4}]-&gt;() AND
    NOT (c)-[:REVIEWS{Stars:3}]-&gt;()
    RETURN c.name as critic_name

The way you have tried would also work, you have to change the query to:

    // Get all the critics who given a score 3
    MATCH (c:Critic)-[r:REVIEWS]-&gt;()
    WHERE r.Score = 3
    WITH collect(distinct c) as score_3_critics
    // get all critics who gave a score 4, but filter out
    // critics who gave it 3
    MATCH (c1:Critic)-[r1:REVIEWS]-&gt;()
    WHERE r1.Score = 4 AND NOT c1 in score_3_critics
    RETURN distinct c1.name as critic

I always preferred filtering out results as in the first example. When you have multiple ways of defining a query to get the same results, it is best to check the execution plan with the PROFILE statement to see which query is faster",1,62243464
5789,https://stackoverflow.com/a/62237281,Cypher - How to call a procedure multiple times in loop?,true,"You have to add a `RETURN` statement at the end of the query like the error states. Basically, if you only call a single procedure, then cypher won&#39;t bug you with this. But if you do any kind of `MATCH` before a procedure call, you have to end the query with `RETURN`. You could also just use `DETACH DELETE` cypher statement instead.

Version with DETACH DELETE:

    UNWIND [10, 20] AS age_num
    MATCH (n:User {name: &#39;a&#39;, age: age_num})
    DETACH DELETE n

Version with APOC:

    UNWIND [10, 20] AS age_num
    MATCH (n:User {name: &#39;a&#39;, age: age_num})
    CALL apoc.nodes.delete(n) YIELD value
    RETURN distinct &#39;done&#39;


Edit: I have fixed the output as per the OP comment

",0,62237281
5790,https://stackoverflow.com/a/62228363,Relations in Neo4j,false,"Neo4j as not a function that is call group. But you can aggregate your values like SQL 

    MATCH (n { name: &lt;group lable&gt; })-[r]-&gt;() RETURN type(r), count(*) 
for a single group.

     MATCH (n)-[r]-&gt;() RETURN type(r), count(*)
for all groups 
https://neo4j.com/docs/cypher-manual/current/functions/aggregating/
",0,62228363
5791,https://stackoverflow.com/a/62222248,Post-Calculations on Aggregations,true,"### Answer using [aggregating functions](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/)

    WITH &quot;Madrid&quot; AS loc1, &quot;Barcelona&quot; AS loc2
    MATCH (:RelevantTwitterUser{location:loc1})-[:FOLLOWS]-&gt;(:RelevantTwitterUser{location:loc2})
    WITH loc1, loc2, COUNT(*) AS count1
    MATCH (:RelevantTwitterUser{location:loc2})-[:FOLLOWS]-&gt;(:RelevantTwitterUser{location:loc1})
    WITH loc1, loc2, count1, COUNT(*) AS count2
    RETURN loc1, count1, loc2, count2, count1 - count2 AS diff

You should read the documentation on [aggregating functions](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) (like `COUNT`) if you want to understand how this query works, and to avoid getting the wrong counts if you need to modify this query. It is especially important to understand how `grouping keys` (e.g., `locs` and `count` in the last `WITH` clause) affect the behavior of aggregating functions.

### Answer using [SIZE() on pattern expressions](https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size-of-pattern-expression)

    WITH &quot;Madrid&quot; AS loc1, &quot;Barcelona&quot; AS loc2
    WITH loc1, loc2,
      SIZE((:RelevantTwitterUser{location:loc1})-[:FOLLOWS]-&gt;(:RelevantTwitterUser{location:loc2})) AS count1,
      SIZE((:RelevantTwitterUser{location:loc2})-[:FOLLOWS]-&gt;(:RelevantTwitterUser{location:loc1})) AS count2
    RETURN loc1, count1, loc2, count2, count1 - count2 AS diff

",1,62222248
5792,https://stackoverflow.com/a/62271306,neo4j find parent node is relationship exists,false,"[UPDATED]

This query should return the group-accessible `a` directory that is closest to the root, starting at a specific (sub)directory:

    MATCH p=(g:group)-[:CAN_ACCESS_DIR]-&gt;(d:directory)&lt;-[:CONTAINS*0..]-(a)
    WHERE g.name = &quot;group1&quot; AND d.name = &quot;JAVA2&quot;
    MATCH (a)&lt;-[:CAN_ACCESS_DIR]-(g)
    RETURN p, a
    ORDER BY LENGTH(p) DESC
    LIMIT 1

Since a single `MATCH` clause would filter out multiple uses of the same relationship, this query uses 2 `MATCH` clauses to allow the same `CAN_ACCESS_DIR` relationship to match twice, in case `d` is the only accessible directory (and therefore the same as `a`).",0,62271306
5793,https://stackoverflow.com/a/62206067,Neo4j query to return parent hierarchy,false,"The simplest way to solve your problem is probably to return the path object. We can use a variable-length path query to combine the nodes one hop away as well as the nodes two hops away.

    MATCH p=(c:Child-[r:has_parent*1..2]-&gt;(p:Parent) 
    RETURN p

If you have a bigger hierarchical graph then you maybe want to use a bigger path limit like 

    MATCH p=(c:Child-[r:has_parent*1..15]-&gt;(p:Parent) 
    RETURN p",0,62206067
5794,https://stackoverflow.com/a/62189917,Is there an ampersand (&amp;) analogue to the pipe (|)?,true,"I don&#39;t see any `with` statement?

There is no support for ampersand (&amp;) operator in relationship types. You showed one way that this could be achieved with `WHERE` statement.

    match (a)-[:X]-(b)
    where (a)-[:Y]-(b)
    return a, b

Another way is to use two `MATCH` statements

    match (a)-[:X]-(b)
    match (a)-[:Y]-(b)
    return a, b

I am sure there are other ways as well",1,62189917
5795,https://stackoverflow.com/a/62190854,Is there an ampersand (&amp;) analogue to the pipe (|)?,false,"Presumably you are returning a different (b) for [:X] and [:Y]. If so a query of this type may meet your need?

    match (a:Person{RN:1})-[r:father|mother]-&gt;(b:Person) 
    with a,collect(b.RN) as bc,collect(type(r)) as rels
    with a,bc,rels 
    return a.RN,bc,rels

You could unwind the b-collection if you want to get two rows.",0,62190854
5796,https://stackoverflow.com/a/62299168,Java client Cypher query with RedisGraph redis.clients.jedis.exceptions.JedisDataException: errMsg: Invalid input &#39;p&#39;: expected PROFILE line: 1,false,"Disclaimer: I&#39;m one of the RedisGraph engineers.

First, for the time being, we do not support maps as a native datatype in RedisGraph so, unfortunately, your query is currently not supported.

Second, Can you please share which version of RedisGraph are you using? I executed the following code over our latest docker image (`docker run -p 6379:6379 --rm redislabs/redisgraph:latest`)

```
    @Test
    public void testStackOverflowQuestion(){
        RedisGraph graph = new RedisGraph();
        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();
        props.put(&quot;id&quot;, 2);
        props.put(&quot;name&quot;, &quot;Jagadeesh&quot;);
        props.put(&quot;age&quot;, 23);
        graph.query(&quot;UserGraph&quot;, &quot;CREATE ($props)&quot;, props);
    }
```
and the response seems to be more appropriate for unsuppoted data types:
```
com.redislabs.redisgraph.exceptions.JRedisGraphCompileTimeException: redis.clients.jedis.exceptions.JedisDataException: Encountered unhandled type in inlined properties.
```

Edit after comment:

I modify the test to be
```java
    @Test
    public void testStackOverflowQuestion(){
        RedisGraph graph = new RedisGraph();
        Map&lt;String, Object&gt; personMap = new HashMap&lt;&gt;();
        personMap.put(&quot;id&quot;, 2);
        personMap.put(&quot;name&quot;, &quot;Jagadeesh&quot;);
        personMap.put(&quot;age&quot;, 23);
        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();
        props.put(&quot;props&quot;, personMap);
        graph.query(&quot;UserGraph&quot;, &quot;CREATE ($props)&quot;, props);
    }
```
I got the same response as you as you.
This is our parser error. Our parser expects map key-value pair to be seperated by colon `key:value` The error caused by wrong format of serialization of the map object in JRedisGraph which currently calls the map `toString()` method which serializes it as `key = value` so our parser skips the parameter parsing and treats the map as part of the actual query.

By applying `MONITOR` in redis-cli, your query yields the command:
`&quot;graph.QUERY&quot; &quot;UserGraph&quot; &quot;CYPHER props={name=Jagadeesh, id=2, age=23} CREATE ($props)&quot; &quot;--COMPACT&quot;`
As you can see, the map is sent in `key=value` format.
I manually changed the query and sent it in redis-cli with `key:value` format and got the expected response:
```
127.0.0.1:6379&gt; graph.query g &quot;CYPHER props={name:Jagadeesh, id:2, age:23} CREATE ($props)&quot;
(error) Encountered unhandled type in inlined properties.
```",2,62299168
5797,https://stackoverflow.com/a/62188013,Neo4j - Graph Data Science library - How to cypher-query against a named graph in Graph Catalog?,true,"There is currently no other way of querying the named graph other than the workaround you already found.

However, there are additional functions, e.g. [`gds.util.nodeProperty`][1] that allow you to access a node property in the named graph without writing it back to Neo4j. An example for querying a `score` property could look like this:

    CALL gds.graph.create(&#39;my-graph&#39;, &#39;User&#39;, &#39;LINK&#39;);
    CALL gds.pageRank.mutate(&#39;my-graph&#39;, { mutateProperty: &#39;score&#39; });
    MATCH (user:User)
    WHERE user.name = &#39;Alice&#39;
    RETURN
        user.name AS name,
        gds.util.nodeProperty(&#39;my-graph&#39;, id(user), &#39;score&#39;) AS score


  [1]: https://neo4j.com/docs/graph-data-science/current/management-ops/utility-functions/#utility-functions-catalog

Could you maybe elaborate why your projections are &quot;trial-and-error&quot; cycles. Maybe an option is to run your validation queries on the subgraph you want to project?",3,62188013
5798,https://stackoverflow.com/a/62183945,Efficient way to import multiple csv&#39;s in neo4j,true,"Your `MERGE` clause has to check for an existing matching relationship (to avoid creating duplicates). If you added *a lot* of relationships between `Person` nodes, that could make the `MERGE` clause slower.

You should consider whether it is safe for you to use `CREATE` instead of `MERGE`.",0,62183945
5799,https://stackoverflow.com/a/62222745,Efficient way to import multiple csv&#39;s in neo4j,false,"Is much better if you export the match using the ID of each node and then create the relationship.

POC

    CREATE INDEX ON :Person(`pid`);

	CALL apoc.export.csv.query(&quot;LOAD CSV WITH HEADERS FROM &#39;file:///calls/calls_28.csv&#39; AS line
    WITH toInteger(line.Source) AS Source, 
    datetime(replace(line.Time,&#39; &#39;,&#39;T&#39;)) AS time,
    toInteger(line.Target) AS Target,
    toInteger(line.Duration) AS Duration
    MATCH (p1:Person {pid: Source})
    MATCH (p2:Person {pid: Target})
    RETURN ID(a) AS ida,ID(b) as idb,time,Duration&quot;,&quot;rels.csv&quot;, {});


and then 

    USING PERIODIC COMMIT
    LOAD CSV WITH HEADERS FROM &#39;file:////rels.csv&#39; AS row
    MATCH (a:Person) WHERE ID(a) = toInt(row.ida)
    MATCH (b:Person) WHERE ID(b) = toInt(row.idb)
    MERGE (b)-[:CALLS {time: row.time, duration: Duration}]-&gt;(a);


For me this is the best way to do this.

",0,62222745
5800,https://stackoverflow.com/a/62180697,Neo4j db.schema.visualization gives additional recursive relationships,true,This non-existent relationship behavior is a known [neo4j issue](https://github.com/neo4j/neo4j/issues/9726) that has existed for awhile.,0,62180697
5801,https://stackoverflow.com/a/62162319,"How do you return created relationships using apoc.refactor.cloneNodes([nodes], true)?",true,"Your approach looks pretty reasonable.

However, (this is a minor side issue) the query would set the `id` of an `output` multiple times if it has multiple relationships. If you want to avoid the unnecessary overhead, you can replace this:

    ...
    MATCH (output)-[r]-()
    SET output.id = apoc.create.uuid(), r.id = apoc.create.uuid()
    ...

with this:

    ...
    SET output.id = apoc.create.uuid()
    WITH output
    MATCH (output)-[r]-()
    SET r.id = apoc.create.uuid()
    ...

[UPDATE]

In your updated query, you can avoid using the `DISTINCT` option in `collect (distinct output)` this way:

    MATCH (n) WHERE n.id in $ids
    WITH COLLECT(n) AS nodesToClone
    CALL apoc.refactor.cloneNodes(nodesToClone,true) YIELD output
    SET output.id = apoc.create.uuid()
    WITH COLLECT(output) AS nodes
    UNWIND nodes AS node
    MATCH (node)-[r]-()
    SET r.id = apoc.create.uuid()
    WITH COLLECT({source:startnode(r), edge:r, target:endnode(r) }) AS edges, nodes
    RETURN *

",0,62162319
5802,https://stackoverflow.com/a/62139908,Inserver distance calculation and Combining Neo4j queries,false,"[UPDATED]

Here is a combined query:

    WITH
      point({ longitude:76.91859, latitude:8.487992, height: 100 }) AS p1,
      point({ latitude:8.495548 , longitude:76.93015, height: 100 }) AS p2
    MATCH (q:QuarantinedPersons) 
    WHERE q.name = &#39;Raman&#39; 
    CREATE (thereturnrecord:theDetails{
      theid: q.id,
      thename: q.Name,
      thedetails: q.details,
      thelat: q.lat,
      thelong: q.long,
      thedistance: distance(p1, p2)
    }) 
    RETURN thereturnrecord

Of, if the arguments for the 2 `point`s are passed as the [parameters](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/) `p1` and `p2`:

    MATCH (q:QuarantinedPersons) 
    WHERE q.name = &#39;Raman&#39; 
    CREATE (thereturnrecord:theDetails{
      theid: q.id,
      thename: q.Name,
      thedetails: q.details,
      thelat: q.lat,
      thelong: q.long,
      thedistance: distance(point($p1), point($p2))
    }) 
    RETURN thereturnrecord

",0,62139908
5803,https://stackoverflow.com/a/62159517,neo4j look for users by radius,true,"Creating/deleting &quot;nearness&quot; relationships between _all_ `User`s is not practical, as you have seen, especially if you need to do that continuously. Generally speaking, relationships should be used when you expect relatively stable connections between nodes. It does not make sense to create/delete a lot relationships to keep track of the results of a continuously running process -- especially if you only care about the results for a handful of `User`s.

Instead, you should create a [spatial index](https://neo4j.com/docs/cypher-manual/current/syntax/spatial/#cypher-spatial-index) on `:User(location)`:

    CREATE INDEX user_distance FOR (u:User) ON (u.location)

That can speed up certain `distance` queries. For example, [PROFILE](https://neo4j.com/docs/developer-manual/3.4/cypher/query-tuning/how-do-i-profile-a-query/) shows that the following query would use that spatial index (at least in neo4j 4.0.4). *You should always profile your queries to help optimize them, and to make sure they remain optimized after version changes.*

    MATCH (p:User), (q:User)
    WHERE
      p.user_id = 1 AND
      p.location_radius &gt; distance(p.location, q.location) &lt; q.location_radius
    RETURN p, COLLECT(q) AS others_nearby

",1,62159517
5804,https://stackoverflow.com/a/62483540,IFC to Cypher via python and IfcOpenShell,true,"It seems this script was created for IfcOpenShell v0.5 compiled for IFC2x3 while you are using IfcOpenShell v0.6, which is unfortunately not backwards-compatible. You could either try to use v0.5 or update the script to the v0.6 API.

If you use v0.5, be aware that this version was compiled for a specific IFC version. I believe the published packages are for IFC2x3, thus it will not work with IFC4 files. You could compile for IFC4 though, but then would loose IFC2x3 support. The assertion wouldn&#39;t work anymore, because IFC4 walls have one more attribute `PredefinedType`:

    assert typeDict[&quot;IfcWall&quot;] == (&#39;GlobalId&#39;, &#39;OwnerHistory&#39;, &#39;Name&#39;, &#39;Description&#39;, &#39;ObjectType&#39;, &#39;ObjectPlacement&#39;, &#39;Representation&#39;, &#39;Tag&#39;, &#39;PredefinedType&#39;)

Alternatively if using v0.6 you will have to change more in the script. Maybe like in this [updated Gist](https://gist.github.com/hlg/2573e52c26b18a949b083466dd2f23d6/revisions). There was another issue further down and you might encounter more. If in doubt, try to contact the original author or use the script as an inspiration to write your own conversion.
",0,62483540
5805,https://stackoverflow.com/a/62111506,Neo4j: return error if no matching nodes found when creating a relationship?,false,"Instead of an error, your query can just return something (like the new relationship) when it successfully finds both nodes. If the query returns nothing, then that means one or both nodes do not exist.

For example:

    MATCH (user1: User{uuid: &#39;123&#39;}), (user2: User{uuid: &#39;456&#39;})
    CREATE (user1)-[r:LIKES]-&gt;(user2)
    RETURN r;

",0,62111506
5806,https://stackoverflow.com/a/62097811,Return all nodes that are indirectly related to central node,true,"This Cypher code *should* find both desired nodes:

    MATCH
      (u:user)-[:watched]-&gt;(v1),
      (v1)-[:hasTag]-&gt;(t)&lt;-[:hasTag]-(v2),
      (v1)-[:hasGenre]-&gt;(g)&lt;-[:hasGenre]-(v2)
    WHERE u.name = $name
    RETURN v2.name",1,62097811
5807,https://stackoverflow.com/a/62099406,"In Neo4j v4.0, Graph Data Science Library: why is Native Projection better than Cypher Projection in terms of performance?",false,"You are correct, all projections end up stored entirely in-memory. The difference between cypher projection and native projection is how fast we can store or materialize the projected graph. As far as I know, native projection uses internal Neo4j API, which makes it faster to load the graph, but is limited to only specifying node labels and relationship types. Cypher projection, on the other hand, supports all the features of cypher and can be used to filter the subgraph we want to project very flexibly. We can also project a virtual graph. A very common projection of a virtual graph is to project a bipartite graph as a unipartite graph using only cypher projection. You must realize though that the more complex your cypher queries are, the slower the graph projection will be. And even just projecting a single node label and relationship type will be slower with cypher projection than with native projection. But I wouldn&#39;t worry much about that until your graph gets bigger than 10s of millions of nodes and relationships

Once the graph is materialized in-memory, the execution times of the algorithms should be the same regardless of the algorithm being projected with cypher projection or native projection.",2,62099406
5808,https://stackoverflow.com/a/62319404,Can I rewrite this Cypher query to be compatible with Redis Graph?,true,"The `ALL` function isn&#39;t supported at the moment, we do intend to add it in the near future, an awkward way of achieving the same effect as the `ALL` function would be a combination of `UNWIND` and `count`

```
MATCH path = (:agent {id: 482})&lt;-[:supervised *]-(b:agent)
WITH b AS b, relationships(path) AS edges, size(relationships(path)) AS edge_count
UNWIND edges AS r
WITH b AS b, edge_count AS edge_count, r AS r
WHERE r.module_id = 1 AND r.valid_from &lt; &#39;2020-05-29&#39; AND &#39;2020-05-29&#39; &lt; r.valid_to
WITH b AS b, edge_count AS edge_count, count(r) AS filter_edge_count
WHERE edge_count = filter_edge_count
....
```
",3,62319404
5809,https://stackoverflow.com/a/62090333,Add constraints to neo4j node based on node property value,true,"Instead of adding a flag property, you can just [add an additional label](https://neo4j.com/docs/cypher-manual/4.0/clauses/set/#set-set-a-label-on-a-node) (say, `ConstrainedEntity`) to `Entity` nodes that should be constrained. Queries can continue to use just the `Entity` label.

For example:

    CREATE CONSTRAINT ON (ce:ConstrainedEntity) ASSERT EXISTS (ce.foo)

To create a &quot;flagged&quot; `Entity`:

    CREATE (e:Entity:ConstrainedEntity {id: 111, foo: &#39;bar&#39;})

To &quot;flag&quot; an existing `Entity`:

    MATCH (e:Entity)
    WHERE e.id = 123
    SET e:ConstrainedEntity

",0,62090333
5810,https://stackoverflow.com/a/62090691,Neo4J ServiceUnavailable always in same place. No idea why,true,"Yes, using smaller batches will probably help.

Also, your query can be simplified:

       UNWIND $batch as row
       MATCH (e:Episode {issueKey: row.issueKey}), (a:OtherElement)
       WHERE a.id IN row.otherIds
       CREATE (e)-[:ENABLES]-&gt;(a)

In addition, having [indexes](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/) on `:Episode(issueKey)` and `:OtherElement(id)` should improve performance.",1,62090691
5811,https://stackoverflow.com/a/62077936,converting a value to datetime in load csv in cypher,true,"Neo4j can automatically parse a wide variety of [string formats to temporal instants](https://neo4j.com/docs/cypher-manual/current/syntax/temporal/#cypher-temporal-instants) (like `datetime`). You just have to use a supported string format.

Although your example string (&quot;2019-3-8 12:10:11&quot;) is not supported, replacing the space character between the date and time with a &quot;T&quot; would work.

For example, try this:

    RETURN datetime(&quot;2019-3-8T12:10:11&quot;);

So, *provided your `creation_date` property values had a supported format*, this would work:

    :auto
    USING PERIODIC COMMIT 
    LOAD CSV WITH HEADERS FROM &#39;file:///test.csv&#39; AS row
    MERGE (news:newsID {newsID: row.id})
      ON CREATE SET 
      news.title = row.title, 
      news.creation_date = datetime(row.creation_date),
      news.content = row.content;

Or, if you want to keep your existing CSV file, and assuming its `creation_date` strings only have a single space character, you can do this:

    :auto
    USING PERIODIC COMMIT 
    LOAD CSV WITH HEADERS FROM &#39;file:///test.csv&#39; AS row
    MERGE (news:newsID {newsID: row.id})
      ON CREATE SET 
      news.title = row.title, 
      news.creation_date = datetime(REPLACE(row.creation_date, &#39; &#39;, &#39;T&#39;)),
      news.content = row.content;",2,62077936
5812,https://stackoverflow.com/a/62070561,How to check if a node contains relation with other node with 2 specific codes in it but not a particular code in Neo4j Cypher Query,true,"Something like this should work:

    MATCH (A)--&gt;(B)
    WHERE B.Code IN [&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;]
    WITH A, COLLECT(B) AS bs, COLLECT(B.Code) AS codes
    WHERE &#39;ccc&#39; NOT IN codes
    RETURN A, bs",0,62070561
5813,https://stackoverflow.com/a/62060831,Neo4j - creating relationships for referential integrity,true,"This may work for you:

    LOAD CSV WITH HEADERS FROM &quot;file:///column_ref_integrity.csv&quot; AS row
    MATCH (c1:column), (c2:column)
    WHERE c1.col_name = row.col_name AND c2.col_name = row.referenced_column_name
    MERGE (c1)-[:refers]-&gt;(c2) 
    WITH row
    MATCH (t1:table), (t2:table)
    WHERE t1.table_name = row.table_name AND t2.table_name = row.referenced_table_name
    MERGE (t1)-[:refers]-&gt;(t2) 
    WITH row
    MATCH (d1:db), (d2:db)
    WHERE d1.db_name = row.table_schema AND d2.db_name = row.referenced_table_schema
    MERGE (d1)-[:refers]-&gt;(d2)
",1,62060831
5814,https://stackoverflow.com/a/62049594,Neo4j query concerning two elements,false,"Your `Ingredient` node check is problematic. Needs to be more like:

    MATCH(x:Cake)-[:CONTAINS]-&gt; (i:Ingredient)
    WHERE i.name IN [&#39;milk&#39;, &#39;cream&#39;]
    Return x
",0,62049594
5815,https://stackoverflow.com/a/62053139,Neo4j query concerning two elements,false,"Here is one way to get the cakes that contain ALL the ingredients from a list:

    MATCH (cake:Cake)
    WHERE ALL(x IN [&#39;milk&#39;, &#39;cream&#39;] WHERE (cake)-[:CONTAINS]-&gt;(:Ingredient{name: x}))
    RETURN cake",0,62053139
5816,https://stackoverflow.com/a/62050093,neo4j cypher filter nodes apoc dijkstra,true,"Apoc dijkstra is an old an deprecated implementation of Dijkstra algorithm. You should check out the Graph Data Science plugin at https://neo4j.com/docs/graph-data-science/current/. It supports shortest weighted path algorithm or otherwise known as dijkstra algorithm, https://neo4j.com/docs/graph-data-science/current/alpha-algorithms/shortest-path/. You can can define which nodes you want and relationships you want to traverse when projecting the graph.

Hope this helps!",1,62050093
5817,https://stackoverflow.com/a/62056487,Match nodes where all relations satisfy constraints,false,"It&#39;s terribly hacky, but this is where I got

```cypher
with [&#39;Sweet Vermouth&#39;, &#39;Gin&#39;, &#39;Campari&#39;, &#39;Bourbon&#39;] as list
call {
  match (ali:Cocktail)--(ii:Ingredient) //pull all nodes
  return ali, count(ii) as needed // get count for needed ingredients
}
MATCH (ali)--(i:Ingredient)
WHERE i.name in list // get ingredients that are in the list

WITH distinct ali.name as name, count(ali.name) as available, needed
WHERE available = needed
RETURN name;
```",0,62056487
5818,https://stackoverflow.com/a/62074331,Match nodes where all relations satisfy constraints,true,"This should return all cocktails whose `needed` ingredients are in the `have` list.

    WITH [&#39;Sweet Vermouth&#39;, &#39;Gin&#39;, &#39;Campari&#39;, &#39;Bourbon&#39;] as have
    MATCH (c:Cocktail)-[:HAS]-&gt;(x)
    WITH have, c, COLLECT(x.name) AS needed
    WHERE ALL(n IN needed WHERE n IN have)
    RETURN c

Or, if you pass `have` as a [parameter](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/):

    MATCH (c:Cocktail)-[:HAS]-&gt;(x)
    WITH c, COLLECT(x.name) AS needed
    WHERE ALL(n IN needed WHERE n IN $have)
    RETURN c",1,62074331
5819,https://stackoverflow.com/a/62121439,neo4j find paths between nodes with with the fewest stages,false,"Try the following:

     MATCH (p:peak{name:&#39;Sandakphu&#39;}), (t:town{name:&#39;Darjeeling&#39;}) 
     MATCH path = ShortestPath((p)-[*..5]-(t))
     RETURN path",0,62121439
5820,https://stackoverflow.com/a/62033412,Mimic a temporary view for Neo4j results,true,"You can use APOC to create [virtual nodes &amp; relationships](https://neo4j.com/docs/labs/apoc/current/virtual/virtual-nodes-rels/#virtual-nodes-rels), which the neo4j Browser can visualize but which do not actually exist in the DB.

For example, running this query in the neo4j Browser should show virtual `TEST_REL` relationships with the desired `confidence` values:

    MATCH (n1{name:&quot;test_node1&quot;})-[:IS_SRC_OF_EVIDENCE]-&gt;(t:TestEvidence {theme:&quot;test_rel&quot;})&lt;-[:IS_TRG_OF_EVIDENCE]-(n2{name:&quot;test_node2&quot;})
    RETURN n1, n2,
      apoc.create.vRelationship(n1, &#39;TEST_REL&#39;, {confidence: AVG(t.confidence)}, n2) as rel

",1,62033412
5821,https://stackoverflow.com/a/62012476,GraphDB - get paths among different types of nodes,true,"Try the below and see if gets you what you&#39;re looking for. 

    MATCH 
      (f:filename), 
      (t1:type1 {name: &quot;type1_A&quot;)-[t1lt:linked_to]-&gt;(f), 
      (:type2 {name: &quot;type2_A&quot;)-[:linked_to]-&gt;(f),
      (:type3 {name: &quot;type3_A&quot;)-[:linked_to]-&gt;(f),
      (:type4 {name: &quot;type4_A&quot;)-[:linked_to]-&gt;(f)
    RETURN f, t1, t1lt",1,62012476
5822,https://stackoverflow.com/a/62128781,Cypher aggregate function on different nodes to evaluate condition for multiple nodes,false,"You need a subquery like `apoc.cypher.run` to not mess with your cardinality.

    MATCH (p:Post)-[:Submitted]-&gt;(:Subreddit {display_name: &#39;X&#39;})
    WITH avg(toFloat(p.score)) as score_avg
    MATCH (u:User)-[:Submitted]-&gt;(p:Post)-[:Submitted]-&gt;(:Subreddit {display_name: &#39;X&#39;})
    WHERE p.score &gt; score_avg
    WITH DISTINCT u as top_users
    MATCH (top_users)-[:Submitted]-&gt;(:Post)-[:Submitted]-&gt;(sub:Subreddit)
    // You need to run a subquery to get the average score for each subreddit
    CALL apoc.cypher.run(&quot;MATCH (p:Post)-[:Submitted]-&gt;(s:Subreddit) WHERE s.display_name = $reddit RETURN avg(toFloat(p.score)) as score_avg&quot;,{reddit:sub.display_name}) yield value
    // now we have top users and we have average score
    // You can do whatever you want to now... 


    ",1,62128781
5823,https://stackoverflow.com/a/62003636,Neo4j -CASE statement-Create a node if it doesn&#39;t exist,true,"You can use a second WITH statement to set the proper `post_id` depending on the case. 

Modified query:

```
MATCH (p:Post{user_id:1})
WITH count(p) as c, max(p.post) as max_post_id  // keep the max post_id in the aggregate
WITH 
    CASE  
        WHEN c &gt; 0 THEN max_post_id + 1  // increment existing post id
        ELSE 1 
    END 
    AS post_id
CREATE (:Post {user_id: 1, post: post_id})
```
",1,62003636
5824,https://stackoverflow.com/a/62072185,Cypher commands not being recognised,true,"SHOW DATABASES command is against the system database. Please see the following excerpt from https://neo4j.com/docs/operations-manual/4.0/monitoring/individual-db-states/

13.7.1. Listing Databases
First ensure that you are executing queries against the system database, either by running the command :use system (if using the Cypher shell or Neo4j Browser) or by creating a session against the system database using a Neo4j driver. Subsequently, run the SHOW DATABASES command.

Syntax:

SHOW DATABASES",1,62072185
5825,https://stackoverflow.com/a/61988426,neo4j Cypher - Check if exact graph exists,true,"**Edit:** *Jump to the last Cypher statement below for the final answer. Otherwise, feel free to read thru the saga of discovery*

I think the issue is that in the first query the entire WHERE clause is only being applied to the WITH. In the Cypher below I broke the WHERE clause from the first query into two WHEREs, one for the MATCH and one for the WITH. Hopefully this will give the expected results.

    MATCH
    (n:User {userId: 1234}),
    (n_0:User {userId: 3345}),
    (n_1:Group {groupId: 8765}),
    (n_1_0:Event {eventId:3456})
    
    WHERE (n)-[:PING {someProp:true}]-&gt;(n_0)
    AND   (n)-[:JOIN {someProp:&quot;cool&quot;}]-&gt;(n_1)
    AND   (n_1)-[:PUBLISH {otherProp: &quot;Hello&quot;}]-&gt;(n_1_0)
    
    WITH n, n_0, n_1, n_1_0
    
    OPTIONAL MATCH
    (n)--&gt;(n_rel),
    (n_0)--&gt;(n_0_rel),
    (n_1)--&gt;(n_1_rel),
    (n_1_0)--&gt;(n_1_0_rel)
    
    WITH
    n, count(n_rel) AS n_count,
    n_0, count(n_0_rel) AS n_0_count,
    n_1, count(n_1_rel) AS n_1_count,
    n_1_0, count(n_1_0_rel) AS n_1_0_count
    
    WHERE
    n_count = 2
    AND   n_0_count = 0
    AND   n_1_count = 1
    AND   n_1_0_count = 0
    
    RETURN n

Using the Movies graph I came up with this query. I believe it&#39;s roughly equivalent to your query and follows the same pattern I originally suggested. It has the same issue you found. When the OPTIONAL MATCH doesn&#39;t find any results then nothing is returned.

    MATCH
      (jamest:Person {name: &quot;James Thompson&quot;}),
      (jessicat:Person {name: &quot;Jessica Thompson&quot;})
    WHERE 
      (jamest)-[:FOLLOWS]-&gt;(jessicat)
    
    WITH jamest, jessicat
    
    OPTIONAL MATCH
      (jamest)-[:REVIEWED]-&gt;(jamest_rev_rel), // James Thompson has 2 REVIEWED relationships
      (jessicat)-[:FOLLOWS]-&gt;(jessicat_fol_rel) // Jessica Thompson has no outbound FOLLOWS relationships
    WITH
      jamest, count(jamest_rev_rel) AS jamest_rev_rel_count,
      jessicat, count(jessicat_fol_rel) AS jessicat_fol_rel_count
    WHERE
      jamest_rev_rel_count = 2
      AND jessicat_fol_rel_count = 0
    
    RETURN jamest, jessicat // No results returned

I reworked the query into this. This one returns the expected results. It feels overly cumbersome but hopefully it&#39;ll give you something to work with. I&#39;ll keep tinkering with it.

    MATCH
      (jamest:Person {name: &quot;James Thompson&quot;}),
      (jessicat:Person {name: &quot;Jessica Thompson&quot;})
    WHERE 
      (jamest)-[:FOLLOWS]-&gt;(jessicat)
    
    WITH jamest, jessicat
    
    OPTIONAL MATCH
      (jamest)-[:REVIEWED]-&gt;(jamest_rev_rel) 
    WITH
      jessicat, jamest, count(jamest_rev_rel) as jamest_rev_rel_count
    WHERE 
      jamest_rev_rel_count = 2 // James Thompson has 2 REVIEWED relationships
    
    WITH jamest, jessicat
      
    OPTIONAL MATCH
      (jessicat)-[:FOLLOWS]-&gt;(jessicat_fol_rel) 
    WITH
      jamest, jessicat, count(jessicat_fol_rel) AS jessicat_fol_rel_count
    WHERE 
      jessicat_fol_rel_count = 0 // Jessica Thompson has no outbound FOLLOWS relationships
    
    RETURN jamest, jessicat // The two nodes are returned as expected

The root of the issue turned out to be having one OPTIONAL MATCH with multiple, comma separated patterns versus multiple OPTIONAL MATCH statements. In the former, all of the separate patterns are considered to be a single pattern. Whereas in the latter they&#39;re distinct which is what this query needs. This [SO question][1] gives more details.

The query can be leaned down quite a bit though. This version gives the same results as the above and is a lot more readable in my opinion

    MATCH
      (jamest:Person {name: &quot;James Thompson&quot;}),
      (jessicat:Person {name: &quot;Jessica Thompson&quot;})
    OPTIONAL MATCH 
      (jamest)-[:REVIEWED]-&gt;(jamest_rev_rel)
    OPTIONAL MATCH 
      (jessicat)-[:FOLLOWS]-&gt;(jessicat_fol_rel) 
    WITH
      jessicat, jamest, 
      count(jamest_rev_rel) as jamest_rev_rel_count, 
      count(jessicat_fol_rel) as jessicat_fol_rel_count
    WHERE 
      jamest_rev_rel_count = 2 // James Thompson has 2 outbount REVIEWED relationships 
      AND jessicat_fol_rel_count = 0 // Jessica Thompson has 0 outbound FOLLOWS relationships
    
    RETURN 
      jamest, jessicat // The two nodes are returned as expected


  [1]: https://stackoverflow.com/questions/32742751/what-is-the-difference-between-multiple-match-clauses-and-a-comma-in-a-cypher-qu",1,61988426
5826,https://stackoverflow.com/a/61961776,Avoid creating multiple relationships for each match,true,"You want to use `MERGE` instead of `CREATE` to have only a single relationship between those nodes.

    MATCH (a:User)-[:AUTHORED]-(c:Comment),(b:Flair)
    WHERE c.flair = &#39;foo&#39; and b.name = &#39;foo&#39;
    MERGE (a)-[r:VOTES_FOR]-&gt;(b)
    RETURN type(a,b,r)",0,61961776
5827,https://stackoverflow.com/a/61961973,Avoid creating multiple relationships for each match,false,"To avoid creating duplicate relationships, you should use [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) instead of `CREATE`:

    MATCH (a:User)-[:AUTHORED]-&gt;(c:Comment), (b:Flair)
    WHERE c.flair = &#39;foo&#39; AND b.name = &#39;foo&#39;
    MERGE (a)-[r:VOTES_FOR]-&gt;(b)
    RETURN a, b, r

*This query also removed the use of the `TYPE` function, since your query was using it illegally.*

But I should also note you are introducing redundant data into your DB by adding the `VOTES_FOR` relationship. Instead, I would suggest removing the `flair` property from the `Comment` node and replacing it with a relationship between `Comment` and `Flair` nodes. The following query should achieve that (and would also avoid redundantly storing the same info in multiple places). In addition, it processes all flair values (not just &quot;foo&quot;):

    MATCH (u:User)-[:AUTHORED]-&gt;(c:Comment), (f:Flair)
    WHERE c.flair = f.name
    REMOVE c.flair
    MERGE (c)-[:FOR_FLAIR]-&gt;(f)
    RETURN u, c, f

Or, more efficiently, if you don&#39;t really need the `User` to be returned:

    MATCH (c:Comment), (f:Flair)
    WHERE c.flair = f.name
    REMOVE c.flair
    MERGE (c)-[:FOR_FLAIR]-&gt;(f)
    RETURN c, f

With this new data model, you can find all the distinct Flairs that were authored by a user this way:

    MATCH (user:User)-[:AUTHORED]-&gt;()-[:FOR_FLAIR]-&gt;(flair)
    WHERE user.id = 123
    RETURN user, COLLECT(DISTINCT flair) AS flairs",1,61961973
5828,https://stackoverflow.com/a/61946439,How to aggregate count of nodes at every depth of variable length relationship,true,"[Aggregating functions](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) like `COLLECT` use the non-aggregating terms in the same `WITH` (or `RETURN`) clause as `grouping keys`. You should read the documentation for more details.

Here is a query that might be suitable for your use case:

    MATCH p = (:User {uid: 1})-[:REFERRED|SUBSCRIBED_TO*]-&gt;(end)
    WITH
      LENGTH(p) AS depth,
      TYPE(LAST(RELATIONSHIPS(p))) AS type,
      COLLECT(end) as ends
    RETURN depth, type, SIZE(ends) AS count, ends

`depth`, `type`, and `count` should have your expected values. And `ends` will be a collection of the `end` nodes that have the same `depth` and `type` values. ",1,61946439
5829,https://stackoverflow.com/a/61917244,neo4j path query with nodes,false,"1. To get the hotels that have a direct `HAS_JUNC` relationship to a specific `hotel_loc` (whose id is assumed to be in the `loc_id` [parameter](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/)) :

        MATCH (a:hotel)-[:HAS_JUNC]-&gt;(ap)
        WHERE ap.loc_id = $loc_id
        RETURN ap, COLLECT(a) AS directly_connected_hotels

2. To get *all* the hotels connected to a specific `hotel_loc`:

        MATCH (a:hotel)-[:HAS *0..]-&gt;()-[:HAS_JUNC]-&gt;(ap)
        WHERE ap.loc_id = $loc_id
        RETURN ap, COLLECT(a) AS connected_hotels

 In the [variable-length relationship](https://neo4j.com/docs/developer-manual/3.4/cypher/clauses/match/#varlength-rels) pattern `[:HAS *0..]`, the `0` lower bound means that the pattern is allowed to match paths in which the `HAS` relationship does not exist.",0,61917244
5830,https://stackoverflow.com/a/61914800,How to move all neo4j relationships with all their labels and properties from one node to another?,false,"I think you need to take a look at APOC, especially [`apoc.create.relationship`](https://neo4j.com/docs/labs/apoc/current/graph-updates/data-creation/) which enable creating relationships with dynamic type.

Adapting your example, you should end up with something along the line of (not tested):

```
MATCH (a), (b) WHERE a.id == b.id
MATCH (b)-[r]-&gt;(n)
CALL apoc.create.relationship(a, type(r), properties(r), n)
DETACH DELETE b
```

**NB**

- relationships have **TYPE** and not **label**
- the proper cypher statement to delete relationships attached to a node and the node itself is `DETACH DELETE` (and not `DELETE DETACH`)


Related resource: https://markhneedham.com/blog/2016/10/30/neo4j-create-dynamic-relationship-type/",2,61914800
5831,https://stackoverflow.com/a/61924042,How to move all neo4j relationships with all their labels and properties from one node to another?,true,"The APOC procedure [apoc.refactor.mergeNodes](https://neo4j-contrib.github.io/neo4j-apoc-procedures/3.5/graph-refactoring/merge-nodes/) should be very helpful. That procedure is very powerful, and you need to read the documentation to understand how to configure it to do what you want in your specific situation.

Here is a simple example that shows how to use the procedure&#39;s default configuration to merge nodes with the same `id`:

    MATCH (node:Foo)
    WITH node.id AS id, COLLECT(node) AS nodes
    WHERE SIZE(nodes) &gt; 1
    CALL apoc.refactor.mergeNodes(nodes, {}) YIELD node
    RETURN node

In this example, I specified an arbitrary `Foo` label to avoid accidentally merging unwanted nodes. Doing so also helps to speed up the query if you have a lot of nodes with other labels (since they will not need to be scanned for the `id` property).

The [aggregating function](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) `COLLECT` is used to collect a list of all the nodes with the same `id`. After checking the size of the list, it is passed to the procedure.",1,61924042
5832,https://stackoverflow.com/a/61908153,Receive JSON data from Neo4j to Spring Boot API,false,"You could use apoc.convert.toTree which takes a list of paths and creates a structure like yours.

",0,61908153
5833,https://stackoverflow.com/a/61919493,Neo4j/Cypher - LIMIT makes query run faster although less results are returned,false,"Yes that&#39;s a planner issue, I think it should also go away when you leave off the `:Movie` label on the 2nd node. 

It shouldn&#39;t do two outside scans and then a join in the middle. Unfortunately there is no planner hint that tells it not to.

In your case the expand from left to right makes more sense as it narrows down as it goes along.

btw. you can also elevate the job to the rel-type so have `:DIRECTED` instead of job=director which makes it also more efficient.",0,61919493
5834,https://stackoverflow.com/a/61905481,Spring data neo4j: Invalid syntax &#39;$&#39; in Cypher。 How to replace &#39;$&#39; with &#39;{}&#39;?,false,"You are using a really old version of neo4j (older than 3.0).

In neo4j 3.0, the `{foo}` syntax was [deprecated](https://neo4j.com/docs/cypher-manual/4.0/deprecations-additions-removals-compatibility/#cypher-deprecations-additions-removals-3.0) in favor of the `$foo` syntax. In neo4j 4.0, the `{foo}` syntax was totally [removed](https://neo4j.com/docs/cypher-manual/4.0/deprecations-additions-removals-compatibility/#cypher-deprecations-additions-removals-4.0).

Instead of trying to support the obsolete `{foo}` syntax, you should upgrade your neo4j installation to a more recent (ideally, the latest) version of neo4j. If you have data to upgrade, you will have to upgrade in 2 steps:

- [From your current version to 3.5](https://neo4j.com/docs/operations-manual/3.5/upgrade/).
- [From 3.5 to 4.x](https://neo4j.com/docs/operations-manual/current/upgrade/).",1,61905481
5835,https://stackoverflow.com/a/61905391,MATCH based on sum of common node property,false,"This may work for you (assuming `b.date` is suitable for sorting):

    MATCH (a:musician)-[:PLAYED]-&gt;(b:jamSession)&lt;-[:PLAYED]-(c:musician)
    WHERE a.name = &quot;Joe Smith&quot;
    WITH a, c, b ORDER BY b.date
    WITH a, c,
      REDUCE(s = {sum: 0}, x IN COLLECT(b) |
        CASE WHEN s.date IS NULL AND x.durationInHours + s.sum &gt;= 100
          THEN {sum: s.sum + x.durationInHours, date: x.date}
          ELSE s
        END
      ) AS data
    WHERE data.date IS NOT NULL
    RETURN c.name AS name, data.date AS date

The [aggregating function](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) `COLLECT` is used to collect the date-ordered `b` nodes that are shared by the same `a` and `c` node pairs. And the [REDUCE](https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-reduce) function is used to iterate through the ordered `b` nodes to find when the 100 threshold is met.",0,61905391
5836,https://stackoverflow.com/a/61872286,How to properly use apoc.periodic.iterate to reduce heap usage for large transactions?,true,"My issue was that although using apoc.periodic.iterate, I was still uploading that large 1.3million node data set to the database as a parameter for the query! 

Modifying my code to do the batching myself as follows fixed my heap usage problem, and the slowness problem:

      const int batchSize = 2000;
      for (int count = 0; count &lt; nodeData.Count; count += batchSize)
      {
        string createNodesQueryString = $@&quot;
          UNWIND $nodes_in AS newNodeObj
          CREATE(n:MyNode)
          SET n = newNodeObj&quot;;

        int length = Math.Min(batchSize, nodeData.Count - count);

        var createNodesResCursor = await session.RunAsync(createNodesQueryString,
                                                    new { nodes_in = nodeData.ToList().GetRange(count, length) });
      
        var createNodesResSummary = await createNodesResCursor.ConsumeAsync();
      }",1,61872286
5837,https://stackoverflow.com/a/61850596,How to return a list of people in neo4j?,true,"This query will get you those readers.

    MATCH(r:READER)-[:READS]-&gt;(b:BOOK{title:&quot;Moby Dick&quot;}
    RETURN r",1,61850596
5838,https://stackoverflow.com/a/61842421,Find all children of a Person along with their Spouse using Cypher,true,"Check out the Cypher [OPTIONAL MATCH][1] statement. It should do what you&#39;re looking for.


  [1]: https://neo4j.com/docs/cypher-manual/current/clauses/optional-match/",0,61842421
5839,https://stackoverflow.com/a/61841096,Neo4j Get all nodes which related to list of nodes,true,"    WITH [1,2,3] as inputThemes
    MATCH (t:TERM)--&gt;(th:THEME)
    WHERE id(th) in inputThemes
    WITH t, size(inputThemes) as inputCnt, COUNT(distinct th) as matchedCnt
    WHERE inputCnt= matchedCnt
    RETURN t

",0,61841096
5840,https://stackoverflow.com/a/61808135,Cypher to sum dynamic properties values,true,"Here is one way:

    MATCH (n:Entity)
    RETURN
      n.name,
      COALESCE(n.`dataSources.ds1.count`, 0) + COALESCE(n.`dataSources.ds2.count`, 0) AS count
    ORDER BY count

The [COALESCE](https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-coalesce) function returns its first non-NULL argument.

Or, if you pass the list of property names in a `props` [parameter](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/):

    MATCH (n:Entity)
    RETURN n.name, REDUCE(s = 0, p IN $props | s + COALESCE(n[p], 0)) AS count
    ORDER BY count",0,61808135
5841,https://stackoverflow.com/a/61806843,How to improve performance of LOAD CSV in NEO4J,true,"Ideally, you should be using the lastest neo4j version, as there have been many performance improvements since 3.3.9. Since you already have indexes on `:Animal(name)` and `:Person(name)`, the other  main issue is probably that the Cypher planner is generating an expensive [Eager](https://neo4j.com/docs/cypher-manual/4.0/execution-plans/operators/#query-plan-eager) operation (at least in neo4j 4.0.3) for your query. Whenever you have performance issues, you. should use [`EXPLAIN` or `PROFILE`](https://neo4j.com/docs/cypher-manual/4.0/query-tuning/how-do-i-profile-a-query/) to see the operations that the Cypher planner generates.

Try using this simpler query (which should do the same thing as yours). Using `EXPLAIN` in neo4j 4.0.3, this query does not use the Eager operation:

    :auto USING PERIODIC COMMIT LOAD CSV WITH HEADERS FROM &quot;file:///Test.csv&quot; AS row
    MERGE(animal:Animal {name: row.`ANIMAL_NAME`})
    SET animal += {type:row.`TYPE`, status:row.`Status`, birth_date:row.`DATE`}
    MERGE (person:Person { name:row.`PERSON_NAME`})
    SET person += {age:row.`AGE`, address:row.`Address`, birth_date:row.`PERSON_DATE`}
    MERGE (person)-[:OWNS]-&gt;(animal);

*The `:auto` command is required in neo4j 4.x when using `USING PERIODIC COMMIT`.*",0,61806843
5842,https://stackoverflow.com/a/61825585,Neo4j Cypher: Unable to define relationships with duplicate records,true,"Something like this may work for you:

    LOAD CSV WITH HEADERS FROM &#39;file:///df_temp.csv&#39; AS row
    MERGE (p:Person {id: row._id})
    MERGE (s:Session {id: row.sessionField})
    FOREACH(
      x IN CASE WHEN s.eventTypes IS NULL OR NOT row.eventType IN s.eventTypes THEN [1] END |
      SET s.eventTypes = COALESCE(s.eventTypes, []) + row.eventType)
    MERGE (p)-[:HAS_SESSION]-&gt;(s)
    RETURN p, s

The resulting `Person` and `Session` nodes would be unique, each `Session` node would have an `eventTypes` list with distinct values, and the appropriate `Person` and `Session` nodes would be connected by a `HAS_SESSION` relationship.

An `Action` node does not seem to be necessary.",1,61825585
5843,https://stackoverflow.com/a/61807647,How do I find the maximum value between several specific nodes in neo4j?,true,"You could do something like this to get the right values.

    // start with a set of slices you would like to get the max from
    WITH [[1,3],[3,5]] AS slices

    // match the path you want to get the slices from
    MATCH path=(:Bar {id: 1})-[:NEXT_BAR*..5]-&gt;(end:Bar)
    WHERE NOT (end)--&gt;()
    WITH slices, path

    // look at the nodes in each slice of the path 
    UNWIND slices AS slice

    // find the max value in the slice
      UNWIND nodes(path)[slice[0]..slice[1]] AS b
      RETURN &#39;b&#39; + toString(slice[0]) + &#39;_b&#39; + toString(slice[1]-1) + &#39;_max&#39;, max(b.value) AS max_value

Rather than returning the slice and max values in rows you can instead collect them as pairs and convert that to a map using `apoc.map.fromPairs`. Then access specific values in the map and return them as columns.

    WITH [[1,3],[3,5]] AS slices
    MATCH path=(:Bar {id: 1})-[:NEXT_BAR*..5]-&gt;(end:Bar)
    WHERE NOT (end)--&gt;()
    WITH slices, path
    UNWIND slices AS slice
      UNWIND nodes(path)[slice[0]..slice[1]] AS b
      WITH [&#39;b&#39; + toString(slice[0]) + &#39;_b&#39; + toString(slice[1]-1) + &#39;_max&#39;, max(b.value)] AS pair
    WITH collect(pair) AS pairs
    RETURN apoc.map.fromPairs(pairs)[&#39;b1_b2_max&#39;] AS b1_b2_max, 
    apoc.map.fromPairs(pairs)[&#39;b3_b4_max&#39;] AS b3_b4_max
",1,61807647
5844,https://stackoverflow.com/a/61918630,Multiple match statements in neo4j in a single query which are related to each other,true,"If I understand you correctly you want to return three different types of post in a single query. The best way to approach this problem is to use the [UNION][1] operator. Given that I don&#39;t know your graph schema, your query would look along the lines of:

    MATCH (u:User{id:$userId})-[:HAS_POST]-&gt;(post)
    RETURN post
    UNION
    MATCH (u:User{id:$userId})-[:MEMBER]-&gt;(group)-[:HAS_POST]-&gt;(post)
    RETURN post

This is one way how you could approach your problem. Another way would be to also use [OPTIONAL MATCH][2], but I would need more information before I could help you more.


  [1]: https://neo4j.com/docs/cypher-manual/current/clauses/union/
  [2]: https://neo4j.com/docs/cypher-manual/current/clauses/optional-match/",1,61918630
5845,https://stackoverflow.com/a/61790994,Facing Syntax Issue in Cypher Query of Neo4j,true,"I think, you are using too many brackets; just remove them:

    &quot;MATCH (x:%s) &lt;-[r]- (m:%s) &quot;
        + &quot;WHERE NOT (x)&lt;-[:PREDECESSOR]-() &quot;
        + &quot;AND NOT (x)-[:PREDECESSOR {action:&#39;DEL&#39;}]-&gt;() &quot;
        + &quot;AND NOT (m)-[:PREDECESSOR {action:&#39;DEL&#39;}]-&gt;() &quot;
        + &quot;RETURN COUNT(m) AS c&quot;;	",1,61790994
5846,https://stackoverflow.com/a/61796478,SCOPE OF VARIABLE IN NEO4J - CYPHER after loading csv file. / alternate code for this pls,false,"You need to include `live` in every `WITH` so that it carries forward in the query. Try this and see if it works.

    load csv with headers from &quot;file:///latlong1.csv&quot; as home
    load csv with headers from &quot;file:///latlong2.csv&quot; as live
    WITH live, point({ latitude:toFloat(home.lath), longitude:toFloat(home.longh)}) AS p1, 
     point({ latitude:toFloat(live.latl), longitude:toFloat(live.longl)}) AS p2
    with live, toInteger(distance(p1,p2)/1000) AS km
    where km &gt; 5 
    merge (redalert{dist:km, Latitude:live.latl, Longitude:live.longl})
    return redalert",0,61796478
5847,https://stackoverflow.com/a/61780630,How to add multiple labels using Neo4jClient,false,"`CREATE` and `MERGE` allow you to specify multiple labels at the same time.

So, instead of:

    .Merge(&quot;(n:Node { Token: {token} })&quot;)

you can do something like this (where `Second` and `Third` are also labels):

    .Merge(&quot;(n:Node:Second:Third { Token: {token} })&quot;)


###CAVEAT

You should be careful when you specify multiple labels in a `MERGE` clause, as you could accidentally create what you might consider to be duplicate nodes.

For example, suppose you execute a query like this and it creates a node:

    ...
    .Merge(&quot;(n:Node { Token: &#39;abc&#39; })&quot;)
    ...

And later on you execute a query like this:

    ...
    .Merge(&quot;(n:Node:Second:Third { Token: &#39;abc&#39; })&quot;)
    ...

The latter query will *also* create a node because there was not yet a node will *all 3 labels*.

*On the other hand, if you executed those queries in the opposite order, no new node would be created.*",1,61780630
5848,https://stackoverflow.com/a/61777204,Delete duplicate relationships with the same value of property saving other relationships with Cypher,true,"I would use grouping instead.

```
MATCH (:Foo) -[r:TYPE]-&gt;(:Bar)
WITH r.year as year collect(r) as rels
CALL apoc.refactor.mergeRelationships(rels) 
YIELD rel 
RETURN rel
```

not sure what you mean with:

&gt; But I can&#39;t normally write part after WITH",0,61777204
5849,https://stackoverflow.com/a/61767871,NEO4j: Help manipulating list in RETURN,true,"*I presume that your lists contain maps like `{ID: 1, value: 0}`, not illegal constructs like `[ID: 1, value: 0]`.*

You can use the [aggregating function](https://neo4j.com/docs/cypher-manual/current/functions/aggregating/) `MAX`:

    UNWIND list AS node
    RETURN {ID: node.ID, value: MAX(node.value)};

Or, if you want the result to be a list of maps:

    UNWIND list AS AS node
    WITH {ID: node.ID, value: MAX(node.value)} AS item
    RETURN COLLECT(item);",1,61767871
5850,https://stackoverflow.com/a/64918912,How can I sum the properties along the edges in a deep traversal,false,"Supposing you have a graph with the following setup:

```sql 
CREATE (a:Part {&#39;part_num&#39;: &#39;123&#39;}), (b:Part {&#39;part_num&#39;: &#39;345&#39;}), 
       (c:Part {&#39;part_num&#39;: &#39;456&#39;}), (d:Part {&#39;part_num&#39;: &#39;789&#39;}); 

MATCH (a:Part {&#39;part_num&#39;: &#39;123&#39;}), (b:Part {&#39;part_num&#39;: &#39;345&#39;})
CREATE (a)-[u:used_by { quantity: 1 }]-&gt;(b);

MATCH (b:Part {&#39;part_num&#39;: &#39;345&#39;}), (c:Part {&#39;part_num&#39;: &#39;456&#39;})
CREATE (b)-[u:used_by { quantity: 2 }]-&gt;(c);

MATCH (a:Part {&#39;part_num&#39;: &#39;123&#39;}), (d:Part {&#39;part_num&#39;: &#39;789&#39;}) 
CREATE (a)-[u:used_by { quantity: 1 }]-&gt;(d);
```

You would then end up with the following graph:
[![graph][1]][1]

Using your base query, we get back a JSON array
```sql
MATCH (a:part {part_num: &#39;123&#39;})-[u:used_by*]-&gt;(b:part {part_num: &#39;456&#39;})
RETURN [x IN u::jsonb | x.properties.quantity] AS quantities

-- Results
 quantities
------------
 [1, 2]
(1 row)
```

Finally, we just need to utilize the hybrid SQL/Cypher capabilities of AgensGraph to convert that array using `jsonb_array_elements_text` and then `SUM` up that subquery.

```sql
SELECT sum(quantity::int) AS sum_of_used_by
FROM (
  SELECT jsonb_array_elements_text(paths.quantity) AS quantity
  FROM ( 
    MATCH (a:part {part_num: &#39;123&#39;})-[u:used_by*]-&gt;(b:part {part_num: &#39;456&#39;})
    RETURN [x IN u::jsonb | x.properties.quantity] AS quantity
  ) AS paths
) as total

-- Results
 sum_of_used_by
----------------
              3
(1 row)
```

  [1]: https://i.stack.imgur.com/vQhBH.png",0,64918912
5851,https://stackoverflow.com/a/61758703,session.run(LOAD CSV) issues,true,That LOAD CSV command will just invoke `CREATE (n)` once per line which will create a node with no label or properties. Try changing it to something like `CREATE (n:CsvNode) SET n.prop_1 = csvLine.header1` (where `header1` is one of the headers from your CSV) and see if nodes labelled :CsvNode get created.,0,61758703
5852,https://stackoverflow.com/a/61756648,How to create relationship between two existing nodes by using node id?,true,"I solved the problem. So, I again queried for the ID(node) and this time I exported them as a string (by using toString(ID(node)) ). Then while loading to the database, I converted them to Integer. The query is as follows:

    LOAD CSV WITH HEADERS FROM &quot;file:///8245_new.csv&quot; AS csvLine
    match (ev:Event) where id(ev)=toInteger(csvLine.first)
    match (ev_sec:Event) where id(ev_sec)=toInteger(csvLine.second)
    merge (ev)-[:DF_mat]-&gt; (ev_sec)

",0,61756648
5853,https://stackoverflow.com/a/61763047,How to create a merge only if the key exists in json using Cypher in Neo4j,true,"The `WHERE hashes_obj.sha1 is not null` test is eliminating all `hashes_obj` maps without the `sha1` property. That means all the maps with the `md5` property are eliminated.

This should work:

    CALL apoc.load.json($url) YIELD value 
    UNWIND value AS q 
    MERGE (report:Report {filename:q.filename})
    ON CREATE SET report.title = q.title,
                  report.published_date = q.published_date
    
    // HASHES
    WITH report, value, REDUCE(s = {sha1:[], md5:[]}, x IN value.hashes |
      CASE
        WHEN x.sha1 IS NOT NULL THEN {sha1: s.sha1 + x.sha1, md5: s.md5}
        WHEN x.md5 IS NOT NULL THEN {sha1: s.sha1, md5: s.md5 + x.md5}
        END
      ) AS todo
    FOREACH(sha1 IN todo.sha1 |
      MERGE (hash_sha1:Hash_sha1 {sha1: sha1})
      MERGE (report)-[:contains]-&gt;(hash_sha1)
    )
    FOREACH(md5 IN todo.md5 |
      MERGE (hash_md5:Hash_md5 {md5: md5})
    )",1,61763047
5854,https://stackoverflow.com/a/61739541,Neo4j - Return a Pseudo relationship from a cypher,true,"With the APOC plugin, you can create [virtual nodes and relationships](https://neo4j.com/docs/labs/apoc/current/virtual/) that do not actually exist in the DB.

For example:

    CALL apoc.create.vNode([&#39;Node1&#39;], {name: &#39;dummy node 1&#39;}) YIELD node AS a
    CALL apoc.create.vNode([&#39;Node2&#39;], {name: &#39;dummy node 2&#39;}) YIELD node AS b
    CALL apoc.create.vRelationship(a, &#39;FOO&#39;, {}, b) YIELD rel
    RETURN a, b, rel

*By the way, `{Name:&#39;dummy node&#39;}` is just a property map -- not a node.*",2,61739541
5855,https://stackoverflow.com/a/61737385,How to write a more efficient import query in Neo4j using APOC,false,"I think you are not using Constraints(or Indexes).

From your query, it looks like `workId` is a unique key.
You should create a unique constraint on it for faster search in the `MERGE` clause. 

    CREATE CONSTRAINT unique_work_id
    ON (n:Work)
    ASSERT n.workId IS UNIQUE

You can also check a few other [tips on faster data load in this answer][1].


  [1]: https://stackoverflow.com/a/56548843/6077914",0,61737385
5856,https://stackoverflow.com/a/61708283,Cypher query to match multiple Destination nodes,false,"    MATCH p:Product{name:&quot;Product2&quot;}) &lt;-[*..10] -(s:Supplier)
    OPTIONAL MATCH s-[:AFFECTED_BY]-(r:RISK)
    RETURN s, r, p

OPTIONAL MATCH is like OUTER JOIN of SQL. It will optionally match :RISK nodes for the :SUPPLIER. It will return all :SUPPLIER nodes which have or don&#39;t have relation to :RISK nodes.",1,61708283
5857,https://stackoverflow.com/a/61711820,Storing multiple independent trees in Neo4j,false,"I recommend using one label, say `:Root`, for all of your trees and a `root_id` property that contains the tree&#39;s unique identifier. 

You can [create a unique constraint][1] on `root_id` to ensure that no two trees have the same ID. The unique constraint has the side effect of creating an index on the property so accessing the `:Root` nodes by `root_id` will be very fast.


  [1]: https://neo4j.com/docs/cypher-manual/current/administration/constraints/#administration-constraints-unique-nodes",1,61711820
5858,https://stackoverflow.com/a/61712242,Can we use more than 1 row in LOAD CSV(neo4j)?,true,"I don&#39;t think referring (i-1) row is possible with LOAD CSV.

Instead, you can add one column say friendID at the end of each row in CSV that has ID of (i-1) and then you need to do 2 scans over the same CSV.

Scan-1) This will create the Person nodes (friendID column will not be used)

Scan-2) This will create the relationships between Person nodes using the friendID column",1,61712242
5859,https://stackoverflow.com/a/61699837,Neo4j find path between nodes with multiple hops and same pattern,true,"If the only types of nodes between :Stops are :Connections then I think this will get you what you need:

       MATCH (from:Stop)-[:HAS|TO*1..5]-(to:Stop)
       WHERE ...

From a schema perspective, though, you may want to consider replacing `(:Stop)-[:HAS]-&gt;(:Connection)-[:T0]-&gt;(:Stop)` with just a single relationship: `(:Stop)-[:CONNECTS_TO]-&gt;(:Stop)`",1,61699837
5860,https://stackoverflow.com/a/61693657,Neo4j cypher - &quot;where edge.property = false&quot; brings also true,true,"If you&#39;re seeing this in the Neo4j Browser, then the behavior here is because by default the browser will issue an additional query after the one you execute, to find all relationships between the nodes returned, whether you asked it to or not. While this is good for graph exploration and for checking out your results, it interferes when you don&#39;t want all relationships between the nodes returned, or you were only filtering for a subset.

You can disable this by going into the browser preferences (gear icon in the lower left), scroll to the bottom of the preferences panel, and uncheck the &quot;Connect result nodes&quot; checkbox. Then run your query again and check the results.",2,61693657
5861,https://stackoverflow.com/a/61687604,neo4j Javascript API : create parameter,true,"`:param` is just a neo4j Browser command, and is not in the Cypher language.

You actually already know how to pass [parameters](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/), since your `run()` invocation is actually passing `json_table_definition` as a parameter. You just need to specify a legal Cypher query to use that parameter.

For example (with a random Cypher query):

    ...
    .run(&#39;MATCH (n:Foo) WHERE n.def = $json_table_definition RETURN n&#39;,
        {json_table_definition: input}
    )
    ...",1,61687604
5862,https://stackoverflow.com/a/61679789,How to get children of a node in redisgraph?,true,"The node &#39;A&#39; needs to be identified somehow, e.g. an attribute.

Using the Cypher query language one can get A&#39;s children by issuing the query:

`MATCH (A {id:&#39;a&#39;})-[]-&gt;(X) RETURN X`

Assuming &#39;A&#39; has an attribute &#39;id&#39; with the value &#39;a&#39; than X represent all of A&#39;s direct neighbours.",2,61679789
5863,https://stackoverflow.com/a/61690943,Search all relationships/Nodes in the path and Filter by a property list Neo4j,false,"Using the Movie Graph sample database, I wrote the statement below which I think is roughly equivalent to what you&#39;re looking to do. The Movie Graph&#39;s :ACTED_IN relationships have the property `roles` which is a list of strings. The statement matches all of the actors who played a role called &quot;Neo&quot; in a movie. In this case it finds all three Matrix movies with Keanu Reeves as the actor. Hopefully this is some help.

    MATCH (a:Person)-[ai:ACTED_IN]-&gt;(m:Movie)
    WITH a AS actor, m AS movie, ai.roles AS roles
    UNWIND roles AS role
    WITH actor, movie, role
    WHERE role = &quot;Neo&quot;
    RETURN actor.name, movie.title, role",0,61690943
5864,https://stackoverflow.com/a/61693384,Search all relationships/Nodes in the path and Filter by a property list Neo4j,false,"I found the simpler way to do it. Replace 1 in the below query with the PID you are searching for.

1) How to search all the relationships and filter on property list for PID (ProductID).

    match path= (n1) -[rel*..8] -(n2)&lt;-[:RECEIVES]-(n3)
    where   all(rel in relationships(path) where 1 in rel.PID)
    return path

2) How to search all the nodes in the Path and filter on property list for PID (ProductID)

    match path= (n1) -[rel*..8] -(n2)&lt;-[:RECEIVES]-(n3)
    where   all(rel in nodes(path) where 1 in rel.PID)
    return path",0,61693384
5865,https://stackoverflow.com/a/61674429,"In what unit does the distance() function return ? i.e meters/feet/inches/kms/miles,etc and, is there inaccuracy in using geoCode in Neo4j",false,"[The documentation](https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-distance) indicates that calling `distance` on two lat/long arguments gives the result in metres. 

&gt; If the points are in the WGS-84 CRS (3D), then the units of the returned distance will be meters.

The result will always be an approximation, because it assumes a spherical Earth - the real Earth is slightly ellipoidal. [This answer would suggest a likely max error of about 0.3%](https://gis.stackexchange.com/a/25580) with the sort of calculation that Neo4j (and most other databases) use.",0,61674429
5866,https://stackoverflow.com/a/61664719,Cypher Query: Set Property on relationship based off the aggregate of other Property Relationship,false,"Can you try this?

    match (n:BrickMrtr)-[b:BM_RU]-&gt;(ru:RU)&lt;-[bm:BM_RU_F]-(n)
    where n.Id = &#39;1000829&#39;
    with n, sum(toInteger(b.FinCYTD)) as sum_f
    set bm.amt = sum_f",0,61664719
5867,https://stackoverflow.com/a/61665403,Cypher Query: Set Property on relationship based off the aggregate of other Property Relationship,false,"This will do what you probably intended:

    MATCH (n:BrickMrtr)-[b:BM_RU]-&gt;(ru:RU)&lt;-[bm:BM_RU_F]-(n)
    WHERE n.Id = &#39;1000829&#39;
    WITH n, ru, bm, SUM(toInteger(b.FinCYTD)) as sum_f
    SET bm.Amt = sum_f

You have to assign a value to a *property* (`SET bm.Amt = ...`). You were trying to assign a value to another variable (`SET bm_amt = ...`).

Also, this query uses `n`, `ru`, and `bm` as the grouping keys for the [aggregating function](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) `SUM`, so that each sum is for a distinct `n`/`ru`/`bm` combination. (I assume that each `ru` only has a single related `bm`.)",0,61665403
5868,https://stackoverflow.com/a/61666308,neo4j finding all the connections very slow,false,"A `MATCH` clause avoids traversing the same relationship twice, so cycles involving going over the *same relationship* multiple times would not be the issue.

The root of the problem is that your graph is extremely dense. You have only 100 nodes, but on average every node has 300 relationships. This means that every node has about 3 relationships to every other node. Therefore, there are likely to be an astronomical number of unique paths between any 2 nodes, and your `MATCH` clause is trying to find all those paths (and keep them all in memory).

A simple way to reduce the memory requirement (and the processing time) is to put a reasonable upper bound on the path length. You will not find all possible paths, but the shorter paths are of more interest to most use cases anyway.

For example, to find paths up to length 6:

    MATCH p=(a:Entity{name: &#39;A 0&#39;})-[r:SENDS_TO*..6]-&gt;(d:Entity{name: &#39;A 94&#39;})
    RETURN p;",2,61666308
5869,https://stackoverflow.com/a/61666719,neo4j finding all the connections very slow,false,"&gt; to identify if there is a connection between A1 and A94

This is key. You&#39;re not actually looking for all possible paths (that&#39;s what your MATCH is trying to do) between the two nodes, but to check if there is at least one path. So your query is doing far far far more work than it actually needs to.

There are a few ways to modify your query to do less work (but first make sure you have an index on `:Entity(name)` for fast initial lookups):

1. LIMIT your results to 1, which will cause the query to stop once the first match is found:

```
MATCH p=(a:Entity{name: &#39;A 0&#39;})-[r:SENDS_TO*..]-&gt;(d:Entity{name: &#39;A 94&#39;})
RETURN p
LIMIT 1
```

2. Use a shortestPath() MATCH function to perform a bi-directional breadth-first expansion until a shortest path is found between the two nodes:

```
MATCH (a:Entity{name: &#39;A 0&#39;}), (d:Entity{name: &#39;A 94&#39;})
MATCH p = shortestPath((a)-[r:SENDS_TO*..]-&gt;(d))
RETURN p
```

3. Use path expander procedures from APOC Procedures, specifying an end node and limiting results to 1:
   
```
 MATCH (a:Entity{name: &#39;A 0&#39;}), (d:Entity{name: &#39;A 94&#39;})
 CALL apoc.path.spanningTree(a, {relationshipFilter:&#39;SENDS_TO&gt;&#39;, endNodes:[d], limit:1}) YIELD path
 RETURN path
```",0,61666719
5870,https://stackoverflow.com/a/61666860,Cypher - unlimited path length and large path length queries hang,false,"A `MATCH` clause avoids traversing the same *relationship* twice, so that would not be the issue. However, it can still travel between the same 2 nodes multiple times (as long as different relationships are used).

The main thing to consider is that variable-length relationship patterns have exponential (time and memory) complexity. If the nodes being traversed have an average of `R` relevant relationships, then the `MATCH` clause has to traverse about `R**P` possible paths of length `P`. The higher that `P` gets (especially with no upper bound), the worse it gets. But a high `R` also hurts. ",2,61666860
5871,https://stackoverflow.com/a/61644697,How to merge and then sort two lists in Cypher?,false,"You can can collect the 1st, collect the 2nd, aggregate the list, unwind return and sort. Try this, modified from this article:
https://neo4j.com/blog/cypher-union-query-using-collect-clause/

    MATCH (kbook:Book)&lt;-[:WROTE]-(kauthor:Author {name: &#39;Kurt Vonnegut&#39;})
    WITH collect({name: kbook.name, published: kbook.published, author: kauthor.name}) as rows
    MATCH(nbook:Book)&lt;-[:WROTE]-(nauthor:Author {name: &#39;Vladimir Nobokov&#39;})
    WITH rows + collect({name: nbook.name, published: nbook.published, author: nauthor.name}) as allRows
    UNWIND allRows as row
    RETURN row
    ORDER BY row.published",1,61644697
5872,https://stackoverflow.com/a/61645257,How to merge and then sort two lists in Cypher?,true,"[UPDATED]

Here is a simple and efficient query (which only needs a single `MATCH`). For example, if the list of author names is passed in an `authNames` [parameter](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/):

    MATCH (b)&lt;-[:WROTE]-(a:Author)
    WHERE a.name IN $authNames
    WITH {name: b.title, published: b.published, authors: COLLECT(a.name)} AS item
    ORDER BY b.published
    RETURN COLLECT(item) AS books

`COLLECT(a.name)` is used to make the `authors` value a list, since a book can generally have multiple authors.

You may also want to create an [index](https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-search-performance/) on `Author(name)` to optimize the query.

### Addendum

If you want to get a date-sorted list of book data (with possibly different properties, from various parts of the DB), you may want to use the new [post-union processing](https://neo4j.com/docs/cypher-manual/current/clauses/call-subquery/#subquery-post-union) support. For example, if you want to get a sorted list of books either authored by an author in `$authNames` or reviewed by a reviewer in `$revNames`:

    CALL {
      MATCH (b)&lt;-[:WROTE]-(a:Author)
      WHERE a.name IN $authNames
      RETURN {name: b.title, published: b.published, authors: COLLECT(a.name)} AS item
      UNION ALL
      MATCH (b)&lt;-[:REVIEWED]-(r:Reviewer)
      WHERE r.name IN $revNames
      RETURN {name: b.title, published: b.published, reviewers: COLLECT(r.name)} AS item
    }
    WITH item.name AS name, apoc.map.mergeList(COLLECT(item)) AS merged
    ORDER BY merged.published
    RETURN COLLECT(merged) AS books

[UNION ALL](https://neo4j.com/docs/cypher-manual/current/clauses/union/#query-union) is used (instead of `UNION`) to avoid the effort to remove duplicates because in this example the 2 subqueries should not produce duplicate items. More `UNION`s can be added for additional subqueries.

The [apoc.map.mergeList](https://neo4j.com/docs/labs/apoc/current/data-structures/map-functions/#map-functions) function is used (along with the [aggregating function](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) `COLLECT`) to merge the author and reviewer data for the same book into a single map.",2,61645257
5873,https://stackoverflow.com/a/61642145,How do i convert this SQL Query into Neo4j Cypher Query?,false,"&gt; Found the Answer to my Above query :

    MATCH (n:tablename) WHERE(n.id+n.code) IN [&quot;1234PQR&quot;,&quot;4567ABC&quot;] RETURN n",0,61642145
5874,https://stackoverflow.com/a/61657795,Neo4j: Filter by time range + group by + return relevant paths,true,"Ok I found out how to solve it:

    WITH [time(&#39;23:00&#39;), time(&#39;05:00&#39;)] as time_range
    UNWIND time_range AS time_val 
    MATCH path = (c:Car)-[]-(a:Accident)
    WHERE CASE WHEN time_range[0] &lt;= time_range[1] THEN time_range[0] &lt;= a.acc_time &lt;= time_range[0]
               ELSE a.acc_time &gt;= time_range[0] OR a.acc_time &lt;= time_range[1] END // condition 1 OK
    WITH c, count(distinct a) as cnt_accidents, MAX(a.acc_date) as latest_acc_date_for_car, 
         collect(a) as coll_accidents
    ORDER BY CASE WHEN cnt_accidents &gt;= 2 THEN 1 ELSE 0 END desc, latest_acc_date_for_car desc
    LIMIT 3 // condition 3 OK
    WHERE cnt_accidents &gt;= 2 // condition 2 OK
    UNWIND coll_accidents AS acc // Getting only accidents nodes from the previous collect
    MATCH path = (c:Car)-[]-(acc) // Matching only accidents nodes from the previous collect
    RETURN path ;


To answer my questions:

 - How can I use collect in the next match pattern? By using UNWIND
   later on and use it back in MATCH

&lt;!-- --&gt;

&gt;     UNWIND coll_accidents AS acc // Getting only accidents nodes from the
&gt;     previous collect MATCH path = (c:Car)-[]-(acc)

 - Why the WHERE clause cannot be set before ORDER BY ? I still don&#39;t understand why, but I found a work around by making sure that group by is ordered by condition first. Otherwise in original query, it was ordered by cnt_accidents, not by cnt_accidents&gt;=2. Which made the query wrong.

&lt;!-- --&gt;

&gt;     ORDER BY CASE WHEN cnt_accidents &gt;= 2 THEN 1 ELSE 0 END desc, latest_acc_date_for_car desc

",0,61657795
5875,https://stackoverflow.com/a/61641211,Neo4j Cypher Commands for Parent -Child Relationship,false,"as @CleanBold suggests, we need a lot more information to provide better clarity, but if you have already used the csv to load all the nodes in the graph and you just need them connected. Then make a 2nd pass through your csv to create the relationships

    USING PERIODIC COMMIT
    LOAD CSV WITH HEADERS FROM &#39;file:///records.csv&#39; AS row
    MATCH (parent:SomeLabel {id: row.parent_id}), (child:SomeLabel {id: row.id})
    MERGE (parent)-[:HAS_CHILD]-&gt;(child)

",1,61641211
5876,https://stackoverflow.com/a/61642699,Neo4j: Usage of parameters of type list,true,"It seems that there is indeed a problem with neo4j 4, and I am glad to see that you have already submitted an [issue](https://github.com/neo4j/neo4j/issues/12505) for that.

I have found 2 workarounds (but hopefully the issue will be fixed soon):

 1. Explicitly convert the list values to the right type. For example, if the `id` values are integers:

        MATCH (user:User)
        WHERE TOINTEGER($range[0]) &gt; user.id OR user.id &gt; TOINTEGER($range[1])
        RETURN user
        LIMIT 1

 2. Assign the list values to variables and use the variables instead:

        WITH $range[0] AS upper, $range[1] AS lower
        MATCH (user:User)
        WHERE upper &gt; user.id OR user.id &gt; lower
        RETURN user
        LIMIT 1

",2,61642699
5877,https://stackoverflow.com/a/61626095,How can I limit to only one relationship between two nodes in Neo4j?,true,"There is no built-in way to throw an error if you create a duplicate relationship. But that would also be a pretty expensive way to enforce such a policy.

Instead, you can use [MERGE](https://neo4j.com/docs/cypher-manual/current/clauses/merge/) instead of `CREATE` to avoid creating duplicate relationships.

For example, this query will only create the `DEPENDENT_ON` relationship if it does not already exist; otherwise, it will just bind the existing relationship to `r`:

        MATCH (a:Service), (b:Service)
        WHERE a.service_id = &#39;cs2322&#39; AND b.service_id = &#39;ab3232&#39;
        MERGE (a)-[r:DEPENDENT_ON]-&gt;(b)
        RETURN TYPE(r)

",3,61626095
5878,https://stackoverflow.com/a/61624359,Neo4j Out of Memory Error while deleting duplicate relationships,true,"The following query *might* execute without running out of memory:

    MATCH (a:person)-[:IS_A_FRIEND]-&gt;(b)
    FOREACH(x IN TAIL([(a)-[r:IS_A_FRIEND]-&gt;(b) | r]) | DELETE x)

The [PROFILE](https://neo4j.com/docs/developer-manual/3.4/cypher/query-tuning/how-do-i-profile-a-query/) (in neo4j 4.0.3) of this particular query does not show an [Eager](https://neo4j.com/docs/cypher-manual/current/execution-plans/operators/#query-plan-eager) operation, which may be what is causing your OOM condition.",2,61624359
5879,https://stackoverflow.com/a/61622716,Neo4j Group result based on property,false,"A more graph-oriented data model would be more suitable.

For example, you can have `Person` and `Interest` nodes connected by `LIKES` relationships:

    MERGE (peter:Person {name: &#39;Peter&#39;, gender: &#39;M&#39;})
    MERGE (ame:Person {name: &#39;Ame&#39;, gender: &#39;F&#39;})
    MERGE (greg:Person {name: &#39;Greg&#39;, gender: &#39;M&#39;})

    MERGE (movies:Interest {name: &#39;Movies&#39;})
    MERGE (games:Interest {name: &#39;Games&#39;})
    MERGE (hiking:Interest {name: &#39;Hiking&#39;})
    MERGE (dogs:Interest {name: &#39;Dogs&#39;})

    MERGE (peter)-[:LIKES]-&gt;(movies)
    MERGE (peter)-[:LIKES]-&gt;(games)
    MERGE (ame)-[:LIKES]-&gt;(dogs)
    MERGE (ame)-[:LIKES]-&gt;(movies)
    MERGE (ame)-[:LIKES]-&gt;(hiking)
    MERGE (greg)-[:LIKES]-&gt;(hiking);

With the above data, you can easily group people by their interests. A couple of examples:

    MATCH (interest:Interest)
    RETURN interest, [(p)-[:LIKES]-&gt;(interest) | p] AS people;
    
or

    MATCH (interest:Interest)&lt;-[:LIKES]-(p)
    RETURN interest, COLLECT(p) AS people;

The result would be:

    ╒═════════════════╤═══════════════════════════════════════════════════════════╕
    │&quot;interest&quot;       │&quot;people&quot;                                                   │
    ╞═════════════════╪═══════════════════════════════════════════════════════════╡
    │{&quot;name&quot;:&quot;Movies&quot;}│[{&quot;gender&quot;:&quot;M&quot;,&quot;name&quot;:&quot;Peter&quot;},{&quot;gender&quot;:&quot;F&quot;,&quot;name&quot;:&quot;Ame&quot;}]│
    ├─────────────────┼───────────────────────────────────────────────────────────┤
    │{&quot;name&quot;:&quot;Games&quot;} │[{&quot;gender&quot;:&quot;M&quot;,&quot;name&quot;:&quot;Peter&quot;}]                            │
    ├─────────────────┼───────────────────────────────────────────────────────────┤
    │{&quot;name&quot;:&quot;Hiking&quot;}│[{&quot;gender&quot;:&quot;F&quot;,&quot;name&quot;:&quot;Ame&quot;},{&quot;gender&quot;:&quot;M&quot;,&quot;name&quot;:&quot;Greg&quot;}] │
    ├─────────────────┼───────────────────────────────────────────────────────────┤
    │{&quot;name&quot;:&quot;Dogs&quot;}  │[{&quot;gender&quot;:&quot;F&quot;,&quot;name&quot;:&quot;Ame&quot;}]                              │
    └─────────────────┴───────────────────────────────────────────────────────────┘
    ",1,61622716
5880,https://stackoverflow.com/a/61689995,Neo4j Group result based on property,false,"Assuming `Like` property is an array you could do the following

```
MATCH(person:Person)
UNWIND person.like as like
RETURN like, count(*)
```",1,61689995
5881,https://stackoverflow.com/a/61618600,How to auto-import csv content into Neo4j,true,"You have a few options for importing data from a CSV file.

This [CSV import guide](https://neo4j.com/developer/guide-import-csv/) is a good intro.

If you want to import (using the Cypher `LOAD CVS` approach) from within your Javascript program, you should also read up on the official [Drivers](https://neo4j.com/developer/language-guides/).",0,61618600
5882,https://stackoverflow.com/a/61616046,neo4j recursive count of nodes,false,"Can you try this?

    MATCH (n:Target)
    WHERE &lt;some_condition&gt;
    WITH n
    MATCH (n)-[r *0..2]-(b)
    RETURN n.Key as targetId, count(r) as cnt

",0,61616046
5883,https://stackoverflow.com/a/61619923,neo4j recursive count of nodes,false,"You should be able to do everything with one `MATCH`. For example:

    MATCH (n:Target)
    WHERE &lt;some_where_logic_here&gt; AND n.Key in $keyList
    RETURN n.Key as targetId, SIZE((n)-[*0..2]-()) as cnt

",0,61619923
5884,https://stackoverflow.com/a/61604577,Neo4j Matching Variable number of relationships from previous query,true,"[EDITED]

You can use the [apoc.path.expandConfig](https://neo4j.com/docs/labs/apoc/current/graph-querying/expand-paths-config/) procedure to perform variable-length relationship queries with dynamic bounds.

For example (to get paths of length `len_p` consisting of `ACTED_IN ` relationships ending in a `Movie` node): 

    ...
    WITH length(p) AS len_p
    MATCH (charlie:Person {name: &#39;Charlie Sheen&#39;})
    CALL apoc.path.expandConfig(charlie, {
        relationshipFilter: &#39;ACTED_IN&#39;,
        labelFilter: &#39;&gt;Movie&#39;,
        minLevel: len_p,
        maxLevel: len_p
    }) YIELD path
    RETURN LAST(NODES(path)).title AS title",0,61604577
5885,https://stackoverflow.com/a/61603836,Cypher to lookup and order by multiple values,true,"Your query is *very* inefficient. You stated that `data` has 3,000 rows (let&#39;s call that number `D`).

 1. So, your first `UNWIND` creates an intermediate result of `D` rows.
 2. Your second `UNWIND` creates an intermediate result of `D**2` (i.e., 9 million) rows.
 3. If your `MATCH (e1:Entity)-[r1:RELATED_TO]-(e2)` clause finds N results, that generates an intermediate result of up to N*(D**2) rows.
 4. Since your `MATCH` clause specifies a non-directional relationship pattern, it finds the same pair of nodes *twice* (in reverse order). So, `N` is actually twice as large as it needs to be.

Here is an improved version of your query, which should be much faster (with N/2 intermediate rows):

    WITH apoc.map.groupBy(value.aggregations.ent.terms.buckets, &#39;key&#39;) as lookup
    MATCH (e1:Entity)-[r1:RELATED_TO]-&gt;(e2)
    WHERE e1.uuid = $entityId AND lookup[e1.uuid] IS NOT NULL AND lookup[e2.uuid] IS NOT NULL
    RETURN e1.uuid, lookup[e1.uuid].doc_count AS count1, r1.uuid, e2.uuid, lookup[e2.uuid].doc_count AS count2
    ORDER BY count2 DESC
    LIMIT 50

The trick here is that the query uses [apoc.map.groupBy](https://neo4j.com/docs/labs/apoc/current/data-structures/map-functions/) to convert your `buckets` (a list of maps) into a single unified `lookup` map that uses the bucket `key` values as its property names. This allows the rest of the query to literally &quot;look up&quot; each `uuid`&#39;s data in the unified map.",0,61603836
5886,https://stackoverflow.com/a/61585425,Neo4j cypher query is not working as expected,false,It&#39;s my bad. I forgot to put : in front of DIRECRED and now it&#39;s ok.,0,61585425
5887,https://stackoverflow.com/a/61717107,Cypher query - only one direction result,false,"I hope this can help you a bit:

    MATCH (gt:GraphTarget)
    MATCH path_account = (:Account)-[:FriendOf*]-&gt;(:Account)
    MATCH (account1:Account)-[:FriendOf]-&gt;(account2:Account)
    MATCH (account2:Account)-[:FriendOf]-&gt;(account1:Account)
    WHERE none(node IN nodes(path_account) WHERE node=account1 OR node=account2)
    RETURN gt, nodes(path_account)

I checked it graphically in Neo4j and this is the result:

Your graph
![Your graph] (https://i.stack.imgur.com/YjzGd.png)

 
The query
![Your query] (https://i.stack.imgur.com/FJJwW.png)",1,61717107
5888,https://stackoverflow.com/a/61577525,How do I create a link between nodes based on a subnode link in Neo4j,true,"Can you please try this?

    MATCH (A_leaf)-&gt;(B_leaf)
    WHERE A_leaf.GroupID &lt;&gt; B_leaf.GroupID
    WITH A_leaf
    MATCH (A_leaf)&lt;-[*]-(A_root)
    WHERE NOT (A_root)&lt;-()
    WITH B_leaf
    MATCH (B_leaf)&lt;-[*]-(B_root)
    WHERE B_leaf.GroupID == B_root.GroupID
    AND NOT (B_root)&lt;-()
    CREATE (A_root)-[:relName]-&gt;(B_root)",1,61577525
5889,https://stackoverflow.com/a/61635261,Adding a relationship in Cypher if no existing relation regardless the relationship properties,true,"Set the properties only if the merge results in a create:

    MATCH (p:Partner)-[:HAS_COMMISSIONS]-&gt;(cc:CommissionConfig),
          (gc:GroupConfig)
    WHERE gc.server = &#39;3&#39;
    MERGE(cc)-[r:BELONGS_TO_ADA_GROUP]-&gt;(gc)
      ON CREATE SET r.aa=100, r.bb=200 
",1,61635261
5890,https://stackoverflow.com/a/61578900,Neo4j server connect while PC off?,false,"The short answer is no. If the server isn&#39;t actively running on your machine then nothing can connect to it.

If you&#39;re just standing up a Neo4j server for a proof-of-concept or similar, then a sandbox instance on Neo4j&#39;s servers may do the trick. Check out https://sandbox.neo4j.com/",0,61578900
5891,https://stackoverflow.com/a/61579088,"Find the actors who DID NOT act with Hugo Weaving but acted with his co-stars, and SET a property act with value as didnot on those actors",false,"Can you please try below code, it gives me 48 such actors.

    MATCH(hw:Person{name:&quot;Hugo Weaving&quot;})-[:ACTED_IN]-&gt;(m:Movie)&lt;-[:ACTED_IN]-(co:Person)
    WITH hw, co
    MATCH (co)-[:ACTED_IN]-&gt;(m2:Movie)&lt;-[:ACTED_IN]-(co2:Person)
    WHERE co2.name &lt;&gt; &quot;Hugo Weaving&quot;
    AND NOT (co2)-[:ACTED_IN]-&gt;(:Movie)&lt;-[:ACTED_IN]-(hw)
    RETURN DISTINCT co2.name

Few of them are:

    &quot;David Morse&quot;
    &quot;Sam Rockwell&quot;
    &quot;Gary Sinise&quot;
    &quot;James Cromwell&quot;
    &quot;Bonnie Hunt&quot;
    &quot;Patricia Clarkson&quot;
    &quot;Michael Clarke Duncan&quot;
    ....",0,61579088
5892,https://stackoverflow.com/a/61575234,"Cypher query to count the number of relationships of specific type that each node has, including same type relationships in their sub-nodes",true,"For future visitors, this is the solution from an answer I got from neo4j online community:

    MATCH (category:Category)
    OPTIONAL MATCH (category)-[:IS_PARENT_OF*..10]-&gt;(c)
    OPTIONAL MATCH (category)&lt;-[:IS_CATEGORIZED_AS]-(item1:Item)
    OPTIONAL MATCH (c)&lt;-[:IS_CATEGORIZED_AS]-(item2:Item)
    RETURN category.name AS category,
       count(DISTINCT(c)) AS childCount,
       count(DISTINCT(item1)) + count(DISTINCT(item2)) AS itemCount


For more details see here: 

https://community.neo4j.com/t/cypher-query-to-count-the-number-of-relationships-of-specific-type-that-each-node-has-including-same-type-relationships-in-their-sub-nodes-ask-question/17987",0,61575234
5893,https://stackoverflow.com/a/61530925,query with regex in neo4j doesn&#39;t return the correct result,true,"Your value contains line endings. Include the DOTALL option with ?s

    MATCH (t:Tweet)
    WHERE  
        t.full_text =~ &#39;(?is).*sciacalli.*&#39;  AND
        t.created_at&gt;&#39;2018/01/01&#39; AND t.created_at&lt;&#39;2020/04/25&#39;
    RETURN t",1,61530925
5894,https://stackoverflow.com/a/61528893,Percentage categorization in Neo4j,true,"I assume you want to set a new property on the Customer nodes to reflect this &#39;category&#39;. How about this?

    MATCH  (c:Customer)-[b:BUY]-&gt;(p:Product)
    WITH SUM(b.count*p.unit_price) As total
    MATCH (c:Customer)-[b:BUY]-&gt;(p:Product)
    WITH c, 100.0 * SUM(b.count*p.unit_price) / total AS percent 
    SET c.category = CASE
                       WHEN percent &lt; 50 THEN &#39;A&#39;
                       WHEN percent &gt;= 50 AND percent &lt; 75 THEN &#39;B&#39;
    		           ELSE &#39;C&#39;
                     END;",0,61528893
5895,https://stackoverflow.com/a/61529115,Percentage categorization in Neo4j,false,"Using 2 identical `MATCH` clauses is usually a sign that you are making unnecessary DB hits, which you should avoid if you want an efficient query.

Here is a query that just needs a single `MATCH` and also returns a `category`:

    MATCH  (c:Customer)-[b:BUY]-&gt;(p:Product)
    WITH c, SUM(b.count*p.unit_price) As cTotal
    WITH COLLECT({customer:c.name, cTotal: cTotal}) AS data, SUM(cTotal) AS total
    UNWIND data AS d
    WITH d.customer AS customer, 100.0 * d.cTotal / total AS percent 
    ORDER BY percent DESC
    RETURN customer, percent, CASE WHEN percent &lt; 50 THEN &#39;A&#39; ELSE &#39;B&#39; END AS category

`cTotal` is the total per customer (because in the first `WITH` clause `c` is used as the grouping key of the [aggregating function](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) `SUM`).",0,61529115
5896,https://stackoverflow.com/a/61530458,Import csv into Neo4j where multiple columns have empty cells,true,"You have multiple issues.

 1. A big issue is that your Comma Separated Values (CSV) file is badly formatted. By default, as the name implies, a CSV file should use the comma character as the value delimiter. Your data file has no commas at all. Here is a properly formatted version of your file:

        Group,Capability,Functionality,Status,Dev,Input,Output
        Pipeline,DataIngest,Read CSV,Complete,Ben,source.csv,masterTable
        Pipeline,DataQuality,Quality score,Complete,,masterTable
        Analytics,Summary,Minimum score,In progress,Jill,masterTable,dataSummary
        Analytics,Summary,Maximum score,In progress,,masterTable,dataSummary
        Analytics,Prediction,Future score
        Output,Report,Bar chart,Not started,Ben,dataSummary
        Output,Report,Line chart,Not started,Fred

  Notice how &quot;empty&quot; values are represented by consecutive commas, or if they are at the end of a line they are just omitted. Values can have embedded spaces.

 2. You have a typo. `DevStage` should be `Dev`.

 3. The clauses that depend on `f` must not be executed unless the `f` node was created, and they must be executed when `f` is in scope. `f` is out of scope outside of the `FOREACH` clause.

 4. Recent versions of neo4j no longer support `CREATE UNIQUE`, and `MERGE` should be used instead.

Here is a query that solves issues 2 through 4, and relies on the above proper data format:

    LOAD CSV WITH HEADERS FROM &#39;file:///MasterSheet.csv&#39; AS line
    MERGE (g:Group {name: line.Group})
    MERGE (c:Capability {name: line.Capability})
    MERGE (g)-[:PART_OF]-&gt;(c)
    FOREACH(x IN CASE WHEN line.Dev IS NOT NULL THEN [1] END |
      MERGE (f:Functionality {name: line.Functionality, status: line.Status, developer: line.Dev})
      MERGE (c)-[:HAS]-&gt;(f)
      FOREACH(x IN CASE WHEN line.Input IS NOT NULL THEN [1] END |
        MERGE (i:Data {name: line.Input})
        MERGE (f)-[:INPUT]-&gt;(i)
      )
      FOREACH(x IN CASE WHEN line.Output IS NOT NULL THEN [1] END |
        MERGE (o:Data {name: line.Output})
        MERGE (f)-[:OUTPUT]-&gt;(o)
      )
    )

*NOTE: Your expected output data visualization is not possible with your sample data.*",1,61530458
5897,https://stackoverflow.com/a/61532475,Cypher query for list pattern,true,"This should work:

    MATCH (e:Email)
    UNWIND (e.cibil_email_addresses + e.active_email_address) AS address
    WITH address, COLLECT(e) AS es
    UNWIND es AS email
    MATCH (email)&lt;-[:MAIL_AT]-(cust)
    RETURN address, COLLECT(cust) AS customers

The `WITH` clause takes advantage of the [arregating function](https://neo4j.com/docs/developer-manual/current/cypher/functions/aggregating/) `COLLECT` to automatically collect all the `Email` nodes containing the same address, using `address` as the grouping key.

*You should only ask one question at a time. You have a couple of other questions at the bottom. If you continue to need help with them, please create new questions.*",1,61532475
5898,https://stackoverflow.com/a/61511934,Return nodes with and without a relation,true,"Optional match is what you&#39;re looking for:

MATCH (a:TypeA)
OPTIONAL MATCH (a)-[r]-&gt;(b:TypeB)
RETURN a, b

https://neo4j.com/docs/cypher-manual/current/clauses/optional-match/",0,61511934
5899,https://stackoverflow.com/a/61512796,Return nodes with and without a relation,false,"This query will return each `TypeA` in a separate row, along with a (possibly empty) list of `TypeB` end nodes:

    MATCH (a:TypeA) 
    RETURN a, [(a)--&gt;(b:TypeB) | b] AS bs",0,61512796
5900,https://stackoverflow.com/a/61488990,Neo4j query combining data from Elasticsearch for time based graph,true,"Assuming that:

- `RELATED_TO` relationships have a `uuid` property for the relationship id, and
- the `Entity` id and the &quot;buckets&quot; list are passed to the query as the [parameters](https://neo4j.com/docs/cypher-manual/current/syntax/parameters/) `entityId` and `buckets`, this should work:

        UNWIND $buckets AS b
        MATCH (e1:Entity)-[r1:RELATED_TO]-(e2)
        WHERE e1.uuid = $entityId AND r1.uuid = b.key
        RETURN e1, r1, e2, b.doc_count AS count
        ORDER BY count DESC

The `LIMIT` clause is not needed, since the number of result rows will be determined by the size of the `buckets` list.",0,61488990
5901,https://stackoverflow.com/a/61487015,Cypher sorting by number of related nodes?,true,"Give this a try:

    MATCH (p:Person)
    WHERE p.name = &quot;Lillian&quot; AND size((p)-[:FAMILY_REL]-&gt;()) = 2
    WITH p, [(p)-[:FAMILY_REL]-&gt;(child) WHERE (child)-[:PARTY_TO]-&gt;(:Crime) | child] as childCriminals
    WHERE size(childCriminals) = 2
    UNWIND childCriminals as s
    RETURN p, s

Note that this will only work if Lillian has exactly two children, and both have been party to a crime.

As for why your query wasn&#39;t working, it&#39;s likely that one of the children was party to two crimes, that would produce results.",1,61487015
5902,https://stackoverflow.com/a/61467684,What is missing in this Cypher query?,false,"`SIZE((p)-[:FAMILY_REL]-&gt;())` counts *all* children of `p`, including ones who had committed no crimes.

This query should work better, as it only counts children who are criminals:

    MATCH (:Crime)&lt;-[:PARTY_TO]-(p:Person)-[:FAMILY_REL]-&gt;(s:Person)-[:PARTY_TO]-&gt;(:Crime)
    WITH p, COLLECT(s) AS badKids
    WHERE SIZE(badKids) = 2
    RETURN p, badKids",1,61467684
5903,https://stackoverflow.com/a/61483528,Best practice to match nodes,false,"Here are the execution plans for each of the queries
```
127.0.0.1:6379&gt; graph.explain test &quot;MATCH (:category {_id:1})-[:post]-&gt;(:post {_id:1})-[comment_rel_1:comment]-&gt;(c1:comment {_id:1}) SET c1.comment = &#39;changed&#39;&quot;
1) &quot;Update&quot;
2) &quot;    Filter&quot;
3) &quot;        Conditional Traverse | (anon_2:post)-&gt;(c1:comment)&quot;
4) &quot;            Filter&quot;
5) &quot;                Conditional Traverse | (anon_0:category)-&gt;(anon_2:post)&quot;
6) &quot;                    Index Scan | (anon_0:category)&quot;

127.0.0.1:6379&gt; graph.explain test &quot;MATCH (c1:comment {_id:1}) SET c1.comment = &#39;changed&#39;&quot;
1) &quot;Update&quot;
2) &quot;    Index Scan | (c1:comment)&quot;
```
In case that you just want to update the comment node, regardless to its state in the graph, the second query is more efficient. In case you want to update only the comment node that is connected in the pattern that you described, the first query is the way to go, between the two.",2,61483528
5904,https://stackoverflow.com/a/61456347,Cypher sort by amount of same relationship?,false,"You can use the `count` function to get the count of sons for each person. Then filter out the persons based on the count.

    MATCH (p:Person)-[r:SON]-&gt;(:Person)
    WITH p, count(r) as sons 
    WHERE sons=2
    RETURN p
",1,61456347
5905,https://stackoverflow.com/a/61456815,Cypher sort by amount of same relationship?,true,"You can use size() in the where clause, like so:

    match (p:Person) where size((p)-[:SON]-&gt;())=2 return p

",2,61456815
5906,https://stackoverflow.com/a/61450255,I am using NEO4J apoc.refactor.setType to change the rel type of a relationship with no luck,true,"You can use the [apoc.help](https://neo4j.com/docs/labs/apoc/current/help/) procedure to see the signature of APOC functions. For example, the result of this statement:

    CALL apoc.help(&quot;apoc.refactor.setType&quot;)

is:

    ╒═══════════╤══════════════════╤══════════════════╤══════════════════╤═══════╤════════╕
    │&quot;type&quot;     │&quot;name&quot;            │&quot;text&quot;            │&quot;signature&quot;       │&quot;roles&quot;│&quot;writes&quot;│
    ╞═══════════╪══════════════════╪══════════════════╪══════════════════╪═══════╪════════╡
    │&quot;procedure&quot;│&quot;apoc.refactor.set│&quot;apoc.refactor.set│&quot;apoc.refactor.set│null   │null    │
    │           │Type&quot;             │Type(rel, &#39;NEW-TYP│Type(relationship │       │        │
    │           │                  │E&#39;) change relatio│:: RELATIONSHIP?, │       │        │
    │           │                  │nship-type&quot;       │newType :: STRING?│       │        │
    │           │                  │                  │) :: (input :: INT│       │        │
    │           │                  │                  │EGER?, output :: R│       │        │
    │           │                  │                  │ELATIONSHIP?, erro│       │        │
    │           │                  │                  │r :: STRING?)&quot;    │       │        │
    └───────────┴──────────────────┴──────────────────┴──────────────────┴───────┴────────┘

So, `apoc.refactor.setType` has these yieldable variables: `input`, `output` and `error`.

This query should work for you:

    MATCH (user:Owner {email: &quot;xyz@mymail.com&quot;})-[r:OWNS]-&gt;(v:Vehicles {name:&quot;Chevy&quot;})
    WHERE r.model = &quot;Silverado&quot; OR NOT EXISTS(r.model)
    CALL apoc.refactor.setType(r, &#39;OWNED&#39;) YIELD output
    RETURN user, output AS r, v

",1,61450255
5907,https://stackoverflow.com/a/61786521,How to send out a collection of nodes via neo4j-stream to kafka,true,"The [streams.publish procedure][1] will send any arbitrary data that you can format with Cypher to the topic of your choosing.  It&#39;s just up to you to format the data as you wish.

I&#39;m imagining something like this:

```
MATCH (a:MyLabel { id: &#39;startingPoint&#39; })
WITH a
MATCH p=shortestPath((a)-[:REL*]-&gt;(b:MyLabel { id: &#39;EndingPoint&#39; }))
UNWIND nodes(p) as node
WITH collect({ 
    my: &#39;custom-object&#39;,
    prop: node.prop
}) as recordsToSendToKafka
CALL streams.publish(&#39;my-topic&#39;, recordsToSendToKafka)
```

This would send an array of JSON records formatted as you choose, from the original matched path.

Note that using APOC triggers, you can do these kinds of things _in response to other transactions within Neo4j_, and so this doesn&#39;t have to be a one-and-done manual execute query pattern.

tl;dr if you can match anything out of the database, you can use cypher to reformat it into JSON objects and dispatch any data to any topic on Kafka.



  [1]: https://neo4j.com/docs/labs/neo4j-streams/current/procedure/#_streams_publish",2,61786521
5908,https://stackoverflow.com/a/61447621,Neo4j Filter function is no longer supported,true,"You can use the [list comprehension](https://neo4j.com/docs/cypher-manual/4.0/syntax/lists/#cypher-list-comprehension) syntax instead of the obsolete `filter` function:

    MATCH (cu:Customer{name: &quot;myCustomer&quot;})-[pu:PURCHASED]-&gt;(o:Order)-[*]-&gt;(cat:Category)&lt;-[:IS_a]-(b:Book)
    WITH COLLECT(DISTINCT pu.ISBN) AS purchasedbooks, COLLECT(DISTINCT b.ISBN) AS booksFromTheSameCategory
    RETURN [n IN booksFromTheSameCategory WHERE NOT n IN purchasedbooks] as listC

*You can see Cypher syntax change documentation on [this page](https://neo4j.com/docs/cypher-manual/4.0/deprecations-additions-removals-compatibility/#cypher-deprecations-additions-removals-4.0).*

",6,61447621
5909,https://stackoverflow.com/a/61574487,Neo4j - Neo4jClient - Deserialize from Cypher Results,true,"This was failing because of the datetime I was using. The datetime in the database had the following format (it included timezone) &quot;1939-06-23T01:00:00+01:00&quot;. Chopping the +01:00 off the end got it working with the Person object with a datetime as 
```C#
public DateTime BirthDate { get; set; }
```
using Neo4j.Driver.V1 in the object class allowed me to specify a ZonedDateTime. Which worked with the original date format that included the timezone
```C#
public ZonedDateTime BirthDate { get; set; }
```
Thanks very much Chris without your comments I would have stumbled around a lot longer.",1,61574487
5910,https://stackoverflow.com/a/61445468,Why this neo4j cypher query fails to rewrite?,false,I have solved the issue by updating APOC to 4.0.0.8 and by installing Neo4j via the apt repository.,1,61445468
